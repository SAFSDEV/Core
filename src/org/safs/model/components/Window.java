
/******************************************************************************
 * Window.java
 *
 * Copyright (c) by SAS Institute Inc., Cary, NC 27513
 * General Public License: http://www.opensource.org/licenses/gpl-license.php
 *
 * !!! DO NOT EDIT THIS FILE !!!
 * This file is automatically generated from XML source.  Any changes you make 
 * here will be erased the next time the file is generated.
 *
 * The following assets are needed to generate this file:
 *
 *   WindowFunctions.xml
 *   keyword_library.dtd
 *   XSLJavaCommonFunctions.xsl
 *   XSLJavaComponentModel.xsl
 *
 * Example invocation to generate:
 *
 *   msxsl.exe WindowFunctions.xml XSLJavaComponentModel.xsl -o Window.java
 *
 ******************************************************************************/ 
package org.safs.model.components;

import org.safs.model.commands.WindowFunctions;
import org.safs.model.ComponentFunction;
import org.safs.model.components.UIComponent;
import org.safs.model.StepTestTable;

public class Window extends GenericObject {

    /*****************
    Constructor 

    Create an instance of pseudo-Window representing 
    a specific AppMap window.
    
    @param winname  Optional:NO 
           Specifies the AppMap name of the window.
    ****************/
    public Window(String winname) {

        super(winname);
        setWindow(this);
    }



    /*********** <pre> 
                Performs a click on any part of a Window based on a stored x,y coordinate.
               
                For components that are unrecognized, like ActiveToolbar menuitems, 
                we can click on these or any part of a Window based on a stored x,y 
                coordinate.  The window containing the coordinate is first given 
                context and then a click is generated at the coordinate.  Thus, an item 
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                 
                (1) t MainWindow MainWindow Click AnObject
                (2) t MainWindow FileMenu  Click Exit
                
                #1 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click at x=3, y=10 in the MainWindow.
                
                #2 above will contain a FileMenu entry in the MainWindow section with 
                normal recognition information for it (the type, however, should still 
                be "Window" even if unspecified).  FileMenu will also have it's
                own section in the Application Map in which there will be an entry like 
                Exit="15,30".  This will tell Robot to locate the FileMenu Window 
                object and click at the coordinates specified by the reference.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup and use for the click.
              
     **********/
    public ComponentFunction click(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "click.appMapSubkey = null");
        return WindowFunctions.click(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                Performs a click on any part of a Window based on a stored x,y coordinate.
               
                For components that are unrecognized, like ActiveToolbar menuitems, 
                we can click on these or any part of a Window based on a stored x,y 
                coordinate.  The window containing the coordinate is first given 
                context and then a click is generated at the coordinate.  Thus, an item 
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                 
                (1) t MainWindow MainWindow Click AnObject
                (2) t MainWindow FileMenu  Click Exit
                
                #1 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click at x=3, y=10 in the MainWindow.
                
                #2 above will contain a FileMenu entry in the MainWindow section with 
                normal recognition information for it (the type, however, should still 
                be "Window" even if unspecified).  FileMenu will also have it's
                own section in the Application Map in which there will be an entry like 
                Exit="15,30".  This will tell Robot to locate the FileMenu Window 
                object and click at the coordinates specified by the reference.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup and use for the click.
              
     **********/
    public void click(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "click.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "click.appMapSubkey = null");
        table.add( WindowFunctions.click(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                Sends a Close command to the active window.
               
	      
		
		   
			
			    
			
		   
		
		
                This Window command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, CloseWindow
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to the command.
                
                t, ParentWindow, ParentWindow, CloseWindow
                t, ChildWindow , ChildWindow , CloseWindow  (normally won't work)
		
	      
	      
		
		    
			
			    
			
		    
		
		Closes the "current" or "lastUsed" WebDriver associated with the found Window component.
	      
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    </UL>

     **********/
    public ComponentFunction closeWindow( ) {

        return WindowFunctions.closeWindow(getWindow().getName(), getName());
    }

    /*********** <pre> 
                Sends a Close command to the active window.
               
	      
		
		   
			
			    
			
		   
		
		
                This Window command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, CloseWindow
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to the command.
                
                t, ParentWindow, ParentWindow, CloseWindow
                t, ChildWindow , ChildWindow , CloseWindow  (normally won't work)
		
	      
	      
		
		    
			
			    
			
		    
		
		Closes the "current" or "lastUsed" WebDriver associated with the found Window component.
	      
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void closeWindow(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "closeWindow.table = null");

        table.add( WindowFunctions.closeWindow(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                Performs a WindowVP CompareProperties on an object.  
               
                Performs a WindowVP CompareProperties on an object.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                To make an existing VP an asset of the current script,
                the existing script, e.g.,
                
                MADHATTERScript.MyObjectVP.base.OBP
                
                can be copied and renamed to
                
                MyDDScript.MyObjectVP.base.OBP
                
                where MyDDScript is the name of the current script.
                
                The name of the actual VP, MyObjectVP, cannot be altered.
                
                Example 1: Perform a WindowVP on a given window
                
                t, MainWindow, MainWindow, CompareStoredProperties, MainSetupVP1
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param vPAsset  Optional:NO 
                 Name of the pre-existing VP asset stored in the currently running script.
              
     **********/
    public ComponentFunction compareStoredProperties(String vPAsset ) {

        if ( vPAsset == null ) throw new IllegalArgumentException ( "compareStoredProperties.vPAsset = null");
        return WindowFunctions.compareStoredProperties(getWindow().getName(), getName(), vPAsset);
    }

    /*********** <pre> 
                Performs a WindowVP CompareProperties on an object.  
               
                Performs a WindowVP CompareProperties on an object.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                To make an existing VP an asset of the current script,
                the existing script, e.g.,
                
                MADHATTERScript.MyObjectVP.base.OBP
                
                can be copied and renamed to
                
                MyDDScript.MyObjectVP.base.OBP
                
                where MyDDScript is the name of the current script.
                
                The name of the actual VP, MyObjectVP, cannot be altered.
                
                Example 1: Perform a WindowVP on a given window
                
                t, MainWindow, MainWindow, CompareStoredProperties, MainSetupVP1
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param vPAsset  Optional:NO 
                 Name of the pre-existing VP asset stored in the currently running script.
              
     **********/
    public void compareStoredProperties(StepTestTable table, String vPAsset ) {

        if ( table == null ) throw new IllegalArgumentException ( "compareStoredProperties.table = null");

        if ( vPAsset == null ) throw new IllegalArgumentException ( "compareStoredProperties.vPAsset = null");
        table.add( WindowFunctions.compareStoredProperties(getWindow().getName(), getName(), vPAsset));
    }

    /*********** <pre> 
                Performs a double-click on any part of a Window based on a stored x,y coordinate.
               
                For components that are unrecognized, like ActiveToolbar menuitems, 
                we can double click on these or any part of a Window based on a stored 
                x,y coordinate.  The window containing the coordinate is first given 
                context and then a double click is generated at the coordinate.  Thus, 
                an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                 
                Typical Data Table records:
                
                (1) t MainWindow MainWindow DoubleClick AnObject
                (2) t MainWindow FolderTree DoubleClick Node1
                
                #1 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to double click at x=3, y=10 in the MainWindow.
                
                #2 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it .  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree 
                object and double click at the coordinates specified by the reference.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup and use for the double-click.
              
     **********/
    public ComponentFunction doubleClick(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "doubleClick.appMapSubkey = null");
        return WindowFunctions.doubleClick(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                Performs a double-click on any part of a Window based on a stored x,y coordinate.
               
                For components that are unrecognized, like ActiveToolbar menuitems, 
                we can double click on these or any part of a Window based on a stored 
                x,y coordinate.  The window containing the coordinate is first given 
                context and then a double click is generated at the coordinate.  Thus, 
                an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                 
                Typical Data Table records:
                
                (1) t MainWindow MainWindow DoubleClick AnObject
                (2) t MainWindow FolderTree DoubleClick Node1
                
                #1 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to double click at x=3, y=10 in the MainWindow.
                
                #2 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it .  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree 
                object and double click at the coordinates specified by the reference.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup and use for the double-click.
              
     **********/
    public void doubleClick(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "doubleClick.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "doubleClick.appMapSubkey = null");
        table.add( WindowFunctions.doubleClick(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                     Gets the value of any property in a window.
                    
                     Gets the value of any property in a window and assigns that property
                     to a variable for later use.
                     
                     
                       </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param propertyName  Optional:NO 
                     The name of the property to retrieve.
                   
     @param variableName  Optional:NO 
			  The name of the variable that the property value should be stored in.
			
     **********/
    public ComponentFunction getWinInfo(String propertyName, String variableName ) {

        if ( propertyName == null ) throw new IllegalArgumentException ( "getWinInfo.propertyName = null");
        if ( variableName == null ) throw new IllegalArgumentException ( "getWinInfo.variableName = null");
        return WindowFunctions.getWinInfo(getWindow().getName(), getName(), propertyName, variableName);
    }

    /*********** <pre> 
                     Gets the value of any property in a window.
                    
                     Gets the value of any property in a window and assigns that property
                     to a variable for later use.
                     
                     
                       </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param propertyName  Optional:NO 
                     The name of the property to retrieve.
                   
     @param variableName  Optional:NO 
			  The name of the variable that the property value should be stored in.
			
     **********/
    public void getWinInfo(StepTestTable table, String propertyName, String variableName ) {

        if ( table == null ) throw new IllegalArgumentException ( "getWinInfo.table = null");

        if ( propertyName == null ) throw new IllegalArgumentException ( "getWinInfo.propertyName = null");
        if ( variableName == null ) throw new IllegalArgumentException ( "getWinInfo.variableName = null");
        table.add( WindowFunctions.getWinInfo(getWindow().getName(), getName(), propertyName, variableName));
    }

    /*********** <pre> 
                     Gets the value of any property in a window.
                    
                     Gets the value of any property in a window and assigns that property
                     to a variable for later use.
                     
                     
                       </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO 
                     The name of the property to retrieve.
                   <BR/>         variableName -- Optional:NO 
			  The name of the variable that the property value should be stored in.
			
    </UL>

     **********/
    public ComponentFunction getWinInfo(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "getWinInfo.parameters = null");
        return WindowFunctions.getWinInfo(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                     Gets the value of any property in a window.
                    
                     Gets the value of any property in a window and assigns that property
                     to a variable for later use.
                     
                     
                       </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO 
                     The name of the property to retrieve.
                   <BR/>         variableName -- Optional:NO 
			  The name of the variable that the property value should be stored in.
			
    </UL>

     **********/
    public void getWinInfo(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "getWinInfo.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "getWinInfo.parameters = null");
        table.add( WindowFunctions.getWinInfo(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                     Make the application\device "go back" to the previous state or window.
                    
                     This is largely for apps or devices--like mobile devices--that have the ability to 
                     "go back" that might be activated by a control that is NOT always part of 
                     the application GUI.  Example: a hardware "back" button or menu button that is not 
                     part of the application itself.
                     
                     Depending upon the technology implementation, The WINDOWNAME may not have to be 
                     valid or exist at the time of invocation.  That is, the WINDOWNAME and COMPNAME 
                     fields might not be used and can contain anything.                     
                     
                       </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    </UL>

     **********/
    public ComponentFunction goBack( ) {

        return WindowFunctions.goBack(getWindow().getName(), getName());
    }

    /*********** <pre> 
                     Make the application\device "go back" to the previous state or window.
                    
                     This is largely for apps or devices--like mobile devices--that have the ability to 
                     "go back" that might be activated by a control that is NOT always part of 
                     the application GUI.  Example: a hardware "back" button or menu button that is not 
                     part of the application itself.
                     
                     Depending upon the technology implementation, The WINDOWNAME may not have to be 
                     valid or exist at the time of invocation.  That is, the WINDOWNAME and COMPNAME 
                     fields might not be used and can contain anything.                     
                     
                       </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void goBack(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "goBack.table = null");

        table.add( WindowFunctions.goBack(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                Sends literal text to the active window via an InputChars command.
               
                Sends literal text to the active window via an InputChars command.
                The InputChars command does not convert or interpret any special 
                characters like InputKeys (InputKeystrokes) does.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param textValue  Optional:NO 
                String of keystrokes to send.
              
     **********/
    public ComponentFunction inputCharacters(String textValue ) {

        if ( textValue == null ) throw new IllegalArgumentException ( "inputCharacters.textValue = null");
        return WindowFunctions.inputCharacters(getWindow().getName(), getName(), textValue);
    }

    /*********** <pre> 
                Sends literal text to the active window via an InputChars command.
               
                Sends literal text to the active window via an InputChars command.
                The InputChars command does not convert or interpret any special 
                characters like InputKeys (InputKeystrokes) does.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param textValue  Optional:NO 
                String of keystrokes to send.
              
     **********/
    public void inputCharacters(StepTestTable table, String textValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "inputCharacters.table = null");

        if ( textValue == null ) throw new IllegalArgumentException ( "inputCharacters.textValue = null");
        table.add( WindowFunctions.inputCharacters(getWindow().getName(), getName(), textValue));
    }

    /*********** <pre> 
                Sends keystrokes to the active window via an InputKeys command.
               
                Sends keystrokes to the active window via an InputKeys command.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param textValue  Optional:NO 
                String of keystrokes to send.
              
     **********/
    public ComponentFunction inputKeys(String textValue ) {

        if ( textValue == null ) throw new IllegalArgumentException ( "inputKeys.textValue = null");
        return WindowFunctions.inputKeys(getWindow().getName(), getName(), textValue);
    }

    /*********** <pre> 
                Sends keystrokes to the active window via an InputKeys command.
               
                Sends keystrokes to the active window via an InputKeys command.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param textValue  Optional:NO 
                String of keystrokes to send.
              
     **********/
    public void inputKeys(StepTestTable table, String textValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "inputKeys.table = null");

        if ( textValue == null ) throw new IllegalArgumentException ( "inputKeys.textValue = null");
        table.add( WindowFunctions.inputKeys(getWindow().getName(), getName(), textValue));
    }

    /*********** <pre> 
                Sends a WMaximize command to the active window.
               
                Sends a WMaximize command to the active window.
                
                This Window command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                 
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, Maximize
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to the command.
                
                t, ParentWindow, ParentWindow, Maximize
                t, ChildWindow , ChildWindow , Maximize   (normally won't work)
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     **********/
    public ComponentFunction maximize( ) {

        return WindowFunctions.maximize(getWindow().getName(), getName());
    }

    /*********** <pre> 
                Sends a WMaximize command to the active window.
               
                Sends a WMaximize command to the active window.
                
                This Window command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                 
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, Maximize
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to the command.
                
                t, ParentWindow, ParentWindow, Maximize
                t, ChildWindow , ChildWindow , Maximize   (normally won't work)
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void maximize(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "maximize.table = null");

        table.add( WindowFunctions.maximize(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                Sends a WMinimize command to the active window.
               
                Sends a WMinimize command to the active window.
                
                This Window command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, Minimize
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to the command.
                
                t, ParentWindow, ParentWindow, Minimize
                t, ChildWindow , ChildWindow , Minimize   (normally won't work)
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     **********/
    public ComponentFunction minimize( ) {

        return WindowFunctions.minimize(getWindow().getName(), getName());
    }

    /*********** <pre> 
                Sends a WMinimize command to the active window.
               
                Sends a WMinimize command to the active window.
                
                This Window command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, Minimize
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to the command.
                
                t, ParentWindow, ParentWindow, Minimize
                t, ChildWindow , ChildWindow , Minimize   (normally won't work)
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void minimize(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "minimize.table = null");

        table.add( WindowFunctions.minimize(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                     Perform a shrinking "zoom out" operation on a touchscreen device supporting the feature.
                    
                     Perform a shrinking "zoom out" operation on a touchscreen device supporting the feature.
                     
                     Effectively shrinks a user-defined rectangular area on the screen.
                     
                     IOS expects the Window/Component to be the main active Window of the application.
                     
                       </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param originSubKey  Optional:NO 
                     The AppMapSubkey that contains the onscreen rectangle for the pinch operation.
                   
     @param resizeSubKey  Optional:NO 
                     Name of the AppMap subkey to lookup for the resize value or the literal text of 
                     the resize values.
                   
     @param duration  Optional:YES  DefaultVal:1The number of seconds to take for the operation.
     **********/
    public ComponentFunction pinchClose(String originSubKey, String resizeSubKey, String duration ) {

        if ( originSubKey == null ) throw new IllegalArgumentException ( "pinchClose.originSubKey = null");
        if ( resizeSubKey == null ) throw new IllegalArgumentException ( "pinchClose.resizeSubKey = null");
        return WindowFunctions.pinchClose(getWindow().getName(), getName(), originSubKey, resizeSubKey, duration);
    }

    /*********** <pre> 
                     Perform a shrinking "zoom out" operation on a touchscreen device supporting the feature.
                    
                     Perform a shrinking "zoom out" operation on a touchscreen device supporting the feature.
                     
                     Effectively shrinks a user-defined rectangular area on the screen.
                     
                     IOS expects the Window/Component to be the main active Window of the application.
                     
                       </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param originSubKey  Optional:NO 
                     The AppMapSubkey that contains the onscreen rectangle for the pinch operation.
                   
     @param resizeSubKey  Optional:NO 
                     Name of the AppMap subkey to lookup for the resize value or the literal text of 
                     the resize values.
                   
     @param duration  Optional:YES  DefaultVal:1The number of seconds to take for the operation.
     **********/
    public void pinchClose(StepTestTable table, String originSubKey, String resizeSubKey, String duration ) {

        if ( table == null ) throw new IllegalArgumentException ( "pinchClose.table = null");

        if ( originSubKey == null ) throw new IllegalArgumentException ( "pinchClose.originSubKey = null");
        if ( resizeSubKey == null ) throw new IllegalArgumentException ( "pinchClose.resizeSubKey = null");
        table.add( WindowFunctions.pinchClose(getWindow().getName(), getName(), originSubKey, resizeSubKey, duration));
    }

    /*********** <pre> 
                     Perform a shrinking "zoom out" operation on a touchscreen device supporting the feature.
                    
                     Perform a shrinking "zoom out" operation on a touchscreen device supporting the feature.
                     
                     Effectively shrinks a user-defined rectangular area on the screen.
                     
                     IOS expects the Window/Component to be the main active Window of the application.
                     
                       </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         originSubKey -- Optional:NO 
                     The AppMapSubkey that contains the onscreen rectangle for the pinch operation.
                   <BR/>         resizeSubKey -- Optional:NO 
                     Name of the AppMap subkey to lookup for the resize value or the literal text of 
                     the resize values.
                   <BR/>         duration -- Optional:YES  DefaultVal:1The number of seconds to take for the operation.
    </UL>

     **********/
    public ComponentFunction pinchClose(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "pinchClose.parameters = null");
        return WindowFunctions.pinchClose(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                     Perform a shrinking "zoom out" operation on a touchscreen device supporting the feature.
                    
                     Perform a shrinking "zoom out" operation on a touchscreen device supporting the feature.
                     
                     Effectively shrinks a user-defined rectangular area on the screen.
                     
                     IOS expects the Window/Component to be the main active Window of the application.
                     
                       </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         originSubKey -- Optional:NO 
                     The AppMapSubkey that contains the onscreen rectangle for the pinch operation.
                   <BR/>         resizeSubKey -- Optional:NO 
                     Name of the AppMap subkey to lookup for the resize value or the literal text of 
                     the resize values.
                   <BR/>         duration -- Optional:YES  DefaultVal:1The number of seconds to take for the operation.
    </UL>

     **********/
    public void pinchClose(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "pinchClose.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "pinchClose.parameters = null");
        table.add( WindowFunctions.pinchClose(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                     Perform an expanding "zoom in" operation on a touchscreen device supporting the feature.
                    
                     Perform an expanding "zoom in" operation on a touchscreen device supporting the feature.
                     
                     Effectively expands or stretches a user-defined rectangular area on the screen.
                     
                     IOS expects the Window/Component to be the main active Window of the application.
                     
                       </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param originSubKey  Optional:NO 
                     The AppMapSubkey that contains the onscreen rectangle for the pinch operation.
                   
     @param resizeSubKey  Optional:NO 
                     Name of the AppMap subkey to lookup for the resize value or the literal text of 
                     the resize values.
                   
     @param duration  Optional:YES  DefaultVal:1The number of seconds to take for the operation.
     **********/
    public ComponentFunction pinchOpen(String originSubKey, String resizeSubKey, String duration ) {

        if ( originSubKey == null ) throw new IllegalArgumentException ( "pinchOpen.originSubKey = null");
        if ( resizeSubKey == null ) throw new IllegalArgumentException ( "pinchOpen.resizeSubKey = null");
        return WindowFunctions.pinchOpen(getWindow().getName(), getName(), originSubKey, resizeSubKey, duration);
    }

    /*********** <pre> 
                     Perform an expanding "zoom in" operation on a touchscreen device supporting the feature.
                    
                     Perform an expanding "zoom in" operation on a touchscreen device supporting the feature.
                     
                     Effectively expands or stretches a user-defined rectangular area on the screen.
                     
                     IOS expects the Window/Component to be the main active Window of the application.
                     
                       </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param originSubKey  Optional:NO 
                     The AppMapSubkey that contains the onscreen rectangle for the pinch operation.
                   
     @param resizeSubKey  Optional:NO 
                     Name of the AppMap subkey to lookup for the resize value or the literal text of 
                     the resize values.
                   
     @param duration  Optional:YES  DefaultVal:1The number of seconds to take for the operation.
     **********/
    public void pinchOpen(StepTestTable table, String originSubKey, String resizeSubKey, String duration ) {

        if ( table == null ) throw new IllegalArgumentException ( "pinchOpen.table = null");

        if ( originSubKey == null ) throw new IllegalArgumentException ( "pinchOpen.originSubKey = null");
        if ( resizeSubKey == null ) throw new IllegalArgumentException ( "pinchOpen.resizeSubKey = null");
        table.add( WindowFunctions.pinchOpen(getWindow().getName(), getName(), originSubKey, resizeSubKey, duration));
    }

    /*********** <pre> 
                     Perform an expanding "zoom in" operation on a touchscreen device supporting the feature.
                    
                     Perform an expanding "zoom in" operation on a touchscreen device supporting the feature.
                     
                     Effectively expands or stretches a user-defined rectangular area on the screen.
                     
                     IOS expects the Window/Component to be the main active Window of the application.
                     
                       </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         originSubKey -- Optional:NO 
                     The AppMapSubkey that contains the onscreen rectangle for the pinch operation.
                   <BR/>         resizeSubKey -- Optional:NO 
                     Name of the AppMap subkey to lookup for the resize value or the literal text of 
                     the resize values.
                   <BR/>         duration -- Optional:YES  DefaultVal:1The number of seconds to take for the operation.
    </UL>

     **********/
    public ComponentFunction pinchOpen(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "pinchOpen.parameters = null");
        return WindowFunctions.pinchOpen(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                     Perform an expanding "zoom in" operation on a touchscreen device supporting the feature.
                    
                     Perform an expanding "zoom in" operation on a touchscreen device supporting the feature.
                     
                     Effectively expands or stretches a user-defined rectangular area on the screen.
                     
                     IOS expects the Window/Component to be the main active Window of the application.
                     
                       </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         originSubKey -- Optional:NO 
                     The AppMapSubkey that contains the onscreen rectangle for the pinch operation.
                   <BR/>         resizeSubKey -- Optional:NO 
                     Name of the AppMap subkey to lookup for the resize value or the literal text of 
                     the resize values.
                   <BR/>         duration -- Optional:YES  DefaultVal:1The number of seconds to take for the operation.
    </UL>

     **********/
    public void pinchOpen(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "pinchOpen.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "pinchOpen.parameters = null");
        table.add( WindowFunctions.pinchOpen(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Sends a RestorePos command to the active window.
               
                Sends a RestorePos command to the active window.
                
                This Window command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, Restore
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to the command.
                
                t, ParentWindow, ParentWindow, Restore
                t, ChildWindow , ChildWindow , Restore      (normally won't work)
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     **********/
    public ComponentFunction restore( ) {

        return WindowFunctions.restore(getWindow().getName(), getName());
    }

    /*********** <pre> 
                Sends a RestorePos command to the active window.
               
                Sends a RestorePos command to the active window.
                
                This Window command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, Restore
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to the command.
                
                t, ParentWindow, ParentWindow, Restore
                t, ChildWindow , ChildWindow , Restore      (normally won't work)
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void restore(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "restore.table = null");

        table.add( WindowFunctions.restore(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                Performs a right-click on any part of a Window based on a stored x,y coordinate.
               
                For components that are unrecognized, like ActiveToolbar menuitems, 
                we can right click on these or any part of a Window based on a stored x,y 
                coordinate.  The window containing the coordinate is first given 
                context and then a right click is generated at the coordinate.  Thus, an item 
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow RightClick AnObject
                (2) t MainWindow  ToolItem  RightClick PrintTool
                
                #1 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to right click at x=3, y=10 in the MainWindow.
                
                #2 above will contain a ToolItem entry in the MainWindow section with 
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like 
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window 
                object and right click at the coordinates specified by the reference.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup and use for the right-click.
              
     **********/
    public ComponentFunction rightClick(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "rightClick.appMapSubkey = null");
        return WindowFunctions.rightClick(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                Performs a right-click on any part of a Window based on a stored x,y coordinate.
               
                For components that are unrecognized, like ActiveToolbar menuitems, 
                we can right click on these or any part of a Window based on a stored x,y 
                coordinate.  The window containing the coordinate is first given 
                context and then a right click is generated at the coordinate.  Thus, an item 
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow RightClick AnObject
                (2) t MainWindow  ToolItem  RightClick PrintTool
                
                #1 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to right click at x=3, y=10 in the MainWindow.
                
                #2 above will contain a ToolItem entry in the MainWindow section with 
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like 
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window 
                object and right click at the coordinates specified by the reference.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup and use for the right-click.
              
     **********/
    public void rightClick(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "rightClick.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "rightClick.appMapSubkey = null");
        table.add( WindowFunctions.rightClick(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                Attempts to select a particular menuitem by menuID.
               
                Attempts to select a particular menuitem by menuID.  This is generally 
                used when the menuitem is a bitmap or other item that does not have 
                text.  This value can be retrieved from the the menu by index or by 
                manual lookup from a menu structure output from MenuUtilities.
                The routine first verifies that the specified menuitem exists and exits 
                with error if it does not.  If it does exist then the selection proceeds.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param menuID  Optional:NO 
                MenuID to identify which menuitem to select.
              
     **********/
    public ComponentFunction selectMenuID(String menuID ) {

        if ( menuID == null ) throw new IllegalArgumentException ( "selectMenuID.menuID = null");
        return WindowFunctions.selectMenuID(getWindow().getName(), getName(), menuID);
    }

    /*********** <pre> 
                Attempts to select a particular menuitem by menuID.
               
                Attempts to select a particular menuitem by menuID.  This is generally 
                used when the menuitem is a bitmap or other item that does not have 
                text.  This value can be retrieved from the the menu by index or by 
                manual lookup from a menu structure output from MenuUtilities.
                The routine first verifies that the specified menuitem exists and exits 
                with error if it does not.  If it does exist then the selection proceeds.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param menuID  Optional:NO 
                MenuID to identify which menuitem to select.
              
     **********/
    public void selectMenuID(StepTestTable table, String menuID ) {

        if ( table == null ) throw new IllegalArgumentException ( "selectMenuID.table = null");

        if ( menuID == null ) throw new IllegalArgumentException ( "selectMenuID.menuID = null");
        table.add( WindowFunctions.selectMenuID(getWindow().getName(), getName(), menuID));
    }

    /*********** <pre> 
                Attempts to select a particular text string menuitem.
               
                Attempts to select a particular text string menuitem.  The menuitem 
                should be specified in the form "Menu->Menu->MenuItem   CTRL+V" 
                with the full text, spaces(if any), and keyboard shortcut text (if
                any).
                
                Ampersands preceding underlined characters are optional.
                The routine first verifies that the specified menuitem exists
                and exits with error if it does not.
                If it does exist then the selection proceeds using the MenuID retrieved
                from the found menuitem.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param textValue  Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to select.
              
     **********/
    public ComponentFunction selectMenuItem(String textValue ) {

        if ( textValue == null ) throw new IllegalArgumentException ( "selectMenuItem.textValue = null");
        return WindowFunctions.selectMenuItem(getWindow().getName(), getName(), textValue);
    }

    /*********** <pre> 
                Attempts to select a particular text string menuitem.
               
                Attempts to select a particular text string menuitem.  The menuitem 
                should be specified in the form "Menu->Menu->MenuItem   CTRL+V" 
                with the full text, spaces(if any), and keyboard shortcut text (if
                any).
                
                Ampersands preceding underlined characters are optional.
                The routine first verifies that the specified menuitem exists
                and exits with error if it does not.
                If it does exist then the selection proceeds using the MenuID retrieved
                from the found menuitem.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param textValue  Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to select.
              
     **********/
    public void selectMenuItem(StepTestTable table, String textValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "selectMenuItem.table = null");

        if ( textValue == null ) throw new IllegalArgumentException ( "selectMenuItem.textValue = null");
        table.add( WindowFunctions.selectMenuItem(getWindow().getName(), getName(), textValue));
    }

    /*********** <pre> 
                Attempts to select a menuitem based on a partial text match.
               
                Attempts to select a menuitem based on a partial text match.  
                The menuitem should be specified in the form "Menu->Menu->MenuItem".
                Each level in the hierarchy can be represented by partial text.
                
                Ampersands preceding underlined characters are optional.
                The routine first verifies that the specified menuitem exists
                and exits with error if it does not.
                If it does exist then the selection proceeds using the MenuID retrieved
                from the found menuitem.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param textValue  Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to select.
              
     **********/
    public ComponentFunction selectMenuItemContains(String textValue ) {

        if ( textValue == null ) throw new IllegalArgumentException ( "selectMenuItemContains.textValue = null");
        return WindowFunctions.selectMenuItemContains(getWindow().getName(), getName(), textValue);
    }

    /*********** <pre> 
                Attempts to select a menuitem based on a partial text match.
               
                Attempts to select a menuitem based on a partial text match.  
                The menuitem should be specified in the form "Menu->Menu->MenuItem".
                Each level in the hierarchy can be represented by partial text.
                
                Ampersands preceding underlined characters are optional.
                The routine first verifies that the specified menuitem exists
                and exits with error if it does not.
                If it does exist then the selection proceeds using the MenuID retrieved
                from the found menuitem.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param textValue  Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to select.
              
     **********/
    public void selectMenuItemContains(StepTestTable table, String textValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "selectMenuItemContains.table = null");

        if ( textValue == null ) throw new IllegalArgumentException ( "selectMenuItemContains.textValue = null");
        table.add( WindowFunctions.selectMenuItemContains(getWindow().getName(), getName(), textValue));
    }

    /*********** <pre> 
                Set focus on the window.
               
                Set focus and bring the window forward.
                
                	Bring the window forward. If there are same name/caption/title windows then the first 
                	window will come forward. The window is find by title. 
                                          
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     **********/
    public ComponentFunction setFocus( ) {

        return WindowFunctions.setFocus(getWindow().getName(), getName());
    }

    /*********** <pre> 
                Set focus on the window.
               
                Set focus and bring the window forward.
                
                	Bring the window forward. If there are same name/caption/title windows then the first 
                	window will come forward. The window is find by title. 
                                          
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void setFocus(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "setFocus.table = null");

        table.add( WindowFunctions.setFocus(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                Sends a SetPosition command to the window to set the position, size, and status of the window.
               
                Sends a SetPosition command to the window to set the position, size, 
                and status of the window.  The position, size, and status information 
                is stored in the app map as a subitem in the section for the window.
                The information should be in the format of:
                
                "0,0,640,480;Status=NORMAL"    OR
                "Coords=0,0,640,480;Status=NORMAL"
                
                That example positions the window at 0,0; sizes it to 640 x 480, and
                sets it's status to NORMAL.  Valid values for STATUS are:
                
                NORMAL, MINIMIZED, and MAXIMIZED
                
                The Window SetPosition command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, SetPosition, ChildPositionReference
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to SetPosition.
                
                t, ParentWindow, ParentWindow, SetPosition, ParentPosition
                t, ChildWindow , ChildWindow , SetPosition, ChildPosition   (normally won't work)
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param presetReference  Optional:NO 
                String specifying a preset reference in the Application for the position, size, and state of the Window.
              
     **********/
    public ComponentFunction setPosition(String presetReference ) {

        if ( presetReference == null ) throw new IllegalArgumentException ( "setPosition.presetReference = null");
        return WindowFunctions.setPosition(getWindow().getName(), getName(), presetReference);
    }

    /*********** <pre> 
                Sends a SetPosition command to the window to set the position, size, and status of the window.
               
                Sends a SetPosition command to the window to set the position, size, 
                and status of the window.  The position, size, and status information 
                is stored in the app map as a subitem in the section for the window.
                The information should be in the format of:
                
                "0,0,640,480;Status=NORMAL"    OR
                "Coords=0,0,640,480;Status=NORMAL"
                
                That example positions the window at 0,0; sizes it to 640 x 480, and
                sets it's status to NORMAL.  Valid values for STATUS are:
                
                NORMAL, MINIMIZED, and MAXIMIZED
                
                The Window SetPosition command has a problem in that it does not want to
                use the same recognition methods used by the other Window commands (like
                SetContext).  Particularly, it does not accept the Type=Window portion
                of these recognition methods.  In addition, if the window is a child
                window of a parent then it expects the ";ChildWindow" add-on in the 
                recognition method.  The child may also need the parent as part of its
                full recognition string like:
                
                ChildWindow=Type=Window;<parent rec>;\;Caption=<caption>;ChildWindow
                
                To handle these child windows, we parse the typical recognition method for 
                our window and attempt to handle these issues.  Once SetContext has 
                successfully set our window, we then remove any "Type=Window" substring 
                if present and add the ";ChildWindow" substring if not present.
                
                To take advantage of this, this routine must be called with the child
                window as a component of the parent window like below:
                
                t, ParentWindow, ChildWindow, SetPosition, ChildPositionReference
                
                If the routine is called like either of the examples below then default
                processing will occur.  This will merely SetContext on the provided 
                Window and use "CurrentWindow" as the parameter to SetPosition.
                
                t, ParentWindow, ParentWindow, SetPosition, ParentPosition
                t, ChildWindow , ChildWindow , SetPosition, ChildPosition   (normally won't work)
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>AutomatedQA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param presetReference  Optional:NO 
                String specifying a preset reference in the Application for the position, size, and state of the Window.
              
     **********/
    public void setPosition(StepTestTable table, String presetReference ) {

        if ( table == null ) throw new IllegalArgumentException ( "setPosition.table = null");

        if ( presetReference == null ) throw new IllegalArgumentException ( "setPosition.presetReference = null");
        table.add( WindowFunctions.setPosition(getWindow().getName(), getName(), presetReference));
    }

    /*********** <pre> 
                 Performs a WindowVP CompareImage OR a RegionImageVP on an object.
               
                Performs a WindowVP CompareImage OR a RegionImageVP on an object.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                A RegionImageVP can be accomplished by having the name of the VP as an item 
                under the component in the application map.  The item's value must be 
                the coordinate values required by the RegionImageVP (i.e. "65,100,200,250").
                
                Example 1: Perform a WindowVP CompareImage
                
                MainWindow SomeWindowObject VerifyImage StoredVP
                
                (no StoredVP item found in the app map under SomeWindowObject)
                
                The named VP (StoredVP) must not exist in the application map.  The 
                entire panel/object of SomeWindowObject will be captured and compared 
                against the StoredVP baseline which must already exist as an asset of the
                currently running script.
                
                Example 2: Perform a RegionImageVP on a particular area of the screen
                
                MainWindow SomeWindowObject VerifyImage StoredVP
                
                (StoredVP found as:
                 
                "65,100,200,250"   OR
                "Coords=65,100,200,250"
                  
                in the SomeWindowObject section of the app map)
                
                The named VP (StoredVP) is found to exist in the application map as a
                subitem in the SomeWindowObject section of the map.  This causes 
                the routine to attempt a RegionImageVP using the map's value of the StoredVP 
                item as the coordinates for the region to capture.  StoredVP is ALSO the 
                name of the VP which must already exist as an asset of the currently 
                running script.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param vPAsset  Optional:NO 
                TextValue is the name of the pre-existing VP asset stored in the currently running script.
              
     **********/
    public ComponentFunction verifyImage(String vPAsset ) {

        if ( vPAsset == null ) throw new IllegalArgumentException ( "verifyImage.vPAsset = null");
        return WindowFunctions.verifyImage(getWindow().getName(), getName(), vPAsset);
    }

    /*********** <pre> 
                 Performs a WindowVP CompareImage OR a RegionImageVP on an object.
               
                Performs a WindowVP CompareImage OR a RegionImageVP on an object.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                A RegionImageVP can be accomplished by having the name of the VP as an item 
                under the component in the application map.  The item's value must be 
                the coordinate values required by the RegionImageVP (i.e. "65,100,200,250").
                
                Example 1: Perform a WindowVP CompareImage
                
                MainWindow SomeWindowObject VerifyImage StoredVP
                
                (no StoredVP item found in the app map under SomeWindowObject)
                
                The named VP (StoredVP) must not exist in the application map.  The 
                entire panel/object of SomeWindowObject will be captured and compared 
                against the StoredVP baseline which must already exist as an asset of the
                currently running script.
                
                Example 2: Perform a RegionImageVP on a particular area of the screen
                
                MainWindow SomeWindowObject VerifyImage StoredVP
                
                (StoredVP found as:
                 
                "65,100,200,250"   OR
                "Coords=65,100,200,250"
                  
                in the SomeWindowObject section of the app map)
                
                The named VP (StoredVP) is found to exist in the application map as a
                subitem in the SomeWindowObject section of the map.  This causes 
                the routine to attempt a RegionImageVP using the map's value of the StoredVP 
                item as the coordinates for the region to capture.  StoredVP is ALSO the 
                name of the VP which must already exist as an asset of the currently 
                running script.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param vPAsset  Optional:NO 
                TextValue is the name of the pre-existing VP asset stored in the currently running script.
              
     **********/
    public void verifyImage(StepTestTable table, String vPAsset ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyImage.table = null");

        if ( vPAsset == null ) throw new IllegalArgumentException ( "verifyImage.vPAsset = null");
        table.add( WindowFunctions.verifyImage(getWindow().getName(), getName(), vPAsset));
    }

    /*********** <pre> 
                Compares the active windows menu system with a benchmark
               
                Retrieves the active windows menu system and outputs the full structure 
                with status to a file.  It then compares that file with the specified 
                benchmark file and sets pass/fail conditions for the test.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param benchmarkFile  Optional:NO 
                name.ext of benchmark file on repositiory's Datapool\Bench directory
              
     @param descriptiveText  Optional:YES 
                Optional expected descriptive text at start of file (first line of bench).
              
     @param testFile  Optional:YES 
                optional name.ext to give current structure in repository's 
                Datapool\Test directory for compare with benchmark.
              
     @param diffFile  Optional:YES 
                Optional name.ext to store difference information
              
     **********/
    public ComponentFunction verifyMainMenu(String benchmarkFile, String descriptiveText, String testFile, String diffFile ) {

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyMainMenu.benchmarkFile = null");
        return WindowFunctions.verifyMainMenu(getWindow().getName(), getName(), benchmarkFile, descriptiveText, testFile, diffFile);
    }

    /*********** <pre> 
                Compares the active windows menu system with a benchmark
               
                Retrieves the active windows menu system and outputs the full structure 
                with status to a file.  It then compares that file with the specified 
                benchmark file and sets pass/fail conditions for the test.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchmarkFile  Optional:NO 
                name.ext of benchmark file on repositiory's Datapool\Bench directory
              
     @param descriptiveText  Optional:YES 
                Optional expected descriptive text at start of file (first line of bench).
              
     @param testFile  Optional:YES 
                optional name.ext to give current structure in repository's 
                Datapool\Test directory for compare with benchmark.
              
     @param diffFile  Optional:YES 
                Optional name.ext to store difference information
              
     **********/
    public void verifyMainMenu(StepTestTable table, String benchmarkFile, String descriptiveText, String testFile, String diffFile ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyMainMenu.table = null");

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyMainMenu.benchmarkFile = null");
        table.add( WindowFunctions.verifyMainMenu(getWindow().getName(), getName(), benchmarkFile, descriptiveText, testFile, diffFile));
    }

    /*********** <pre> 
                Compares the active windows menu system with a benchmark
               
                Retrieves the active windows menu system and outputs the full structure 
                with status to a file.  It then compares that file with the specified 
                benchmark file and sets pass/fail conditions for the test.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO 
                name.ext of benchmark file on repositiory's Datapool\Bench directory
              <BR/>         descriptiveText -- Optional:YES 
                Optional expected descriptive text at start of file (first line of bench).
              <BR/>         testFile -- Optional:YES 
                optional name.ext to give current structure in repository's 
                Datapool\Test directory for compare with benchmark.
              <BR/>         diffFile -- Optional:YES 
                Optional name.ext to store difference information
              
    </UL>

     **********/
    public ComponentFunction verifyMainMenu(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyMainMenu.parameters = null");
        return WindowFunctions.verifyMainMenu(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                Compares the active windows menu system with a benchmark
               
                Retrieves the active windows menu system and outputs the full structure 
                with status to a file.  It then compares that file with the specified 
                benchmark file and sets pass/fail conditions for the test.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO 
                name.ext of benchmark file on repositiory's Datapool\Bench directory
              <BR/>         descriptiveText -- Optional:YES 
                Optional expected descriptive text at start of file (first line of bench).
              <BR/>         testFile -- Optional:YES 
                optional name.ext to give current structure in repository's 
                Datapool\Test directory for compare with benchmark.
              <BR/>         diffFile -- Optional:YES 
                Optional name.ext to store difference information
              
    </UL>

     **********/
    public void verifyMainMenu(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyMainMenu.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyMainMenu.parameters = null");
        table.add( WindowFunctions.verifyMainMenu(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Attempts to verify the state information of a particular menuitem
                identified by MenuID.
               
                Attempts to verify the state information of a particular menuitem
                identified by MenuID.  This is generally used when the menuitem is a 
                bitmap or other item that does not have text.
                This value can be retrieved from the the menu by index or by manual
                lookup from a menu structure output from MenuUtilities.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param menuID  Optional:NO 
                MenuID to identify which menuitem to test.
              
     @param expectedStatus  Optional:NO 
                Expected status string (or part thereof) to verify. 
              
     **********/
    public ComponentFunction verifyMenuID(String menuID, String expectedStatus ) {

        if ( expectedStatus == null ) throw new IllegalArgumentException ( "verifyMenuID.expectedStatus = null");
        if ( menuID == null ) throw new IllegalArgumentException ( "verifyMenuID.menuID = null");
        return WindowFunctions.verifyMenuID(getWindow().getName(), getName(), menuID, expectedStatus);
    }

    /*********** <pre> 
                Attempts to verify the state information of a particular menuitem
                identified by MenuID.
               
                Attempts to verify the state information of a particular menuitem
                identified by MenuID.  This is generally used when the menuitem is a 
                bitmap or other item that does not have text.
                This value can be retrieved from the the menu by index or by manual
                lookup from a menu structure output from MenuUtilities.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param menuID  Optional:NO 
                MenuID to identify which menuitem to test.
              
     @param expectedStatus  Optional:NO 
                Expected status string (or part thereof) to verify. 
              
     **********/
    public void verifyMenuID(StepTestTable table, String menuID, String expectedStatus ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyMenuID.table = null");

        if ( expectedStatus == null ) throw new IllegalArgumentException ( "verifyMenuID.expectedStatus = null");
        if ( menuID == null ) throw new IllegalArgumentException ( "verifyMenuID.menuID = null");
        table.add( WindowFunctions.verifyMenuID(getWindow().getName(), getName(), menuID, expectedStatus));
    }

    /*********** <pre> 
                Attempts to verify the state information of a particular menuitem
                identified by MenuID.
               
                Attempts to verify the state information of a particular menuitem
                identified by MenuID.  This is generally used when the menuitem is a 
                bitmap or other item that does not have text.
                This value can be retrieved from the the menu by index or by manual
                lookup from a menu structure output from MenuUtilities.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         menuID -- Optional:NO 
                MenuID to identify which menuitem to test.
              <BR/>         expectedStatus -- Optional:NO 
                Expected status string (or part thereof) to verify. 
              
    </UL>

     **********/
    public ComponentFunction verifyMenuID(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyMenuID.parameters = null");
        return WindowFunctions.verifyMenuID(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                Attempts to verify the state information of a particular menuitem
                identified by MenuID.
               
                Attempts to verify the state information of a particular menuitem
                identified by MenuID.  This is generally used when the menuitem is a 
                bitmap or other item that does not have text.
                This value can be retrieved from the the menu by index or by manual
                lookup from a menu structure output from MenuUtilities.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         menuID -- Optional:NO 
                MenuID to identify which menuitem to test.
              <BR/>         expectedStatus -- Optional:NO 
                Expected status string (or part thereof) to verify. 
              
    </UL>

     **********/
    public void verifyMenuID(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyMenuID.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyMenuID.parameters = null");
        table.add( WindowFunctions.verifyMenuID(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
               Attempts to verify the state information of a particular text string menuitem.
               
                Attempts to verify the state information of a particular text string 
                menuitem.  The menuitem should be specified in the form 
                "Menu->Menu->MenuItem   CTRL+V" with the full text (ampersands optional), 
                spaces(if any), and keyboard shortcut text (if any).  
                (The ampersands precede any character in the menuitem that is underlined.)
                
                Note 1: This command differs from JavaMenuFunctions.VerifyMenuItemContains as this 
                command seeks a Window object that contains a Window's menu.
                
                
                Note 2: For RobotJ engine, this command only supports JavaSwing. It may support other clients in the future.
              	
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param menuItemText  Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to test.
              
     @param expectedStatus  Optional:NO 
                Expected status string (or part thereof) to verify. 
              
     **********/
    public ComponentFunction verifyMenuItem(String menuItemText, String expectedStatus ) {

        if ( expectedStatus == null ) throw new IllegalArgumentException ( "verifyMenuItem.expectedStatus = null");
        if ( menuItemText == null ) throw new IllegalArgumentException ( "verifyMenuItem.menuItemText = null");
        return WindowFunctions.verifyMenuItem(getWindow().getName(), getName(), menuItemText, expectedStatus);
    }

    /*********** <pre> 
               Attempts to verify the state information of a particular text string menuitem.
               
                Attempts to verify the state information of a particular text string 
                menuitem.  The menuitem should be specified in the form 
                "Menu->Menu->MenuItem   CTRL+V" with the full text (ampersands optional), 
                spaces(if any), and keyboard shortcut text (if any).  
                (The ampersands precede any character in the menuitem that is underlined.)
                
                Note 1: This command differs from JavaMenuFunctions.VerifyMenuItemContains as this 
                command seeks a Window object that contains a Window's menu.
                
                
                Note 2: For RobotJ engine, this command only supports JavaSwing. It may support other clients in the future.
              	
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param menuItemText  Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to test.
              
     @param expectedStatus  Optional:NO 
                Expected status string (or part thereof) to verify. 
              
     **********/
    public void verifyMenuItem(StepTestTable table, String menuItemText, String expectedStatus ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyMenuItem.table = null");

        if ( expectedStatus == null ) throw new IllegalArgumentException ( "verifyMenuItem.expectedStatus = null");
        if ( menuItemText == null ) throw new IllegalArgumentException ( "verifyMenuItem.menuItemText = null");
        table.add( WindowFunctions.verifyMenuItem(getWindow().getName(), getName(), menuItemText, expectedStatus));
    }

    /*********** <pre> 
               Attempts to verify the state information of a particular text string menuitem.
               
                Attempts to verify the state information of a particular text string 
                menuitem.  The menuitem should be specified in the form 
                "Menu->Menu->MenuItem   CTRL+V" with the full text (ampersands optional), 
                spaces(if any), and keyboard shortcut text (if any).  
                (The ampersands precede any character in the menuitem that is underlined.)
                
                Note 1: This command differs from JavaMenuFunctions.VerifyMenuItemContains as this 
                command seeks a Window object that contains a Window's menu.
                
                
                Note 2: For RobotJ engine, this command only supports JavaSwing. It may support other clients in the future.
              	
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         menuItemText -- Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to test.
              <BR/>         expectedStatus -- Optional:NO 
                Expected status string (or part thereof) to verify. 
              
    </UL>

     **********/
    public ComponentFunction verifyMenuItem(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyMenuItem.parameters = null");
        return WindowFunctions.verifyMenuItem(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
               Attempts to verify the state information of a particular text string menuitem.
               
                Attempts to verify the state information of a particular text string 
                menuitem.  The menuitem should be specified in the form 
                "Menu->Menu->MenuItem   CTRL+V" with the full text (ampersands optional), 
                spaces(if any), and keyboard shortcut text (if any).  
                (The ampersands precede any character in the menuitem that is underlined.)
                
                Note 1: This command differs from JavaMenuFunctions.VerifyMenuItemContains as this 
                command seeks a Window object that contains a Window's menu.
                
                
                Note 2: For RobotJ engine, this command only supports JavaSwing. It may support other clients in the future.
              	
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         menuItemText -- Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to test.
              <BR/>         expectedStatus -- Optional:NO 
                Expected status string (or part thereof) to verify. 
              
    </UL>

     **********/
    public void verifyMenuItem(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyMenuItem.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyMenuItem.parameters = null");
        table.add( WindowFunctions.verifyMenuItem(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
               Attempts to verify the state information of a menuitem found by partial text match.
               
                Attempts to verify the state information of a menuitem found by partial text match.
                The menuitem should be specified in the form "Menu->Menu->MenuItem".  
                (Optional ampersands precede any character in the menuitem that is underlined.)
                
                Note 1: This command differs from JavaMenuFunctions.VerifyMenuItemContains as this 
                command seeks a Window object that contains a Window's menu.
                
                
                Note 2: For RobotJ engine, this command only supports JavaSwing. It may support other clients in the future.
              	
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param menuItemText  Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to test.
              
     @param expectedStatus  Optional:NO 
                Expected status string (or part thereof) to verify. 
              
     **********/
    public ComponentFunction verifyMenuItemContains(String menuItemText, String expectedStatus ) {

        if ( expectedStatus == null ) throw new IllegalArgumentException ( "verifyMenuItemContains.expectedStatus = null");
        if ( menuItemText == null ) throw new IllegalArgumentException ( "verifyMenuItemContains.menuItemText = null");
        return WindowFunctions.verifyMenuItemContains(getWindow().getName(), getName(), menuItemText, expectedStatus);
    }

    /*********** <pre> 
               Attempts to verify the state information of a menuitem found by partial text match.
               
                Attempts to verify the state information of a menuitem found by partial text match.
                The menuitem should be specified in the form "Menu->Menu->MenuItem".  
                (Optional ampersands precede any character in the menuitem that is underlined.)
                
                Note 1: This command differs from JavaMenuFunctions.VerifyMenuItemContains as this 
                command seeks a Window object that contains a Window's menu.
                
                
                Note 2: For RobotJ engine, this command only supports JavaSwing. It may support other clients in the future.
              	
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param menuItemText  Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to test.
              
     @param expectedStatus  Optional:NO 
                Expected status string (or part thereof) to verify. 
              
     **********/
    public void verifyMenuItemContains(StepTestTable table, String menuItemText, String expectedStatus ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyMenuItemContains.table = null");

        if ( expectedStatus == null ) throw new IllegalArgumentException ( "verifyMenuItemContains.expectedStatus = null");
        if ( menuItemText == null ) throw new IllegalArgumentException ( "verifyMenuItemContains.menuItemText = null");
        table.add( WindowFunctions.verifyMenuItemContains(getWindow().getName(), getName(), menuItemText, expectedStatus));
    }

    /*********** <pre> 
               Attempts to verify the state information of a menuitem found by partial text match.
               
                Attempts to verify the state information of a menuitem found by partial text match.
                The menuitem should be specified in the form "Menu->Menu->MenuItem".  
                (Optional ampersands precede any character in the menuitem that is underlined.)
                
                Note 1: This command differs from JavaMenuFunctions.VerifyMenuItemContains as this 
                command seeks a Window object that contains a Window's menu.
                
                
                Note 2: For RobotJ engine, this command only supports JavaSwing. It may support other clients in the future.
              	
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         menuItemText -- Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to test.
              <BR/>         expectedStatus -- Optional:NO 
                Expected status string (or part thereof) to verify. 
              
    </UL>

     **********/
    public ComponentFunction verifyMenuItemContains(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyMenuItemContains.parameters = null");
        return WindowFunctions.verifyMenuItemContains(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
               Attempts to verify the state information of a menuitem found by partial text match.
               
                Attempts to verify the state information of a menuitem found by partial text match.
                The menuitem should be specified in the form "Menu->Menu->MenuItem".  
                (Optional ampersands precede any character in the menuitem that is underlined.)
                
                Note 1: This command differs from JavaMenuFunctions.VerifyMenuItemContains as this 
                command seeks a Window object that contains a Window's menu.
                
                
                Note 2: For RobotJ engine, this command only supports JavaSwing. It may support other clients in the future.
              	
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         menuItemText -- Optional:NO 
                Menu->MenuItem hierarchy string to identify which menuitem to test.
              <BR/>         expectedStatus -- Optional:NO 
                Expected status string (or part thereof) to verify. 
              
    </UL>

     **********/
    public void verifyMenuItemContains(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyMenuItemContains.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyMenuItemContains.parameters = null");
        table.add( WindowFunctions.verifyMenuItemContains(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                 Performs an UNLOGGED WindowVP CompareImage OR a RegionImageVP on an 
                 object then attempts to retrieve and compare OCR text to the expected 
                 value provided.
               
                Performs an UNLOGGED WindowVP CompareImage OR a RegionImageVP on an 
                object then attempts to retrieve and compare OCR text to the expected 
                value provided.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                A RegionImageVP can be accomplished by having the name of the VP as an item 
                under the component in the application map.  The item's value must be 
                the coordinate values required by the RegionImageVP 
                (i.e. "Coords=65,100,200,250").
                
                EXAMPLE 1 : Perform a WindowVP CompareImage before OCR Test
                
                t, MainWindow, SomeWindowObject, VerifyOCRValue, StoredVP, 1, "Expected Text"
                
                (no StoredVP item found in the app map under SomeWindowObject)
                
                The named VP (StoredVP) must not exist in the application map if you 
                intend to compare the entire window.  The entire panel/object of 
                SomeWindowObject will be captured and compared against the StoredVP 
                baseline.  This VP must already exist as an asset of the
                currently running script.
                
                EXAMPLE 2 : Perform a RegionImageVP before the OCR test
                
                t, MainWindow, SomeWindowObject, VerifyOCRValue, StoredVP, DataField, "Expected Text"
                
                StoredVP found in Application Map like below:
                
                [SomeWindowObject]
                SomeWindowObject="Type=Something...."
                StoredVP="Coords=65,100,200,250"        --- invokes a RegionImageVP
                ....
                
                When the named VP (StoredVP) is found to exist in the application map as a
                subitem in the SomeWindowObject section of the map then a RegionImageVP 
                will be invoked using the value of the StoredVP item as the coordinates 
                for the region to capture.  
                
                StoredVP is ALSO the name of the VP which must already exist as an asset 
                of the currently running script.
                
                Once the unlogged VP has been completed, we attempt to retrieve the text
                of a predefined OCR region mask that should exist in the VP.  
                
                We can use the OCRRegion value provided from the inputrecord to identify 
                the OCR mask number as needed by the SQAGetOcrRegionText function in Robot.  
                Example 1 above shows we are looking for OCR region #1.
                
                The OCRRegion value in the inputrecord can also be a reference in the 
                Application Map in a section with the same name as the VP as shown below.
                
                [SomeWindowObject]
                SomeWindowObject="Type=Something...."
                StoredVP="Coords=65,100,200,250"
                ....
                
                [StoredVP]
                DataField=1
                AnotherField=2
                ....
                
                Example 2 above shows that we have given region #1 a name of DataField.
                          
                Once retrieved, the OCR text (if any) is compared against the expected 
                results provided.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param vPAsset  Optional:NO 
               VPTextValue is the name of the pre-existing VP asset stored in the currently running script.
              
     @param oCRIntegerValue  Optional:NO 
                IntegerValue is the numeric OCR region mask to get the text from.
              
     @param expectedTextValue  Optional:NO 
                Text baseline to compare against the retrieved OCR text.
              
     **********/
    public ComponentFunction verifyOCRValue(String vPAsset, String oCRIntegerValue, String expectedTextValue ) {

        if ( expectedTextValue == null ) throw new IllegalArgumentException ( "verifyOCRValue.expectedTextValue = null");
        if ( oCRIntegerValue == null ) throw new IllegalArgumentException ( "verifyOCRValue.oCRIntegerValue = null");
        if ( vPAsset == null ) throw new IllegalArgumentException ( "verifyOCRValue.vPAsset = null");
        return WindowFunctions.verifyOCRValue(getWindow().getName(), getName(), vPAsset, oCRIntegerValue, expectedTextValue);
    }

    /*********** <pre> 
                 Performs an UNLOGGED WindowVP CompareImage OR a RegionImageVP on an 
                 object then attempts to retrieve and compare OCR text to the expected 
                 value provided.
               
                Performs an UNLOGGED WindowVP CompareImage OR a RegionImageVP on an 
                object then attempts to retrieve and compare OCR text to the expected 
                value provided.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                A RegionImageVP can be accomplished by having the name of the VP as an item 
                under the component in the application map.  The item's value must be 
                the coordinate values required by the RegionImageVP 
                (i.e. "Coords=65,100,200,250").
                
                EXAMPLE 1 : Perform a WindowVP CompareImage before OCR Test
                
                t, MainWindow, SomeWindowObject, VerifyOCRValue, StoredVP, 1, "Expected Text"
                
                (no StoredVP item found in the app map under SomeWindowObject)
                
                The named VP (StoredVP) must not exist in the application map if you 
                intend to compare the entire window.  The entire panel/object of 
                SomeWindowObject will be captured and compared against the StoredVP 
                baseline.  This VP must already exist as an asset of the
                currently running script.
                
                EXAMPLE 2 : Perform a RegionImageVP before the OCR test
                
                t, MainWindow, SomeWindowObject, VerifyOCRValue, StoredVP, DataField, "Expected Text"
                
                StoredVP found in Application Map like below:
                
                [SomeWindowObject]
                SomeWindowObject="Type=Something...."
                StoredVP="Coords=65,100,200,250"        --- invokes a RegionImageVP
                ....
                
                When the named VP (StoredVP) is found to exist in the application map as a
                subitem in the SomeWindowObject section of the map then a RegionImageVP 
                will be invoked using the value of the StoredVP item as the coordinates 
                for the region to capture.  
                
                StoredVP is ALSO the name of the VP which must already exist as an asset 
                of the currently running script.
                
                Once the unlogged VP has been completed, we attempt to retrieve the text
                of a predefined OCR region mask that should exist in the VP.  
                
                We can use the OCRRegion value provided from the inputrecord to identify 
                the OCR mask number as needed by the SQAGetOcrRegionText function in Robot.  
                Example 1 above shows we are looking for OCR region #1.
                
                The OCRRegion value in the inputrecord can also be a reference in the 
                Application Map in a section with the same name as the VP as shown below.
                
                [SomeWindowObject]
                SomeWindowObject="Type=Something...."
                StoredVP="Coords=65,100,200,250"
                ....
                
                [StoredVP]
                DataField=1
                AnotherField=2
                ....
                
                Example 2 above shows that we have given region #1 a name of DataField.
                          
                Once retrieved, the OCR text (if any) is compared against the expected 
                results provided.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param vPAsset  Optional:NO 
               VPTextValue is the name of the pre-existing VP asset stored in the currently running script.
              
     @param oCRIntegerValue  Optional:NO 
                IntegerValue is the numeric OCR region mask to get the text from.
              
     @param expectedTextValue  Optional:NO 
                Text baseline to compare against the retrieved OCR text.
              
     **********/
    public void verifyOCRValue(StepTestTable table, String vPAsset, String oCRIntegerValue, String expectedTextValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyOCRValue.table = null");

        if ( expectedTextValue == null ) throw new IllegalArgumentException ( "verifyOCRValue.expectedTextValue = null");
        if ( oCRIntegerValue == null ) throw new IllegalArgumentException ( "verifyOCRValue.oCRIntegerValue = null");
        if ( vPAsset == null ) throw new IllegalArgumentException ( "verifyOCRValue.vPAsset = null");
        table.add( WindowFunctions.verifyOCRValue(getWindow().getName(), getName(), vPAsset, oCRIntegerValue, expectedTextValue));
    }

    /*********** <pre> 
                 Performs an UNLOGGED WindowVP CompareImage OR a RegionImageVP on an 
                 object then attempts to retrieve and compare OCR text to the expected 
                 value provided.
               
                Performs an UNLOGGED WindowVP CompareImage OR a RegionImageVP on an 
                object then attempts to retrieve and compare OCR text to the expected 
                value provided.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                A RegionImageVP can be accomplished by having the name of the VP as an item 
                under the component in the application map.  The item's value must be 
                the coordinate values required by the RegionImageVP 
                (i.e. "Coords=65,100,200,250").
                
                EXAMPLE 1 : Perform a WindowVP CompareImage before OCR Test
                
                t, MainWindow, SomeWindowObject, VerifyOCRValue, StoredVP, 1, "Expected Text"
                
                (no StoredVP item found in the app map under SomeWindowObject)
                
                The named VP (StoredVP) must not exist in the application map if you 
                intend to compare the entire window.  The entire panel/object of 
                SomeWindowObject will be captured and compared against the StoredVP 
                baseline.  This VP must already exist as an asset of the
                currently running script.
                
                EXAMPLE 2 : Perform a RegionImageVP before the OCR test
                
                t, MainWindow, SomeWindowObject, VerifyOCRValue, StoredVP, DataField, "Expected Text"
                
                StoredVP found in Application Map like below:
                
                [SomeWindowObject]
                SomeWindowObject="Type=Something...."
                StoredVP="Coords=65,100,200,250"        --- invokes a RegionImageVP
                ....
                
                When the named VP (StoredVP) is found to exist in the application map as a
                subitem in the SomeWindowObject section of the map then a RegionImageVP 
                will be invoked using the value of the StoredVP item as the coordinates 
                for the region to capture.  
                
                StoredVP is ALSO the name of the VP which must already exist as an asset 
                of the currently running script.
                
                Once the unlogged VP has been completed, we attempt to retrieve the text
                of a predefined OCR region mask that should exist in the VP.  
                
                We can use the OCRRegion value provided from the inputrecord to identify 
                the OCR mask number as needed by the SQAGetOcrRegionText function in Robot.  
                Example 1 above shows we are looking for OCR region #1.
                
                The OCRRegion value in the inputrecord can also be a reference in the 
                Application Map in a section with the same name as the VP as shown below.
                
                [SomeWindowObject]
                SomeWindowObject="Type=Something...."
                StoredVP="Coords=65,100,200,250"
                ....
                
                [StoredVP]
                DataField=1
                AnotherField=2
                ....
                
                Example 2 above shows that we have given region #1 a name of DataField.
                          
                Once retrieved, the OCR text (if any) is compared against the expected 
                results provided.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         vPAsset -- Optional:NO 
               VPTextValue is the name of the pre-existing VP asset stored in the currently running script.
              <BR/>         oCRIntegerValue -- Optional:NO 
                IntegerValue is the numeric OCR region mask to get the text from.
              <BR/>         expectedTextValue -- Optional:NO 
                Text baseline to compare against the retrieved OCR text.
              
    </UL>

     **********/
    public ComponentFunction verifyOCRValue(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyOCRValue.parameters = null");
        return WindowFunctions.verifyOCRValue(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                 Performs an UNLOGGED WindowVP CompareImage OR a RegionImageVP on an 
                 object then attempts to retrieve and compare OCR text to the expected 
                 value provided.
               
                Performs an UNLOGGED WindowVP CompareImage OR a RegionImageVP on an 
                object then attempts to retrieve and compare OCR text to the expected 
                value provided.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                A RegionImageVP can be accomplished by having the name of the VP as an item 
                under the component in the application map.  The item's value must be 
                the coordinate values required by the RegionImageVP 
                (i.e. "Coords=65,100,200,250").
                
                EXAMPLE 1 : Perform a WindowVP CompareImage before OCR Test
                
                t, MainWindow, SomeWindowObject, VerifyOCRValue, StoredVP, 1, "Expected Text"
                
                (no StoredVP item found in the app map under SomeWindowObject)
                
                The named VP (StoredVP) must not exist in the application map if you 
                intend to compare the entire window.  The entire panel/object of 
                SomeWindowObject will be captured and compared against the StoredVP 
                baseline.  This VP must already exist as an asset of the
                currently running script.
                
                EXAMPLE 2 : Perform a RegionImageVP before the OCR test
                
                t, MainWindow, SomeWindowObject, VerifyOCRValue, StoredVP, DataField, "Expected Text"
                
                StoredVP found in Application Map like below:
                
                [SomeWindowObject]
                SomeWindowObject="Type=Something...."
                StoredVP="Coords=65,100,200,250"        --- invokes a RegionImageVP
                ....
                
                When the named VP (StoredVP) is found to exist in the application map as a
                subitem in the SomeWindowObject section of the map then a RegionImageVP 
                will be invoked using the value of the StoredVP item as the coordinates 
                for the region to capture.  
                
                StoredVP is ALSO the name of the VP which must already exist as an asset 
                of the currently running script.
                
                Once the unlogged VP has been completed, we attempt to retrieve the text
                of a predefined OCR region mask that should exist in the VP.  
                
                We can use the OCRRegion value provided from the inputrecord to identify 
                the OCR mask number as needed by the SQAGetOcrRegionText function in Robot.  
                Example 1 above shows we are looking for OCR region #1.
                
                The OCRRegion value in the inputrecord can also be a reference in the 
                Application Map in a section with the same name as the VP as shown below.
                
                [SomeWindowObject]
                SomeWindowObject="Type=Something...."
                StoredVP="Coords=65,100,200,250"
                ....
                
                [StoredVP]
                DataField=1
                AnotherField=2
                ....
                
                Example 2 above shows that we have given region #1 a name of DataField.
                          
                Once retrieved, the OCR text (if any) is compared against the expected 
                results provided.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         vPAsset -- Optional:NO 
               VPTextValue is the name of the pre-existing VP asset stored in the currently running script.
              <BR/>         oCRIntegerValue -- Optional:NO 
                IntegerValue is the numeric OCR region mask to get the text from.
              <BR/>         expectedTextValue -- Optional:NO 
                Text baseline to compare against the retrieved OCR text.
              
    </UL>

     **********/
    public void verifyOCRValue(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyOCRValue.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyOCRValue.parameters = null");
        table.add( WindowFunctions.verifyOCRValue(getWindow().getName(), getName(), parameters));
    }

}
