
/******************************************************************************
 * GenericObject.java
 *
 * Copyright (c) by SAS Institute Inc., Cary, NC 27513
 * General Public License: http://www.opensource.org/licenses/gpl-license.php
 *
 * !!! DO NOT EDIT THIS FILE !!!
 * This file is automatically generated from XML source.  Any changes you make 
 * here will be erased the next time the file is generated.
 *
 * The following assets are needed to generate this file:
 *
 *   GenericObjectFunctions.xml
 *   keyword_library.dtd
 *   XSLJavaCommonFunctions.xsl
 *   XSLJavaComponentModel.xsl
 *
 * Example invocation to generate:
 *
 *   msxsl.exe GenericObjectFunctions.xml XSLJavaComponentModel.xsl -o GenericObject.java
 *
 ******************************************************************************/ 
package org.safs.model.components;

import org.safs.model.commands.GenericObjectFunctions;
import org.safs.model.ComponentFunction;
import org.safs.model.components.UIComponent;
import org.safs.model.StepTestTable;

public class GenericObject extends GenericMaster {

    /*****************
    Constructor 

    Create an instance of pseudo-component representing 
    a specific component in a specific window.
    
    @param window  Optional:NO 
           Specifies which Window this component is 'in'.
    @param compname Optional:NO 
           Specifies the AppMap name of the component in the Window.
    ****************/
    public GenericObject(Window window, String compname) {

        super(window, compname);
    }

    /*****************
    Constructor 

    Create an instance of pseudo-component representing 
    a specific component in a specific window.
    
    This convenience routine will create the requisite Window component.
    
    @param winname  Optional:NO 
           Specifies the AppMap name of the window.
    @param compname Optional:NO 
           Specifies the AppMap name of the component in the Window.
    ****************/
    public GenericObject(String winname, String compname) {

        this(new Window(winname), compname);
    }

    protected GenericObject(String compname) {

        super(compname);
    }



    /*********** <pre> 
                  An ALT left mouse drag is performed on the object based on the stored coordinates.
                 
                  
                  The coordinate lookup is done with the component name(Field #3) of the record AND 
                  Field #5.
                  
                  Typical Data Table records:
                  
                  (1) t MainWindow GenericItem AltLeftDrag DragName
                  
                  #1 above will contain a GenericItem entry in the MainWindow section with 
                  normal recognition information for it .  GenericItem will also have it's
                  own section in the Application Map in which there will be an entry like:
                  
                  DragName="15,30,60,90"    OR
                  DragName="Coords=15,30,60,90"
                  
                  This will tell RFT to locate the GenericItem Window object and an ALT left mouse drag
                  from coordinates 15,30 to 60,90.
  	            </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for an ALT left mouse drag.
                
     **********/
    public ComponentFunction altLeftDrag(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "altLeftDrag.appMapSubkey = null");
        return GenericObjectFunctions.altLeftDrag(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                  An ALT left mouse drag is performed on the object based on the stored coordinates.
                 
                  
                  The coordinate lookup is done with the component name(Field #3) of the record AND 
                  Field #5.
                  
                  Typical Data Table records:
                  
                  (1) t MainWindow GenericItem AltLeftDrag DragName
                  
                  #1 above will contain a GenericItem entry in the MainWindow section with 
                  normal recognition information for it .  GenericItem will also have it's
                  own section in the Application Map in which there will be an entry like:
                  
                  DragName="15,30,60,90"    OR
                  DragName="Coords=15,30,60,90"
                  
                  This will tell RFT to locate the GenericItem Window object and an ALT left mouse drag
                  from coordinates 15,30 to 60,90.
  	            </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for an ALT left mouse drag.
                
     **********/
    public void altLeftDrag(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "altLeftDrag.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "altLeftDrag.appMapSubkey = null");
        table.add( GenericObjectFunctions.altLeftDrag(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                A single click on an object.
              
                
                By default, clicks on the center of the component.
                We can also click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                For SE+, the coordinate can be percentage format, like "20%,30%". This percentage format 
                indicates the point (20% width of component, 30% height of component) relative to the object.
                
                The object to be clicked is first given context and then a click is 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow  Click
                (2) t MainWindow MainWindow  Click AnObject
                (3) t MainWindow FolderTree  Click Node1
                (4) t MainWindow MainWindow  Click "50,200"
                (5) t MainWindow MainWindow  Click "Coords=50,200"
                
                For SE+, the Data Table records can be:
                
                (6) t MainWindow MainWindow  Click "50%,20%"
                (7) t MainWindow MainWindow  Click "50,20%"
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and click at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to click relative to the item.
                
                #6 and #7 above show using percentage format in SE+. #6 will click at position, 
                where the X value equals 50% width of component, its Y value equals 20% height of component, 
                relative to the object. #7 will click at position, where the X value equals 50, 
                its Y value equals 20% height of component, relative to the object.
                
                Rational Robot no longer requires the AppMapSubKey be provided and will 
                attempt to use the string as literal text if no AppMapSubKey is found in 
                the current App Map.  Robot also no longer assumes the AppMapSubKey value 
                or the literal value is presenting coordinate information.  This allows 
                components that can accept parameters other than coordinates, like table 
                row/col values or ImageMap areas to be specified.
                
                If the value is deduced to contain coordinates, but is not prefixed with 
                "Coords=" text, then Robot will add the prefix.  Otherwise, the text value 
                will remain unmodified.
                
		        This is the direction we expect all tools to follow going forward.
		        
		        Engines should also attempt to support coordinates separated by alternate separators.  
		        The most common separators that should be supported would be:
		        
		        "," (comma) Example: "50,200"
		        ";" (semi-colon) Example: "50;200"
		        " " (space) Example: "50 200"
		        
		        
		        Note: the TID supports this command using 
		        Image-Based Testing 
		        techniques and App Map entries as well as literal text coordinates.
		        
		        For IOS: Any optional coordinates MUST be specified as an integer number between 
		        0-100.  0 represents the extreme left (or top), while 100 represents the extreme 
		        right (or bottom). IOS does not use absolute coordinates, but relative coordinates 
		        representing a percentage of the element width or height.
		        
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public ComponentFunction click(String appMapSubkey, String autoScroll ) {

        return GenericObjectFunctions.click(getWindow().getName(), getName(), appMapSubkey, autoScroll);
    }

    /*********** <pre> 
                A single click on an object.
              
                
                By default, clicks on the center of the component.
                We can also click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                For SE+, the coordinate can be percentage format, like "20%,30%". This percentage format 
                indicates the point (20% width of component, 30% height of component) relative to the object.
                
                The object to be clicked is first given context and then a click is 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow  Click
                (2) t MainWindow MainWindow  Click AnObject
                (3) t MainWindow FolderTree  Click Node1
                (4) t MainWindow MainWindow  Click "50,200"
                (5) t MainWindow MainWindow  Click "Coords=50,200"
                
                For SE+, the Data Table records can be:
                
                (6) t MainWindow MainWindow  Click "50%,20%"
                (7) t MainWindow MainWindow  Click "50,20%"
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and click at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to click relative to the item.
                
                #6 and #7 above show using percentage format in SE+. #6 will click at position, 
                where the X value equals 50% width of component, its Y value equals 20% height of component, 
                relative to the object. #7 will click at position, where the X value equals 50, 
                its Y value equals 20% height of component, relative to the object.
                
                Rational Robot no longer requires the AppMapSubKey be provided and will 
                attempt to use the string as literal text if no AppMapSubKey is found in 
                the current App Map.  Robot also no longer assumes the AppMapSubKey value 
                or the literal value is presenting coordinate information.  This allows 
                components that can accept parameters other than coordinates, like table 
                row/col values or ImageMap areas to be specified.
                
                If the value is deduced to contain coordinates, but is not prefixed with 
                "Coords=" text, then Robot will add the prefix.  Otherwise, the text value 
                will remain unmodified.
                
		        This is the direction we expect all tools to follow going forward.
		        
		        Engines should also attempt to support coordinates separated by alternate separators.  
		        The most common separators that should be supported would be:
		        
		        "," (comma) Example: "50,200"
		        ";" (semi-colon) Example: "50;200"
		        " " (space) Example: "50 200"
		        
		        
		        Note: the TID supports this command using 
		        Image-Based Testing 
		        techniques and App Map entries as well as literal text coordinates.
		        
		        For IOS: Any optional coordinates MUST be specified as an integer number between 
		        0-100.  0 represents the extreme left (or top), while 100 represents the extreme 
		        right (or bottom). IOS does not use absolute coordinates, but relative coordinates 
		        representing a percentage of the element width or height.
		        
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public void click(StepTestTable table, String appMapSubkey, String autoScroll ) {

        if ( table == null ) throw new IllegalArgumentException ( "click.table = null");

        table.add( GenericObjectFunctions.click(getWindow().getName(), getName(), appMapSubkey, autoScroll));
    }

    /*********** <pre> 
                A single click on an object.
              
                
                By default, clicks on the center of the component.
                We can also click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                For SE+, the coordinate can be percentage format, like "20%,30%". This percentage format 
                indicates the point (20% width of component, 30% height of component) relative to the object.
                
                The object to be clicked is first given context and then a click is 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow  Click
                (2) t MainWindow MainWindow  Click AnObject
                (3) t MainWindow FolderTree  Click Node1
                (4) t MainWindow MainWindow  Click "50,200"
                (5) t MainWindow MainWindow  Click "Coords=50,200"
                
                For SE+, the Data Table records can be:
                
                (6) t MainWindow MainWindow  Click "50%,20%"
                (7) t MainWindow MainWindow  Click "50,20%"
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and click at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to click relative to the item.
                
                #6 and #7 above show using percentage format in SE+. #6 will click at position, 
                where the X value equals 50% width of component, its Y value equals 20% height of component, 
                relative to the object. #7 will click at position, where the X value equals 50, 
                its Y value equals 20% height of component, relative to the object.
                
                Rational Robot no longer requires the AppMapSubKey be provided and will 
                attempt to use the string as literal text if no AppMapSubKey is found in 
                the current App Map.  Robot also no longer assumes the AppMapSubKey value 
                or the literal value is presenting coordinate information.  This allows 
                components that can accept parameters other than coordinates, like table 
                row/col values or ImageMap areas to be specified.
                
                If the value is deduced to contain coordinates, but is not prefixed with 
                "Coords=" text, then Robot will add the prefix.  Otherwise, the text value 
                will remain unmodified.
                
		        This is the direction we expect all tools to follow going forward.
		        
		        Engines should also attempt to support coordinates separated by alternate separators.  
		        The most common separators that should be supported would be:
		        
		        "," (comma) Example: "50,200"
		        ";" (semi-colon) Example: "50;200"
		        " " (space) Example: "50 200"
		        
		        
		        Note: the TID supports this command using 
		        Image-Based Testing 
		        techniques and App Map entries as well as literal text coordinates.
		        
		        For IOS: Any optional coordinates MUST be specified as an integer number between 
		        0-100.  0 represents the extreme left (or top), while 100 represents the extreme 
		        right (or bottom). IOS does not use absolute coordinates, but relative coordinates 
		        representing a percentage of the element width or height.
		        
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public ComponentFunction click(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "click.parameters = null");
        return GenericObjectFunctions.click(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                A single click on an object.
              
                
                By default, clicks on the center of the component.
                We can also click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                For SE+, the coordinate can be percentage format, like "20%,30%". This percentage format 
                indicates the point (20% width of component, 30% height of component) relative to the object.
                
                The object to be clicked is first given context and then a click is 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow  Click
                (2) t MainWindow MainWindow  Click AnObject
                (3) t MainWindow FolderTree  Click Node1
                (4) t MainWindow MainWindow  Click "50,200"
                (5) t MainWindow MainWindow  Click "Coords=50,200"
                
                For SE+, the Data Table records can be:
                
                (6) t MainWindow MainWindow  Click "50%,20%"
                (7) t MainWindow MainWindow  Click "50,20%"
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and click at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to click relative to the item.
                
                #6 and #7 above show using percentage format in SE+. #6 will click at position, 
                where the X value equals 50% width of component, its Y value equals 20% height of component, 
                relative to the object. #7 will click at position, where the X value equals 50, 
                its Y value equals 20% height of component, relative to the object.
                
                Rational Robot no longer requires the AppMapSubKey be provided and will 
                attempt to use the string as literal text if no AppMapSubKey is found in 
                the current App Map.  Robot also no longer assumes the AppMapSubKey value 
                or the literal value is presenting coordinate information.  This allows 
                components that can accept parameters other than coordinates, like table 
                row/col values or ImageMap areas to be specified.
                
                If the value is deduced to contain coordinates, but is not prefixed with 
                "Coords=" text, then Robot will add the prefix.  Otherwise, the text value 
                will remain unmodified.
                
		        This is the direction we expect all tools to follow going forward.
		        
		        Engines should also attempt to support coordinates separated by alternate separators.  
		        The most common separators that should be supported would be:
		        
		        "," (comma) Example: "50,200"
		        ";" (semi-colon) Example: "50;200"
		        " " (space) Example: "50 200"
		        
		        
		        Note: the TID supports this command using 
		        Image-Based Testing 
		        techniques and App Map entries as well as literal text coordinates.
		        
		        For IOS: Any optional coordinates MUST be specified as an integer number between 
		        0-100.  0 represents the extreme left (or top), while 100 represents the extreme 
		        right (or bottom). IOS does not use absolute coordinates, but relative coordinates 
		        representing a percentage of the element width or height.
		        
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public void click(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "click.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "click.parameters = null");
        table.add( GenericObjectFunctions.click(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Same as Click.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey type of use as documented in the CLICK command.
              
     **********/
    public ComponentFunction clickScreenImage(String appMapSubKey ) {

        return GenericObjectFunctions.clickScreenImage(getWindow().getName(), getName(), appMapSubKey);
    }

    /*********** <pre> 
                Same as Click.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey type of use as documented in the CLICK command.
              
     **********/
    public void clickScreenImage(StepTestTable table, String appMapSubKey ) {

        if ( table == null ) throw new IllegalArgumentException ( "clickScreenImage.table = null");

        table.add( GenericObjectFunctions.clickScreenImage(getWindow().getName(), getName(), appMapSubKey));
    }

    /*********** <pre> 
                Click a specified screen location.
              
                Click a specified screen location.
                We can click on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component ClickScreenLocation
                (2) t MainWindow MainWindow ClickScreenLocation AnObject
                (3) t MainWindow MainWindow ClickScreenLocation 50,80
                (4) t AnyWin AnyComp ClickScreenLocation Node1
                
                #1 above will contain a blank as it's 5th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinates for the click.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the click will occur with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the click will occur with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates for the click.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to locate in the AppMap.
              
     **********/
    public ComponentFunction clickScreenLocation(String appMapSubkey ) {

        return GenericObjectFunctions.clickScreenLocation(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                Click a specified screen location.
              
                Click a specified screen location.
                We can click on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component ClickScreenLocation
                (2) t MainWindow MainWindow ClickScreenLocation AnObject
                (3) t MainWindow MainWindow ClickScreenLocation 50,80
                (4) t AnyWin AnyComp ClickScreenLocation Node1
                
                #1 above will contain a blank as it's 5th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinates for the click.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the click will occur with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the click will occur with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates for the click.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to locate in the AppMap.
              
     **********/
    public void clickScreenLocation(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "clickScreenLocation.table = null");

        table.add( GenericObjectFunctions.clickScreenLocation(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                (Deprecated) Click a specified screen location.
              
                (Deprecated) Click a specified screen location. See ClickScreenLocation 
                for the preferred method to click on screen coordinates.
                
                We can click on any screen location based on literal text x,y 
                coordinates retrieved from Field #5.  Window and Component names and App Map entries are 
                completely ignored.  So the user can put anything in those fields that might help test readability.  
                
                It is not recommended to hardcode screen coordinates in the test table in this way.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param coords  Optional:NO 
                The hardcoded X,Y screen coordinates--or the result of an expression--that provides the 
                absolute screen coordinates to click.
              
     **********/
    public ComponentFunction clickScreenPoint(String coords ) {

        if ( coords == null ) throw new IllegalArgumentException ( "clickScreenPoint.coords = null");
        return GenericObjectFunctions.clickScreenPoint(getWindow().getName(), getName(), coords);
    }

    /*********** <pre> 
                (Deprecated) Click a specified screen location.
              
                (Deprecated) Click a specified screen location. See ClickScreenLocation 
                for the preferred method to click on screen coordinates.
                
                We can click on any screen location based on literal text x,y 
                coordinates retrieved from Field #5.  Window and Component names and App Map entries are 
                completely ignored.  So the user can put anything in those fields that might help test readability.  
                
                It is not recommended to hardcode screen coordinates in the test table in this way.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param coords  Optional:NO 
                The hardcoded X,Y screen coordinates--or the result of an expression--that provides the 
                absolute screen coordinates to click.
              
     **********/
    public void clickScreenPoint(StepTestTable table, String coords ) {

        if ( table == null ) throw new IllegalArgumentException ( "clickScreenPoint.table = null");

        if ( coords == null ) throw new IllegalArgumentException ( "clickScreenPoint.coords = null");
        table.add( GenericObjectFunctions.clickScreenPoint(getWindow().getName(), getName(), coords));
    }

    /*********** <pre> 
                Performs a GenericObjectVP CompareData on an object.
               
                
                THE BENCHMARK VP MUST ALREADY EXIST AND BE AN ASSET OF THE CURRENTLY
                RUNNING SCRIPT.
                
                Modified VP parameter information can be added to the standard
                VP=VPName by including the VPName reference in the application map
                in a section defined for the object.  If this is done, the value 
                retrieved from the application map will be appended to VP=VPName.
                The required semicolon for this append will be provided by this routine.
                
                Example 1: Perform a standard HTMLImage CompareData.  To perform
                a basic CompareData the name "StoredVP" will not exist in the app map:
                
                The Step File call:
                 
                BrowserWindow AnHTMLImage CompareStoredData StoredVP
                 
                This will produce a CompareData VP with "VP=StoredVP;Wait=2,10".
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                
                Example 2: Perform a HTMLImage CompareData providing addition 
                parameter information (such as ExpectedResult=FAIL).  To do this the
                HTMLImage object must have its own section in the app map and an item
                with the same name as the StoredVP.  The value of that item will be
                appended to the standard VP argument with a semicolon.
                
                Part of App Map:
                
                [BrowserWindow]
                BrowserWindow=WindowTag=WEBBrowser
                AnHTMLImage=<snipped for brevity>;\;Type=HTMLImage;Index=1
                ...
                [AnHTMLImage]
                StoredVP=ExpectedResult=FAIL;Wait=3,30
                
                The Step File call:
                
                BrowserWindow AnHTMLImage CompareStoredData StoredVP
                
                This will produce a CompareData VP with all the parameters appended
                like this: "VP=StoredVP;ExpectedResult=FAIL;Wait=3,30".
                NOTE:When stored parameters are found in the app map then the default Wait= 
                parameter used in the standard compare is no longer provided.  If you still 
                need a Wait= parameter, then it must be included in the stored parameters.
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    </UL>

     @param vPAsset  Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              
     @param addParams  Optional:YES 
                Additional parameter name used for lookup, or as literal text.
              
     **********/
    public ComponentFunction compareStoredData(String vPAsset, String addParams ) {

        if ( vPAsset == null ) throw new IllegalArgumentException ( "compareStoredData.vPAsset = null");
        return GenericObjectFunctions.compareStoredData(getWindow().getName(), getName(), vPAsset, addParams);
    }

    /*********** <pre> 
                Performs a GenericObjectVP CompareData on an object.
               
                
                THE BENCHMARK VP MUST ALREADY EXIST AND BE AN ASSET OF THE CURRENTLY
                RUNNING SCRIPT.
                
                Modified VP parameter information can be added to the standard
                VP=VPName by including the VPName reference in the application map
                in a section defined for the object.  If this is done, the value 
                retrieved from the application map will be appended to VP=VPName.
                The required semicolon for this append will be provided by this routine.
                
                Example 1: Perform a standard HTMLImage CompareData.  To perform
                a basic CompareData the name "StoredVP" will not exist in the app map:
                
                The Step File call:
                 
                BrowserWindow AnHTMLImage CompareStoredData StoredVP
                 
                This will produce a CompareData VP with "VP=StoredVP;Wait=2,10".
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                
                Example 2: Perform a HTMLImage CompareData providing addition 
                parameter information (such as ExpectedResult=FAIL).  To do this the
                HTMLImage object must have its own section in the app map and an item
                with the same name as the StoredVP.  The value of that item will be
                appended to the standard VP argument with a semicolon.
                
                Part of App Map:
                
                [BrowserWindow]
                BrowserWindow=WindowTag=WEBBrowser
                AnHTMLImage=<snipped for brevity>;\;Type=HTMLImage;Index=1
                ...
                [AnHTMLImage]
                StoredVP=ExpectedResult=FAIL;Wait=3,30
                
                The Step File call:
                
                BrowserWindow AnHTMLImage CompareStoredData StoredVP
                
                This will produce a CompareData VP with all the parameters appended
                like this: "VP=StoredVP;ExpectedResult=FAIL;Wait=3,30".
                NOTE:When stored parameters are found in the app map then the default Wait= 
                parameter used in the standard compare is no longer provided.  If you still 
                need a Wait= parameter, then it must be included in the stored parameters.
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param vPAsset  Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              
     @param addParams  Optional:YES 
                Additional parameter name used for lookup, or as literal text.
              
     **********/
    public void compareStoredData(StepTestTable table, String vPAsset, String addParams ) {

        if ( table == null ) throw new IllegalArgumentException ( "compareStoredData.table = null");

        if ( vPAsset == null ) throw new IllegalArgumentException ( "compareStoredData.vPAsset = null");
        table.add( GenericObjectFunctions.compareStoredData(getWindow().getName(), getName(), vPAsset, addParams));
    }

    /*********** <pre> 
                Performs a GenericObjectVP CompareData on an object.
               
                
                THE BENCHMARK VP MUST ALREADY EXIST AND BE AN ASSET OF THE CURRENTLY
                RUNNING SCRIPT.
                
                Modified VP parameter information can be added to the standard
                VP=VPName by including the VPName reference in the application map
                in a section defined for the object.  If this is done, the value 
                retrieved from the application map will be appended to VP=VPName.
                The required semicolon for this append will be provided by this routine.
                
                Example 1: Perform a standard HTMLImage CompareData.  To perform
                a basic CompareData the name "StoredVP" will not exist in the app map:
                
                The Step File call:
                 
                BrowserWindow AnHTMLImage CompareStoredData StoredVP
                 
                This will produce a CompareData VP with "VP=StoredVP;Wait=2,10".
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                
                Example 2: Perform a HTMLImage CompareData providing addition 
                parameter information (such as ExpectedResult=FAIL).  To do this the
                HTMLImage object must have its own section in the app map and an item
                with the same name as the StoredVP.  The value of that item will be
                appended to the standard VP argument with a semicolon.
                
                Part of App Map:
                
                [BrowserWindow]
                BrowserWindow=WindowTag=WEBBrowser
                AnHTMLImage=<snipped for brevity>;\;Type=HTMLImage;Index=1
                ...
                [AnHTMLImage]
                StoredVP=ExpectedResult=FAIL;Wait=3,30
                
                The Step File call:
                
                BrowserWindow AnHTMLImage CompareStoredData StoredVP
                
                This will produce a CompareData VP with all the parameters appended
                like this: "VP=StoredVP;ExpectedResult=FAIL;Wait=3,30".
                NOTE:When stored parameters are found in the app map then the default Wait= 
                parameter used in the standard compare is no longer provided.  If you still 
                need a Wait= parameter, then it must be included in the stored parameters.
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         vPAsset -- Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              <BR/>         addParams -- Optional:YES 
                Additional parameter name used for lookup, or as literal text.
              
    </UL>

     **********/
    public ComponentFunction compareStoredData(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "compareStoredData.parameters = null");
        return GenericObjectFunctions.compareStoredData(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                Performs a GenericObjectVP CompareData on an object.
               
                
                THE BENCHMARK VP MUST ALREADY EXIST AND BE AN ASSET OF THE CURRENTLY
                RUNNING SCRIPT.
                
                Modified VP parameter information can be added to the standard
                VP=VPName by including the VPName reference in the application map
                in a section defined for the object.  If this is done, the value 
                retrieved from the application map will be appended to VP=VPName.
                The required semicolon for this append will be provided by this routine.
                
                Example 1: Perform a standard HTMLImage CompareData.  To perform
                a basic CompareData the name "StoredVP" will not exist in the app map:
                
                The Step File call:
                 
                BrowserWindow AnHTMLImage CompareStoredData StoredVP
                 
                This will produce a CompareData VP with "VP=StoredVP;Wait=2,10".
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                
                Example 2: Perform a HTMLImage CompareData providing addition 
                parameter information (such as ExpectedResult=FAIL).  To do this the
                HTMLImage object must have its own section in the app map and an item
                with the same name as the StoredVP.  The value of that item will be
                appended to the standard VP argument with a semicolon.
                
                Part of App Map:
                
                [BrowserWindow]
                BrowserWindow=WindowTag=WEBBrowser
                AnHTMLImage=<snipped for brevity>;\;Type=HTMLImage;Index=1
                ...
                [AnHTMLImage]
                StoredVP=ExpectedResult=FAIL;Wait=3,30
                
                The Step File call:
                
                BrowserWindow AnHTMLImage CompareStoredData StoredVP
                
                This will produce a CompareData VP with all the parameters appended
                like this: "VP=StoredVP;ExpectedResult=FAIL;Wait=3,30".
                NOTE:When stored parameters are found in the app map then the default Wait= 
                parameter used in the standard compare is no longer provided.  If you still 
                need a Wait= parameter, then it must be included in the stored parameters.
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         vPAsset -- Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              <BR/>         addParams -- Optional:YES 
                Additional parameter name used for lookup, or as literal text.
              
    </UL>

     **********/
    public void compareStoredData(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "compareStoredData.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "compareStoredData.parameters = null");
        table.add( GenericObjectFunctions.compareStoredData(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Performs a GenericObjectVP CompareProperties on an object.
               
                Performs a GenericObjectVP CompareProperties on an object.
                
                THE BENCHMARK VP MUST ALREADY EXIST AND BE AN ASSET OF THE CURRENTLY
                RUNNING SCRIPT.
                
                Modified VP parameter information can be added to the standard
                VP=VPName by including the VPName reference in the application map
                in a section defined for the object.  If this is done, the value 
                retrieved from the application map will be appended to VP=VPName.
                The required semicolon for this append will be provided by this routine.
                
                Example 1: Perform a standard HTMLImage CompareProperties.  To perform
                a basic CompareProperties the name "StoredVP" will not exist in the app map:
                
                The Step File call:
                 
                BrowserWindow AnHTMLImage CompareStoredProperties StoredVP
                 
                This will produce a VP with "VP=StoredVP;Wait=2,10".
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                
                Example 2: Perform a HTMLImage CompareProperties providing addition 
                parameter information (such as ExpectedResult=FAIL).  To do this the
                HTMLImage object must have its own section in the app map and an item
                with the same name as the StoredVP.  The value of that item will be
                appended to the standard VP argument with a semicolon.
                
                Part of App Map:
                
                [BrowserWindow]
                BrowserWindow=WindowTag=WEBBrowser
                AnHTMLImage=<snipped for brevity>;\;Type=HTMLImage;Index=1
                ...
                [AnHTMLImage]
                StoredVP=ExpectedResult=FAIL;Wait=3,30
                
                The Step File call:
                
                BrowserWindow AnHTMLImage CompareStoredProperties StoredVP
                
                This will produce a VP with all the parameters appended
                like this: "VP=StoredVP;ExpectedResult=FAIL;Wait=3,30".
                NOTE:When stored parameters are found in the app map then the default Wait= 
                parameter used in the standard compare is no longer provided.  If you still 
                need a Wait= parameter, then it must be included in the stored parameters.
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param vPAsset  Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              
     @param addParams  Optional:YES 
                Additional parameter name used for lookup, or as literal text.
              
     **********/
    public ComponentFunction compareStoredProperties(String vPAsset, String addParams ) {

        if ( vPAsset == null ) throw new IllegalArgumentException ( "compareStoredProperties.vPAsset = null");
        return GenericObjectFunctions.compareStoredProperties(getWindow().getName(), getName(), vPAsset, addParams);
    }

    /*********** <pre> 
                Performs a GenericObjectVP CompareProperties on an object.
               
                Performs a GenericObjectVP CompareProperties on an object.
                
                THE BENCHMARK VP MUST ALREADY EXIST AND BE AN ASSET OF THE CURRENTLY
                RUNNING SCRIPT.
                
                Modified VP parameter information can be added to the standard
                VP=VPName by including the VPName reference in the application map
                in a section defined for the object.  If this is done, the value 
                retrieved from the application map will be appended to VP=VPName.
                The required semicolon for this append will be provided by this routine.
                
                Example 1: Perform a standard HTMLImage CompareProperties.  To perform
                a basic CompareProperties the name "StoredVP" will not exist in the app map:
                
                The Step File call:
                 
                BrowserWindow AnHTMLImage CompareStoredProperties StoredVP
                 
                This will produce a VP with "VP=StoredVP;Wait=2,10".
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                
                Example 2: Perform a HTMLImage CompareProperties providing addition 
                parameter information (such as ExpectedResult=FAIL).  To do this the
                HTMLImage object must have its own section in the app map and an item
                with the same name as the StoredVP.  The value of that item will be
                appended to the standard VP argument with a semicolon.
                
                Part of App Map:
                
                [BrowserWindow]
                BrowserWindow=WindowTag=WEBBrowser
                AnHTMLImage=<snipped for brevity>;\;Type=HTMLImage;Index=1
                ...
                [AnHTMLImage]
                StoredVP=ExpectedResult=FAIL;Wait=3,30
                
                The Step File call:
                
                BrowserWindow AnHTMLImage CompareStoredProperties StoredVP
                
                This will produce a VP with all the parameters appended
                like this: "VP=StoredVP;ExpectedResult=FAIL;Wait=3,30".
                NOTE:When stored parameters are found in the app map then the default Wait= 
                parameter used in the standard compare is no longer provided.  If you still 
                need a Wait= parameter, then it must be included in the stored parameters.
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param vPAsset  Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              
     @param addParams  Optional:YES 
                Additional parameter name used for lookup, or as literal text.
              
     **********/
    public void compareStoredProperties(StepTestTable table, String vPAsset, String addParams ) {

        if ( table == null ) throw new IllegalArgumentException ( "compareStoredProperties.table = null");

        if ( vPAsset == null ) throw new IllegalArgumentException ( "compareStoredProperties.vPAsset = null");
        table.add( GenericObjectFunctions.compareStoredProperties(getWindow().getName(), getName(), vPAsset, addParams));
    }

    /*********** <pre> 
                Performs a GenericObjectVP CompareProperties on an object.
               
                Performs a GenericObjectVP CompareProperties on an object.
                
                THE BENCHMARK VP MUST ALREADY EXIST AND BE AN ASSET OF THE CURRENTLY
                RUNNING SCRIPT.
                
                Modified VP parameter information can be added to the standard
                VP=VPName by including the VPName reference in the application map
                in a section defined for the object.  If this is done, the value 
                retrieved from the application map will be appended to VP=VPName.
                The required semicolon for this append will be provided by this routine.
                
                Example 1: Perform a standard HTMLImage CompareProperties.  To perform
                a basic CompareProperties the name "StoredVP" will not exist in the app map:
                
                The Step File call:
                 
                BrowserWindow AnHTMLImage CompareStoredProperties StoredVP
                 
                This will produce a VP with "VP=StoredVP;Wait=2,10".
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                
                Example 2: Perform a HTMLImage CompareProperties providing addition 
                parameter information (such as ExpectedResult=FAIL).  To do this the
                HTMLImage object must have its own section in the app map and an item
                with the same name as the StoredVP.  The value of that item will be
                appended to the standard VP argument with a semicolon.
                
                Part of App Map:
                
                [BrowserWindow]
                BrowserWindow=WindowTag=WEBBrowser
                AnHTMLImage=<snipped for brevity>;\;Type=HTMLImage;Index=1
                ...
                [AnHTMLImage]
                StoredVP=ExpectedResult=FAIL;Wait=3,30
                
                The Step File call:
                
                BrowserWindow AnHTMLImage CompareStoredProperties StoredVP
                
                This will produce a VP with all the parameters appended
                like this: "VP=StoredVP;ExpectedResult=FAIL;Wait=3,30".
                NOTE:When stored parameters are found in the app map then the default Wait= 
                parameter used in the standard compare is no longer provided.  If you still 
                need a Wait= parameter, then it must be included in the stored parameters.
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         vPAsset -- Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              <BR/>         addParams -- Optional:YES 
                Additional parameter name used for lookup, or as literal text.
              
    </UL>

     **********/
    public ComponentFunction compareStoredProperties(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "compareStoredProperties.parameters = null");
        return GenericObjectFunctions.compareStoredProperties(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                Performs a GenericObjectVP CompareProperties on an object.
               
                Performs a GenericObjectVP CompareProperties on an object.
                
                THE BENCHMARK VP MUST ALREADY EXIST AND BE AN ASSET OF THE CURRENTLY
                RUNNING SCRIPT.
                
                Modified VP parameter information can be added to the standard
                VP=VPName by including the VPName reference in the application map
                in a section defined for the object.  If this is done, the value 
                retrieved from the application map will be appended to VP=VPName.
                The required semicolon for this append will be provided by this routine.
                
                Example 1: Perform a standard HTMLImage CompareProperties.  To perform
                a basic CompareProperties the name "StoredVP" will not exist in the app map:
                
                The Step File call:
                 
                BrowserWindow AnHTMLImage CompareStoredProperties StoredVP
                 
                This will produce a VP with "VP=StoredVP;Wait=2,10".
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                
                Example 2: Perform a HTMLImage CompareProperties providing addition 
                parameter information (such as ExpectedResult=FAIL).  To do this the
                HTMLImage object must have its own section in the app map and an item
                with the same name as the StoredVP.  The value of that item will be
                appended to the standard VP argument with a semicolon.
                
                Part of App Map:
                
                [BrowserWindow]
                BrowserWindow=WindowTag=WEBBrowser
                AnHTMLImage=<snipped for brevity>;\;Type=HTMLImage;Index=1
                ...
                [AnHTMLImage]
                StoredVP=ExpectedResult=FAIL;Wait=3,30
                
                The Step File call:
                
                BrowserWindow AnHTMLImage CompareStoredProperties StoredVP
                
                This will produce a VP with all the parameters appended
                like this: "VP=StoredVP;ExpectedResult=FAIL;Wait=3,30".
                NOTE:When stored parameters are found in the app map then the default Wait= 
                parameter used in the standard compare is no longer provided.  If you still 
                need a Wait= parameter, then it must be included in the stored parameters.
                
                The StoredVP baseline MUST already exist as an asset of the
                currently running script.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         vPAsset -- Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              <BR/>         addParams -- Optional:YES 
                Additional parameter name used for lookup, or as literal text.
              
    </UL>

     **********/
    public void compareStoredProperties(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "compareStoredProperties.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "compareStoredProperties.parameters = null");
        table.add( GenericObjectFunctions.compareStoredProperties(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                  CTRL ALT left mouse drag is performed on the object based on the stored coordinates.
                 
                  
                  The coordinate lookup is done with the component name(Field #3) of the record AND 
                  Field #5.
                  
                  Typical Data Table records:
                  
                  (1) t MainWindow GenericItem CtrlAltLeftDrag DragName
                  
                  #1 above will contain a GenericItem entry in the MainWindow section with 
                  normal recognition information for it .  GenericItem will also have it's
                  own section in the Application Map in which there will be an entry like:
                  
                  DragName="15,30,60,90"    OR
                  DragName="Coords=15,30,60,90"
                  
                  This will tell RFT to locate the GenericItem Window object and CTRL ALT left mouse drag
                  from coordinates 15,30 to 60,90.
  	            </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for the CTRL ALT left mouse drag.
                
     **********/
    public ComponentFunction ctrlAltLeftDrag(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "ctrlAltLeftDrag.appMapSubkey = null");
        return GenericObjectFunctions.ctrlAltLeftDrag(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                  CTRL ALT left mouse drag is performed on the object based on the stored coordinates.
                 
                  
                  The coordinate lookup is done with the component name(Field #3) of the record AND 
                  Field #5.
                  
                  Typical Data Table records:
                  
                  (1) t MainWindow GenericItem CtrlAltLeftDrag DragName
                  
                  #1 above will contain a GenericItem entry in the MainWindow section with 
                  normal recognition information for it .  GenericItem will also have it's
                  own section in the Application Map in which there will be an entry like:
                  
                  DragName="15,30,60,90"    OR
                  DragName="Coords=15,30,60,90"
                  
                  This will tell RFT to locate the GenericItem Window object and CTRL ALT left mouse drag
                  from coordinates 15,30 to 60,90.
  	            </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for the CTRL ALT left mouse drag.
                
     **********/
    public void ctrlAltLeftDrag(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "ctrlAltLeftDrag.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "ctrlAltLeftDrag.appMapSubkey = null");
        table.add( GenericObjectFunctions.ctrlAltLeftDrag(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre>
                A CTRL-click on an object.
              
                By default we should click the center of the object.
                We can also CTRL-click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a CTRL-click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow CtrlClick
                (2) t MainWindow MainWindow CtrlClick AnObject
                (3) t MainWindow  ToolItem  CtrlClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to CTRL-click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and CTRL-click at the coordinates specified by the reference.
				
				Engines should also attempt to support coordinates separated by alternate separators.  
				The most common separators that should be supported would be:
				
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
				
				
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the CTRL-click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public ComponentFunction ctrlClick(String appMapSubkey, String autoScroll ) {

        return GenericObjectFunctions.ctrlClick(getWindow().getName(), getName(), appMapSubkey, autoScroll);
    }

    /*********** <pre>
                A CTRL-click on an object.
              
                By default we should click the center of the object.
                We can also CTRL-click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a CTRL-click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow CtrlClick
                (2) t MainWindow MainWindow CtrlClick AnObject
                (3) t MainWindow  ToolItem  CtrlClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to CTRL-click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and CTRL-click at the coordinates specified by the reference.
				
				Engines should also attempt to support coordinates separated by alternate separators.  
				The most common separators that should be supported would be:
				
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
				
				
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the CTRL-click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public void ctrlClick(StepTestTable table, String appMapSubkey, String autoScroll ) {

        if ( table == null ) throw new IllegalArgumentException ( "ctrlClick.table = null");

        table.add( GenericObjectFunctions.ctrlClick(getWindow().getName(), getName(), appMapSubkey, autoScroll));
    }

    /*********** <pre>
                A CTRL-click on an object.
              
                By default we should click the center of the object.
                We can also CTRL-click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a CTRL-click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow CtrlClick
                (2) t MainWindow MainWindow CtrlClick AnObject
                (3) t MainWindow  ToolItem  CtrlClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to CTRL-click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and CTRL-click at the coordinates specified by the reference.
				
				Engines should also attempt to support coordinates separated by alternate separators.  
				The most common separators that should be supported would be:
				
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
				
				
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the CTRL-click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public ComponentFunction ctrlClick(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "ctrlClick.parameters = null");
        return GenericObjectFunctions.ctrlClick(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
                A CTRL-click on an object.
              
                By default we should click the center of the object.
                We can also CTRL-click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a CTRL-click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow CtrlClick
                (2) t MainWindow MainWindow CtrlClick AnObject
                (3) t MainWindow  ToolItem  CtrlClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to CTRL-click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and CTRL-click at the coordinates specified by the reference.
				
				Engines should also attempt to support coordinates separated by alternate separators.  
				The most common separators that should be supported would be:
				
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
				
				
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the CTRL-click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public void ctrlClick(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "ctrlClick.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "ctrlClick.parameters = null");
        table.add( GenericObjectFunctions.ctrlClick(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Same as CtrlClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey type of use as documented in the CLICK command.
              
     **********/
    public ComponentFunction ctrlClickScreenImage(String appMapSubKey ) {

        return GenericObjectFunctions.ctrlClickScreenImage(getWindow().getName(), getName(), appMapSubKey);
    }

    /*********** <pre> 
                Same as CtrlClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey type of use as documented in the CLICK command.
              
     **********/
    public void ctrlClickScreenImage(StepTestTable table, String appMapSubKey ) {

        if ( table == null ) throw new IllegalArgumentException ( "ctrlClickScreenImage.table = null");

        table.add( GenericObjectFunctions.ctrlClickScreenImage(getWindow().getName(), getName(), appMapSubKey));
    }

    /*********** <pre> 
                  A CTRL left mouse drag is performed on the object based on the stored coordinates.
               
                
                The coordinate lookup is done with the component name(Field #3) of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow GenericItem CtrlLeftDrag DragName
                
                #1 above will contain a GenericItem entry in the MainWindow section with 
                normal recognition information for it .  GenericItem will also have it's
                own section in the Application Map in which there will be an entry like:
                
                DragName="15,30,60,90"    OR
                DragName="Coords=15,30,60,90"
                
                This will tell RFT to locate the GenericItem Window object and CTRL left drag 
                from coordinates 15,30 to 60,90.
  	            </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for the CTRL left mouse drag.
                
     **********/
    public ComponentFunction ctrlLeftDrag(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "ctrlLeftDrag.appMapSubkey = null");
        return GenericObjectFunctions.ctrlLeftDrag(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                  A CTRL left mouse drag is performed on the object based on the stored coordinates.
               
                
                The coordinate lookup is done with the component name(Field #3) of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow GenericItem CtrlLeftDrag DragName
                
                #1 above will contain a GenericItem entry in the MainWindow section with 
                normal recognition information for it .  GenericItem will also have it's
                own section in the Application Map in which there will be an entry like:
                
                DragName="15,30,60,90"    OR
                DragName="Coords=15,30,60,90"
                
                This will tell RFT to locate the GenericItem Window object and CTRL left drag 
                from coordinates 15,30 to 60,90.
  	            </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for the CTRL left mouse drag.
                
     **********/
    public void ctrlLeftDrag(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "ctrlLeftDrag.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "ctrlLeftDrag.appMapSubkey = null");
        table.add( GenericObjectFunctions.ctrlLeftDrag(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre>
                A CTRL-Right click on an object.
              
                By default we should click the center of the object.
                We can also CTRL-Right-Click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a CTRL-Right-Click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow CtrlRightClick
                (2) t MainWindow MainWindow CtrlRightClick AnObject
                (3) t MainWindow  ToolItem  CtrlRightClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to CTRL-click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and CTRL-Right-Click at the coordinates specified by the reference.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the CTRL-Right-Click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public ComponentFunction ctrlRightClick(String appMapSubkey, String autoScroll ) {

        return GenericObjectFunctions.ctrlRightClick(getWindow().getName(), getName(), appMapSubkey, autoScroll);
    }

    /*********** <pre>
                A CTRL-Right click on an object.
              
                By default we should click the center of the object.
                We can also CTRL-Right-Click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a CTRL-Right-Click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow CtrlRightClick
                (2) t MainWindow MainWindow CtrlRightClick AnObject
                (3) t MainWindow  ToolItem  CtrlRightClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to CTRL-click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and CTRL-Right-Click at the coordinates specified by the reference.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the CTRL-Right-Click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public void ctrlRightClick(StepTestTable table, String appMapSubkey, String autoScroll ) {

        if ( table == null ) throw new IllegalArgumentException ( "ctrlRightClick.table = null");

        table.add( GenericObjectFunctions.ctrlRightClick(getWindow().getName(), getName(), appMapSubkey, autoScroll));
    }

    /*********** <pre>
                A CTRL-Right click on an object.
              
                By default we should click the center of the object.
                We can also CTRL-Right-Click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a CTRL-Right-Click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow CtrlRightClick
                (2) t MainWindow MainWindow CtrlRightClick AnObject
                (3) t MainWindow  ToolItem  CtrlRightClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to CTRL-click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and CTRL-Right-Click at the coordinates specified by the reference.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the CTRL-Right-Click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public ComponentFunction ctrlRightClick(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "ctrlRightClick.parameters = null");
        return GenericObjectFunctions.ctrlRightClick(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
                A CTRL-Right click on an object.
              
                By default we should click the center of the object.
                We can also CTRL-Right-Click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a CTRL-Right-Click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow CtrlRightClick
                (2) t MainWindow MainWindow CtrlRightClick AnObject
                (3) t MainWindow  ToolItem  CtrlRightClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to CTRL-click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and CTRL-Right-Click at the coordinates specified by the reference.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the CTRL-Right-Click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public void ctrlRightClick(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "ctrlRightClick.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "ctrlRightClick.parameters = null");
        table.add( GenericObjectFunctions.ctrlRightClick(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Same as CtrlRightClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey type of use as documented in the CLICK command.
              
     **********/
    public ComponentFunction ctrlRightClickScreenImage(String appMapSubKey ) {

        return GenericObjectFunctions.ctrlRightClickScreenImage(getWindow().getName(), getName(), appMapSubKey);
    }

    /*********** <pre> 
                Same as CtrlRightClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey type of use as documented in the CLICK command.
              
     **********/
    public void ctrlRightClickScreenImage(StepTestTable table, String appMapSubKey ) {

        if ( table == null ) throw new IllegalArgumentException ( "ctrlRightClickScreenImage.table = null");

        table.add( GenericObjectFunctions.ctrlRightClickScreenImage(getWindow().getName(), getName(), appMapSubKey));
    }

    /*********** <pre> 
                A CTRL SHIFT left mouse drag is performed on the object based on the stored coordinates.
               
                  
                  The coordinate lookup is done with the component name(Field #3) of the record AND 
                  Field #5.
                  
                  Typical Data Table records:
                  
                  (1) t MainWindow GenericItem CtrlShiftLeftDrag DragName
                  
                  #1 above will contain a GenericItem entry in the MainWindow section with 
                  normal recognition information for it .  GenericItem will also have it's
                  own section in the Application Map in which there will be an entry like:
                  
                  DragName="15,30,60,90"    OR
                  DragName="Coords=15,30,60,90"
                  
                  This will tell RFT to locate the GenericItem Window object and CTRL SHIFT left mouse drag
                  from coordinates 15,30 to 60,90.
  	              </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for the CTRL SHIFT left mouse drag.
              
     **********/
    public ComponentFunction ctrlShiftLeftDrag(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "ctrlShiftLeftDrag.appMapSubkey = null");
        return GenericObjectFunctions.ctrlShiftLeftDrag(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                A CTRL SHIFT left mouse drag is performed on the object based on the stored coordinates.
               
                  
                  The coordinate lookup is done with the component name(Field #3) of the record AND 
                  Field #5.
                  
                  Typical Data Table records:
                  
                  (1) t MainWindow GenericItem CtrlShiftLeftDrag DragName
                  
                  #1 above will contain a GenericItem entry in the MainWindow section with 
                  normal recognition information for it .  GenericItem will also have it's
                  own section in the Application Map in which there will be an entry like:
                  
                  DragName="15,30,60,90"    OR
                  DragName="Coords=15,30,60,90"
                  
                  This will tell RFT to locate the GenericItem Window object and CTRL SHIFT left mouse drag
                  from coordinates 15,30 to 60,90.
  	              </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for the CTRL SHIFT left mouse drag.
              
     **********/
    public void ctrlShiftLeftDrag(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "ctrlShiftLeftDrag.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "ctrlShiftLeftDrag.appMapSubkey = null");
        table.add( GenericObjectFunctions.ctrlShiftLeftDrag(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                A double click on an object.
               
                By default we should click the center of the object.
                We can also double click on any part of an object based on a stored 
                x,y coordinate.  The object containing the coordinate is first given 
                context and then a double click is generated at the coordinate.  Thus, 
                an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow DoubleClick
                (2) t MainWindow MainWindow DoubleClick AnObject
                (3) t MainWindow FolderTree DoubleClick Node1
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to double click at x=3, y=10 in the MainWindow. For SE+, the coordinate 
                can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it .  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree 
                object and double click at the coordinates specified by the reference.
  		        
		        Engines should also attempt to support coordinates separated by alternate separators.  
		        The most common separators that should be supported would be:
		        
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
		        
		        
		        Note: the TID supports this command using 
		        Image-Based Testing 
		        techniques and App Map entries as well as literal text coordinates.
		        
		        For IOS: Any optional coordinates MUST be specified as an integer number between 
		        0-100.  0 represents the extreme left (or top), while 100 represents the extreme 
		        right (or bottom). IOS does not use absolute coordinates, but relative coordinates 
		        representing a percentage of the element width or height.
		        
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Optional) Name of the AppMap subkey to lookup or the literal text to use for the double click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public ComponentFunction doubleClick(String appMapSubkey, String autoScroll ) {

        return GenericObjectFunctions.doubleClick(getWindow().getName(), getName(), appMapSubkey, autoScroll);
    }

    /*********** <pre> 
                A double click on an object.
               
                By default we should click the center of the object.
                We can also double click on any part of an object based on a stored 
                x,y coordinate.  The object containing the coordinate is first given 
                context and then a double click is generated at the coordinate.  Thus, 
                an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow DoubleClick
                (2) t MainWindow MainWindow DoubleClick AnObject
                (3) t MainWindow FolderTree DoubleClick Node1
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to double click at x=3, y=10 in the MainWindow. For SE+, the coordinate 
                can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it .  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree 
                object and double click at the coordinates specified by the reference.
  		        
		        Engines should also attempt to support coordinates separated by alternate separators.  
		        The most common separators that should be supported would be:
		        
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
		        
		        
		        Note: the TID supports this command using 
		        Image-Based Testing 
		        techniques and App Map entries as well as literal text coordinates.
		        
		        For IOS: Any optional coordinates MUST be specified as an integer number between 
		        0-100.  0 represents the extreme left (or top), while 100 represents the extreme 
		        right (or bottom). IOS does not use absolute coordinates, but relative coordinates 
		        representing a percentage of the element width or height.
		        
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Optional) Name of the AppMap subkey to lookup or the literal text to use for the double click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public void doubleClick(StepTestTable table, String appMapSubkey, String autoScroll ) {

        if ( table == null ) throw new IllegalArgumentException ( "doubleClick.table = null");

        table.add( GenericObjectFunctions.doubleClick(getWindow().getName(), getName(), appMapSubkey, autoScroll));
    }

    /*********** <pre> 
                A double click on an object.
               
                By default we should click the center of the object.
                We can also double click on any part of an object based on a stored 
                x,y coordinate.  The object containing the coordinate is first given 
                context and then a double click is generated at the coordinate.  Thus, 
                an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow DoubleClick
                (2) t MainWindow MainWindow DoubleClick AnObject
                (3) t MainWindow FolderTree DoubleClick Node1
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to double click at x=3, y=10 in the MainWindow. For SE+, the coordinate 
                can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it .  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree 
                object and double click at the coordinates specified by the reference.
  		        
		        Engines should also attempt to support coordinates separated by alternate separators.  
		        The most common separators that should be supported would be:
		        
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
		        
		        
		        Note: the TID supports this command using 
		        Image-Based Testing 
		        techniques and App Map entries as well as literal text coordinates.
		        
		        For IOS: Any optional coordinates MUST be specified as an integer number between 
		        0-100.  0 represents the extreme left (or top), while 100 represents the extreme 
		        right (or bottom). IOS does not use absolute coordinates, but relative coordinates 
		        representing a percentage of the element width or height.
		        
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional) Name of the AppMap subkey to lookup or the literal text to use for the double click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public ComponentFunction doubleClick(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "doubleClick.parameters = null");
        return GenericObjectFunctions.doubleClick(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                A double click on an object.
               
                By default we should click the center of the object.
                We can also double click on any part of an object based on a stored 
                x,y coordinate.  The object containing the coordinate is first given 
                context and then a double click is generated at the coordinate.  Thus, 
                an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow DoubleClick
                (2) t MainWindow MainWindow DoubleClick AnObject
                (3) t MainWindow FolderTree DoubleClick Node1
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to double click at x=3, y=10 in the MainWindow. For SE+, the coordinate 
                can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it .  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree 
                object and double click at the coordinates specified by the reference.
  		        
		        Engines should also attempt to support coordinates separated by alternate separators.  
		        The most common separators that should be supported would be:
		        
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
		        
		        
		        Note: the TID supports this command using 
		        Image-Based Testing 
		        techniques and App Map entries as well as literal text coordinates.
		        
		        For IOS: Any optional coordinates MUST be specified as an integer number between 
		        0-100.  0 represents the extreme left (or top), while 100 represents the extreme 
		        right (or bottom). IOS does not use absolute coordinates, but relative coordinates 
		        representing a percentage of the element width or height.
		        
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional) Name of the AppMap subkey to lookup or the literal text to use for the double click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public void doubleClick(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "doubleClick.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "doubleClick.parameters = null");
        table.add( GenericObjectFunctions.doubleClick(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Same as DoubleClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey as documented in the CLICK command.
              
     **********/
    public ComponentFunction doubleClickScreenImage(String appMapSubKey ) {

        return GenericObjectFunctions.doubleClickScreenImage(getWindow().getName(), getName(), appMapSubKey);
    }

    /*********** <pre> 
                Same as DoubleClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey as documented in the CLICK command.
              
     **********/
    public void doubleClickScreenImage(StepTestTable table, String appMapSubKey ) {

        if ( table == null ) throw new IllegalArgumentException ( "doubleClickScreenImage.table = null");

        table.add( GenericObjectFunctions.doubleClickScreenImage(getWindow().getName(), getName(), appMapSubKey));
    }

    /*********** <pre> 
                DoubleClick a specified screen location.
              
                DoubleClick a specified screen location.
                We can click on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component DoubleClickScreenLocation
                (2) t MainWindow MainWindow DoubleClickScreenLocation AnObject
                (3) t MainWindow MainWindow DoubleClickScreenLocation 50,80
                (4) t AnyWin AnyComp DoubleClickScreenLocation Node1
                
                #1 above will contain a blank as it's 5th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinates for the click.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the click will occur with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the click will occur with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates for the click.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to locate in the AppMap.
              
     **********/
    public ComponentFunction doubleClickScreenLocation(String appMapSubkey ) {

        return GenericObjectFunctions.doubleClickScreenLocation(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                DoubleClick a specified screen location.
              
                DoubleClick a specified screen location.
                We can click on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component DoubleClickScreenLocation
                (2) t MainWindow MainWindow DoubleClickScreenLocation AnObject
                (3) t MainWindow MainWindow DoubleClickScreenLocation 50,80
                (4) t AnyWin AnyComp DoubleClickScreenLocation Node1
                
                #1 above will contain a blank as it's 5th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinates for the click.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the click will occur with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the click will occur with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates for the click.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to locate in the AppMap.
              
     **********/
    public void doubleClickScreenLocation(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "doubleClickScreenLocation.table = null");

        table.add( GenericObjectFunctions.doubleClickScreenLocation(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                (Deprecated) DoubleClick a specified screen location.
              
                (Deprecated) DoubleClick a specified screen location. See DoubleClickScreenLocation 
                for the preferred method to click on screen coordinates.
                
                We can click on any screen location based on literal text x,y 
                coordinates retrieved from Field #5.  Window and Component names and App Map entries are 
                completely ignored.  So the user can put anything in those fields that might help test readability.  
                
                It is not recommended to hardcode screen coordinates in the test table in this way.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param coords  Optional:NO 
                The hardcoded X,Y screen coordinates--or the result of an expression--that provides the 
                absolute screen coordinates to click.
              
     **********/
    public ComponentFunction doubleClickScreenPoint(String coords ) {

        if ( coords == null ) throw new IllegalArgumentException ( "doubleClickScreenPoint.coords = null");
        return GenericObjectFunctions.doubleClickScreenPoint(getWindow().getName(), getName(), coords);
    }

    /*********** <pre> 
                (Deprecated) DoubleClick a specified screen location.
              
                (Deprecated) DoubleClick a specified screen location. See DoubleClickScreenLocation 
                for the preferred method to click on screen coordinates.
                
                We can click on any screen location based on literal text x,y 
                coordinates retrieved from Field #5.  Window and Component names and App Map entries are 
                completely ignored.  So the user can put anything in those fields that might help test readability.  
                
                It is not recommended to hardcode screen coordinates in the test table in this way.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param coords  Optional:NO 
                The hardcoded X,Y screen coordinates--or the result of an expression--that provides the 
                absolute screen coordinates to click.
              
     **********/
    public void doubleClickScreenPoint(StepTestTable table, String coords ) {

        if ( table == null ) throw new IllegalArgumentException ( "doubleClickScreenPoint.table = null");

        if ( coords == null ) throw new IllegalArgumentException ( "doubleClickScreenPoint.coords = null");
        table.add( GenericObjectFunctions.doubleClickScreenPoint(getWindow().getName(), getName(), coords));
    }

    /*********** <pre> 
                A double-tap on a touchscreen object.  Use keyword "DoubleClick" syntax and parameters.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     **********/
    public ComponentFunction doubleTap( ) {
        return GenericObjectFunctions.doubleTap(getWindow().getName(), getName());
    }

    /*********** <pre> 
                A double-tap on a touchscreen object.  Use keyword "DoubleClick" syntax and parameters.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void doubleTap(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "doubleTap.table = null");
        table.add( GenericObjectFunctions.doubleTap(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                  A left mouse drag is performed from one object to another object based on the offsets values.
                
                  Drag will be performed from component (from-component) to another to-component. Offsets value are the drag object select location. The location (drag and release) calucate by X and Y percentage cordination. DragTo also supports sub item of component and  sub item of to-component.
                  
                   The coordination specify by offsets value. First two values are for from-component and another are for to-component.
                  
        Offsets can be 50%,50%,50%,50% or 50%;50%;50%;50%
                  
                   
	T, WINDOW,COMPONENT, DRAGTO, ToWINDOW,ToCOMPONENT,"50%,50%,50%,50%"
	Where first 50%,50% are COMPONENT or their subitem's X and Y location
	and second 50%,50% are ToCOMPONENT or their subitem's X and Y location.
		             
                    </pre>    Supporting Engines:
    <P/><UL>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param toWindow  Optional:NO 
                  ToWindow object.
                
     @param toComponent  Optional:NO 
		    ToComponent object.
		  
     @param offsets  Optional:YES 
		    Drag and release location of from-component and to-component. Offsets syntax will be "50%,50%,70%,70%, where first two percentages for from-component's X and Y location and second two are for to-component's X and Y location. If offsets isn't specify then center will be used."
		    Default value, both components center
		  
     @param fromSubItem  Optional:YES 
		    Text of from-component's sub item.
		  
     @param toSubItem  Optional:YES 
		    Text of to-component's sub item.
		  
     **********/
    public ComponentFunction dragTo(String toWindow, String toComponent, String offsets, String fromSubItem, String toSubItem ) {

        if ( toComponent == null ) throw new IllegalArgumentException ( "dragTo.toComponent = null");
        if ( toWindow == null ) throw new IllegalArgumentException ( "dragTo.toWindow = null");
        return GenericObjectFunctions.dragTo(getWindow().getName(), getName(), toWindow, toComponent, offsets, fromSubItem, toSubItem);
    }

    /*********** <pre> 
                  A left mouse drag is performed from one object to another object based on the offsets values.
                
                  Drag will be performed from component (from-component) to another to-component. Offsets value are the drag object select location. The location (drag and release) calucate by X and Y percentage cordination. DragTo also supports sub item of component and  sub item of to-component.
                  
                   The coordination specify by offsets value. First two values are for from-component and another are for to-component.
                  
        Offsets can be 50%,50%,50%,50% or 50%;50%;50%;50%
                  
                   
	T, WINDOW,COMPONENT, DRAGTO, ToWINDOW,ToCOMPONENT,"50%,50%,50%,50%"
	Where first 50%,50% are COMPONENT or their subitem's X and Y location
	and second 50%,50% are ToCOMPONENT or their subitem's X and Y location.
		             
                    </pre>    Supporting Engines:
    <P/><UL>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param toWindow  Optional:NO 
                  ToWindow object.
                
     @param toComponent  Optional:NO 
		    ToComponent object.
		  
     @param offsets  Optional:YES 
		    Drag and release location of from-component and to-component. Offsets syntax will be "50%,50%,70%,70%, where first two percentages for from-component's X and Y location and second two are for to-component's X and Y location. If offsets isn't specify then center will be used."
		    Default value, both components center
		  
     @param fromSubItem  Optional:YES 
		    Text of from-component's sub item.
		  
     @param toSubItem  Optional:YES 
		    Text of to-component's sub item.
		  
     **********/
    public void dragTo(StepTestTable table, String toWindow, String toComponent, String offsets, String fromSubItem, String toSubItem ) {

        if ( table == null ) throw new IllegalArgumentException ( "dragTo.table = null");

        if ( toComponent == null ) throw new IllegalArgumentException ( "dragTo.toComponent = null");
        if ( toWindow == null ) throw new IllegalArgumentException ( "dragTo.toWindow = null");
        table.add( GenericObjectFunctions.dragTo(getWindow().getName(), getName(), toWindow, toComponent, offsets, fromSubItem, toSubItem));
    }

    /*********** <pre> 
                  A left mouse drag is performed from one object to another object based on the offsets values.
                
                  Drag will be performed from component (from-component) to another to-component. Offsets value are the drag object select location. The location (drag and release) calucate by X and Y percentage cordination. DragTo also supports sub item of component and  sub item of to-component.
                  
                   The coordination specify by offsets value. First two values are for from-component and another are for to-component.
                  
        Offsets can be 50%,50%,50%,50% or 50%;50%;50%;50%
                  
                   
	T, WINDOW,COMPONENT, DRAGTO, ToWINDOW,ToCOMPONENT,"50%,50%,50%,50%"
	Where first 50%,50% are COMPONENT or their subitem's X and Y location
	and second 50%,50% are ToCOMPONENT or their subitem's X and Y location.
		             
                    </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         toWindow -- Optional:NO 
                  ToWindow object.
                <BR/>         toComponent -- Optional:NO 
		    ToComponent object.
		  <BR/>         offsets -- Optional:YES 
		    Drag and release location of from-component and to-component. Offsets syntax will be "50%,50%,70%,70%, where first two percentages for from-component's X and Y location and second two are for to-component's X and Y location. If offsets isn't specify then center will be used."
		    Default value, both components center
		  <BR/>         fromSubItem -- Optional:YES 
		    Text of from-component's sub item.
		  <BR/>         toSubItem -- Optional:YES 
		    Text of to-component's sub item.
		  
    </UL>

     **********/
    public ComponentFunction dragTo(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "dragTo.parameters = null");
        return GenericObjectFunctions.dragTo(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                  A left mouse drag is performed from one object to another object based on the offsets values.
                
                  Drag will be performed from component (from-component) to another to-component. Offsets value are the drag object select location. The location (drag and release) calucate by X and Y percentage cordination. DragTo also supports sub item of component and  sub item of to-component.
                  
                   The coordination specify by offsets value. First two values are for from-component and another are for to-component.
                  
        Offsets can be 50%,50%,50%,50% or 50%;50%;50%;50%
                  
                   
	T, WINDOW,COMPONENT, DRAGTO, ToWINDOW,ToCOMPONENT,"50%,50%,50%,50%"
	Where first 50%,50% are COMPONENT or their subitem's X and Y location
	and second 50%,50% are ToCOMPONENT or their subitem's X and Y location.
		             
                    </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         toWindow -- Optional:NO 
                  ToWindow object.
                <BR/>         toComponent -- Optional:NO 
		    ToComponent object.
		  <BR/>         offsets -- Optional:YES 
		    Drag and release location of from-component and to-component. Offsets syntax will be "50%,50%,70%,70%, where first two percentages for from-component's X and Y location and second two are for to-component's X and Y location. If offsets isn't specify then center will be used."
		    Default value, both components center
		  <BR/>         fromSubItem -- Optional:YES 
		    Text of from-component's sub item.
		  <BR/>         toSubItem -- Optional:YES 
		    Text of to-component's sub item.
		  
    </UL>

     **********/
    public void dragTo(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "dragTo.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "dragTo.parameters = null");
        table.add( GenericObjectFunctions.dragTo(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                A user-defined flick or swipe on a touchscreen object.
              
                The user would use this command if they need to customize parameters like:
                
                Number of fingers used: default=1,
                Start and ending offsets within the object: defaults=90;50;10;50
                How long (in seconds) to complete the flick from start to end: default=1.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param appMapSubKey  Optional:YES  DefaultVal:90;50;10;50
                 Optional AppMap SubKey (or literal text) containing x1,y1,x2,y2 flick offsets within the object.
              
     @param duration  Optional:YES  DefaultVal:1
                 Optional number of seconds (0 to N) to press on the object.
              
     @param touches  Optional:YES  DefaultVal:1
                 Optional number of touches or fingers to use.
              
     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public ComponentFunction flick(String appMapSubKey, String duration, String touches, String repeat ) {

        return GenericObjectFunctions.flick(getWindow().getName(), getName(), appMapSubKey, duration, touches, repeat);
    }

    /*********** <pre> 
                A user-defined flick or swipe on a touchscreen object.
              
                The user would use this command if they need to customize parameters like:
                
                Number of fingers used: default=1,
                Start and ending offsets within the object: defaults=90;50;10;50
                How long (in seconds) to complete the flick from start to end: default=1.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubKey  Optional:YES  DefaultVal:90;50;10;50
                 Optional AppMap SubKey (or literal text) containing x1,y1,x2,y2 flick offsets within the object.
              
     @param duration  Optional:YES  DefaultVal:1
                 Optional number of seconds (0 to N) to press on the object.
              
     @param touches  Optional:YES  DefaultVal:1
                 Optional number of touches or fingers to use.
              
     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public void flick(StepTestTable table, String appMapSubKey, String duration, String touches, String repeat ) {

        if ( table == null ) throw new IllegalArgumentException ( "flick.table = null");

        table.add( GenericObjectFunctions.flick(getWindow().getName(), getName(), appMapSubKey, duration, touches, repeat));
    }

    /*********** <pre> 
                A user-defined flick or swipe on a touchscreen object.
              
                The user would use this command if they need to customize parameters like:
                
                Number of fingers used: default=1,
                Start and ending offsets within the object: defaults=90;50;10;50
                How long (in seconds) to complete the flick from start to end: default=1.
                
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubKey -- Optional:YES  DefaultVal:90;50;10;50
                 Optional AppMap SubKey (or literal text) containing x1,y1,x2,y2 flick offsets within the object.
              <BR/>         duration -- Optional:YES  DefaultVal:1
                 Optional number of seconds (0 to N) to press on the object.
              <BR/>         touches -- Optional:YES  DefaultVal:1
                 Optional number of touches or fingers to use.
              <BR/>         repeat -- Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
    </UL>

     **********/
    public ComponentFunction flick(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "flick.parameters = null");
        return GenericObjectFunctions.flick(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                A user-defined flick or swipe on a touchscreen object.
              
                The user would use this command if they need to customize parameters like:
                
                Number of fingers used: default=1,
                Start and ending offsets within the object: defaults=90;50;10;50
                How long (in seconds) to complete the flick from start to end: default=1.
                
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubKey -- Optional:YES  DefaultVal:90;50;10;50
                 Optional AppMap SubKey (or literal text) containing x1,y1,x2,y2 flick offsets within the object.
              <BR/>         duration -- Optional:YES  DefaultVal:1
                 Optional number of seconds (0 to N) to press on the object.
              <BR/>         touches -- Optional:YES  DefaultVal:1
                 Optional number of touches or fingers to use.
              <BR/>         repeat -- Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
    </UL>

     **********/
    public void flick(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "flick.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "flick.parameters = null");
        table.add( GenericObjectFunctions.flick(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                A flick or swipe on a touchscreen object from top-to-bottom.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public ComponentFunction flickDown(String repeat ) {

        return GenericObjectFunctions.flickDown(getWindow().getName(), getName(), repeat);
    }

    /*********** <pre> 
                A flick or swipe on a touchscreen object from top-to-bottom.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public void flickDown(StepTestTable table, String repeat ) {

        if ( table == null ) throw new IllegalArgumentException ( "flickDown.table = null");

        table.add( GenericObjectFunctions.flickDown(getWindow().getName(), getName(), repeat));
    }

    /*********** <pre> 
                A flick or swipe on a touchscreen object from right-to-left.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public ComponentFunction flickLeft(String repeat ) {

        return GenericObjectFunctions.flickLeft(getWindow().getName(), getName(), repeat);
    }

    /*********** <pre> 
                A flick or swipe on a touchscreen object from right-to-left.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public void flickLeft(StepTestTable table, String repeat ) {

        if ( table == null ) throw new IllegalArgumentException ( "flickLeft.table = null");

        table.add( GenericObjectFunctions.flickLeft(getWindow().getName(), getName(), repeat));
    }

    /*********** <pre> 
                A flick or swipe on a touchscreen object from left-to-right.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public ComponentFunction flickRight(String repeat ) {

        return GenericObjectFunctions.flickRight(getWindow().getName(), getName(), repeat);
    }

    /*********** <pre> 
                A flick or swipe on a touchscreen object from left-to-right.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public void flickRight(StepTestTable table, String repeat ) {

        if ( table == null ) throw new IllegalArgumentException ( "flickRight.table = null");

        table.add( GenericObjectFunctions.flickRight(getWindow().getName(), getName(), repeat));
    }

    /*********** <pre> 
                A flick or swipe on a touchscreen object from bottom-to-top.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public ComponentFunction flickUp(String repeat ) {

        return GenericObjectFunctions.flickUp(getWindow().getName(), getName(), repeat);
    }

    /*********** <pre> 
                A flick or swipe on a touchscreen object from bottom-to-top.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param repeat  Optional:YES  DefaultVal:1
                 Optional number of times to repeat the operation.
              
     **********/
    public void flickUp(StepTestTable table, String repeat ) {

        if ( table == null ) throw new IllegalArgumentException ( "flickUp.table = null");

        table.add( GenericObjectFunctions.flickUp(getWindow().getName(), getName(), repeat));
    }

    /*********** <pre> 
                 Attempts to perform an HScrollTo on an object.
               
                Attempts to perform an HScrollTo on an object. The input record
                specifies the absolute position to scroll to.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>AutomatedQA TestComplete</LI>
    </UL>

     @param pOSITION  Optional:NO 
                 Integer value that specifies the absolute position to scroll to.
              
     **********/
    public ComponentFunction hScrollTo(String pOSITION ) {

        if ( pOSITION == null ) throw new IllegalArgumentException ( "hScrollTo.pOSITION = null");
        return GenericObjectFunctions.hScrollTo(getWindow().getName(), getName(), pOSITION);
    }

    /*********** <pre> 
                 Attempts to perform an HScrollTo on an object.
               
                Attempts to perform an HScrollTo on an object. The input record
                specifies the absolute position to scroll to.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>AutomatedQA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param pOSITION  Optional:NO 
                 Integer value that specifies the absolute position to scroll to.
              
     **********/
    public void hScrollTo(StepTestTable table, String pOSITION ) {

        if ( table == null ) throw new IllegalArgumentException ( "hScrollTo.table = null");

        if ( pOSITION == null ) throw new IllegalArgumentException ( "hScrollTo.pOSITION = null");
        table.add( GenericObjectFunctions.hScrollTo(getWindow().getName(), getName(), pOSITION));
    }

    /*********** <pre> 
                Select a JAVA Menu Item according to a stored text value.
               
                Select a JAVA Menu Item according to a stored text value.
                Until JavaMenu objects are routed elsewhere, we will handle  
                the menu selection here. 
                Each menuItem acted upon is given a name in the AppMap under 
                the name provided for the Menu.
                
                The menuitem lookup is done with the component\menu name of 
                the record AND Field #5.
                
                Typical Data Table records:
                
                    t JavaWindow MainMenu JavaMenuSelect FileOpen
                
                The example will contain a FileOpen="Path=File->Open" entry in 
                the MainMenu section of the Application Map to select File->Open 
                menuItem from the menu of the MainWindow.
                
                MainMenu will also be an entry in the MainWindow section with 
                normal recognition information for it.  This will tell Robot to 
                locate the MainMenu Generic Object prior to the menu selection.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param javaMenuItem  Optional:NO 
                Name of the Java menuitem to lookup and use for the selection.
              
     **********/
    public ComponentFunction javaMenuSelect(String javaMenuItem ) {

        if ( javaMenuItem == null ) throw new IllegalArgumentException ( "javaMenuSelect.javaMenuItem = null");
        return GenericObjectFunctions.javaMenuSelect(getWindow().getName(), getName(), javaMenuItem);
    }

    /*********** <pre> 
                Select a JAVA Menu Item according to a stored text value.
               
                Select a JAVA Menu Item according to a stored text value.
                Until JavaMenu objects are routed elsewhere, we will handle  
                the menu selection here. 
                Each menuItem acted upon is given a name in the AppMap under 
                the name provided for the Menu.
                
                The menuitem lookup is done with the component\menu name of 
                the record AND Field #5.
                
                Typical Data Table records:
                
                    t JavaWindow MainMenu JavaMenuSelect FileOpen
                
                The example will contain a FileOpen="Path=File->Open" entry in 
                the MainMenu section of the Application Map to select File->Open 
                menuItem from the menu of the MainWindow.
                
                MainMenu will also be an entry in the MainWindow section with 
                normal recognition information for it.  This will tell Robot to 
                locate the MainMenu Generic Object prior to the menu selection.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param javaMenuItem  Optional:NO 
                Name of the Java menuitem to lookup and use for the selection.
              
     **********/
    public void javaMenuSelect(StepTestTable table, String javaMenuItem ) {

        if ( table == null ) throw new IllegalArgumentException ( "javaMenuSelect.table = null");

        if ( javaMenuItem == null ) throw new IllegalArgumentException ( "javaMenuSelect.javaMenuItem = null");
        table.add( GenericObjectFunctions.javaMenuSelect(getWindow().getName(), getName(), javaMenuItem));
    }

    /*********** <pre> 
                A left mouse drag is performed on the object based on the stored coordinates.
               
                For components that are unrecognized, we can make a mouse drag in these 
                to draw fields(rectangles) or do drag and drop, based on stored x,y start 
                and end coordinates. The object containing the starting coordinates is first 
                given context and then a left mouse drag is performed with the stored coordinates.
                 
                The coordinate lookup is done with the component name(Field #3) of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow GenericItem LeftDrag DragName
                
                #1 above will contain a GenericItem entry in the MainWindow section with 
                normal recognition information for it .  GenericItem will also have it's
                own section in the Application Map in which there will be an entry like:
                
                DragName="15,30,60,90"    OR
                DragName="Coords=15,30,60,90"
                
                
                This will tell Robot to locate the GenericItem Window object and left drag 
                from coordinates 15,30 to 60,90.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup or literal text to use for the left mouse drag.
              
     **********/
    public ComponentFunction leftDrag(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "leftDrag.appMapSubkey = null");
        return GenericObjectFunctions.leftDrag(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                A left mouse drag is performed on the object based on the stored coordinates.
               
                For components that are unrecognized, we can make a mouse drag in these 
                to draw fields(rectangles) or do drag and drop, based on stored x,y start 
                and end coordinates. The object containing the starting coordinates is first 
                given context and then a left mouse drag is performed with the stored coordinates.
                 
                The coordinate lookup is done with the component name(Field #3) of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow GenericItem LeftDrag DragName
                
                #1 above will contain a GenericItem entry in the MainWindow section with 
                normal recognition information for it .  GenericItem will also have it's
                own section in the Application Map in which there will be an entry like:
                
                DragName="15,30,60,90"    OR
                DragName="Coords=15,30,60,90"
                
                
                This will tell Robot to locate the GenericItem Window object and left drag 
                from coordinates 15,30 to 60,90.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup or literal text to use for the left mouse drag.
              
     **********/
    public void leftDrag(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "leftDrag.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "leftDrag.appMapSubkey = null");
        table.add( GenericObjectFunctions.leftDrag(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                A single click on an object by mouse event. It uses low level mouse event to click on an object.
              
                
                By default, mouse click on the center of the component.
                We can also mouse click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                The object to be mouse clicked is first given context and then a mouse click is 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow  MouseClick
                (2) t MainWindow MainWindow  MouseClick AnObject
                (3) t MainWindow FolderTree  MouseClick Node1
                (4) t MainWindow MainWindow  MouseClick "50,200"
                (5) t MainWindow MainWindow  MouseClick "Coords=50,200"
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to mouse click at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and mouse click at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to mouse click relative to the item.
                
                Rational Robot no longer requires the AppMapSubKey be provided and will 
                attempt to use the string as literal text if no AppMapSubKey is found in 
                the current App Map.  Robot also no longer assumes the AppMapSubKey value 
                or the literal value is presenting coordinate information.  This allows 
                components that can accept parameters other than coordinates, like table 
                row/col values or ImageMap areas to be specified.
                
                If the value is deduced to contain coordinates, but is not prefixed with 
                "Coords=" text, then Robot will add the prefix.  Otherwise, the text value 
                will remain unmodified.
                
		This is the direction we expect all tools to follow going forward.
		
		Engines should also attempt to support coordinates separated by alternate separators.  
		The most common separators that should be supported would be:
		
		"," (comma) Example: "50,200"
		";" (semi-colon) Example: "50;200"
		" " (space) Example: "50 200"
			
			
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the click.
              
     **********/
    public ComponentFunction mouseClick(String appMapSubkey ) {

        return GenericObjectFunctions.mouseClick(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                A single click on an object by mouse event. It uses low level mouse event to click on an object.
              
                
                By default, mouse click on the center of the component.
                We can also mouse click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                The object to be mouse clicked is first given context and then a mouse click is 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow  MouseClick
                (2) t MainWindow MainWindow  MouseClick AnObject
                (3) t MainWindow FolderTree  MouseClick Node1
                (4) t MainWindow MainWindow  MouseClick "50,200"
                (5) t MainWindow MainWindow  MouseClick "Coords=50,200"
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to mouse click at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and mouse click at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to mouse click relative to the item.
                
                Rational Robot no longer requires the AppMapSubKey be provided and will 
                attempt to use the string as literal text if no AppMapSubKey is found in 
                the current App Map.  Robot also no longer assumes the AppMapSubKey value 
                or the literal value is presenting coordinate information.  This allows 
                components that can accept parameters other than coordinates, like table 
                row/col values or ImageMap areas to be specified.
                
                If the value is deduced to contain coordinates, but is not prefixed with 
                "Coords=" text, then Robot will add the prefix.  Otherwise, the text value 
                will remain unmodified.
                
		This is the direction we expect all tools to follow going forward.
		
		Engines should also attempt to support coordinates separated by alternate separators.  
		The most common separators that should be supported would be:
		
		"," (comma) Example: "50,200"
		";" (semi-colon) Example: "50;200"
		" " (space) Example: "50 200"
			
			
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the click.
              
     **********/
    public void mouseClick(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "mouseClick.table = null");

        table.add( GenericObjectFunctions.mouseClick(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                Multiple clicks on an object.
              
                
                By default, clicks on the center of the component 3 times.
                Use the optional ClickCount parameter to specify the desired number of clicks.
                We can also click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                The object to be clicked is first given context and then the clicks are 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The optional coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records with relative references:
                
                (1) t MainWindow MainWindow  MultiClick 
                (2) t MainWindow MainWindow  MultiClick AnObject
                (3) t MainWindow FolderTree  MultiClick Node1  "4"
                (4) t MainWindow MainWindow  MultiClick "50,200" "3"
                (5) t MainWindow MainWindow  MultiClick "Coords=50,200" "2"
                
                #1 above should click 3 times (default) at the center (default) of the MainWindow.
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click 3 times (default) at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell the runtime to locate the FolderTree Generic 
                object and click 3 times (default) at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to click relative to the item.  The item will be clicked 3 times and 2 times, 
                respectively
                
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the clicks.
              
     @param clickCount  Optional:YES  DefaultVal:3
                 Optional number of times (1 to N) to click the item.
              
     **********/
    public ComponentFunction multiClick(String appMapSubkey, String clickCount ) {

        return GenericObjectFunctions.multiClick(getWindow().getName(), getName(), appMapSubkey, clickCount);
    }

    /*********** <pre> 
                Multiple clicks on an object.
              
                
                By default, clicks on the center of the component 3 times.
                Use the optional ClickCount parameter to specify the desired number of clicks.
                We can also click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                The object to be clicked is first given context and then the clicks are 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The optional coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records with relative references:
                
                (1) t MainWindow MainWindow  MultiClick 
                (2) t MainWindow MainWindow  MultiClick AnObject
                (3) t MainWindow FolderTree  MultiClick Node1  "4"
                (4) t MainWindow MainWindow  MultiClick "50,200" "3"
                (5) t MainWindow MainWindow  MultiClick "Coords=50,200" "2"
                
                #1 above should click 3 times (default) at the center (default) of the MainWindow.
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click 3 times (default) at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell the runtime to locate the FolderTree Generic 
                object and click 3 times (default) at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to click relative to the item.  The item will be clicked 3 times and 2 times, 
                respectively
                
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the clicks.
              
     @param clickCount  Optional:YES  DefaultVal:3
                 Optional number of times (1 to N) to click the item.
              
     **********/
    public void multiClick(StepTestTable table, String appMapSubkey, String clickCount ) {

        if ( table == null ) throw new IllegalArgumentException ( "multiClick.table = null");

        table.add( GenericObjectFunctions.multiClick(getWindow().getName(), getName(), appMapSubkey, clickCount));
    }

    /*********** <pre> 
                Multiple clicks on an object.
              
                
                By default, clicks on the center of the component 3 times.
                Use the optional ClickCount parameter to specify the desired number of clicks.
                We can also click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                The object to be clicked is first given context and then the clicks are 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The optional coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records with relative references:
                
                (1) t MainWindow MainWindow  MultiClick 
                (2) t MainWindow MainWindow  MultiClick AnObject
                (3) t MainWindow FolderTree  MultiClick Node1  "4"
                (4) t MainWindow MainWindow  MultiClick "50,200" "3"
                (5) t MainWindow MainWindow  MultiClick "Coords=50,200" "2"
                
                #1 above should click 3 times (default) at the center (default) of the MainWindow.
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click 3 times (default) at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell the runtime to locate the FolderTree Generic 
                object and click 3 times (default) at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to click relative to the item.  The item will be clicked 3 times and 2 times, 
                respectively
                
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the clicks.
              <BR/>         clickCount -- Optional:YES  DefaultVal:3
                 Optional number of times (1 to N) to click the item.
              
    </UL>

     **********/
    public ComponentFunction multiClick(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "multiClick.parameters = null");
        return GenericObjectFunctions.multiClick(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                Multiple clicks on an object.
              
                
                By default, clicks on the center of the component 3 times.
                Use the optional ClickCount parameter to specify the desired number of clicks.
                We can also click on any part of an object, or any point relative to an object 
                based on a provided x,y coordinate or other component-specific parameters.  
                
                The object to be clicked is first given context and then the clicks are 
                generated at the coordinates.  Thus, a subitem or object can be 
                referenced by name even though it is only recognized via coordinates.
                
                The optional coordinate lookup is done with the component name of the record AND 
                Field #5 or by providing the literal text of the coordinates, where supported.
                
                Typical Data Table records with relative references:
                
                (1) t MainWindow MainWindow  MultiClick 
                (2) t MainWindow MainWindow  MultiClick AnObject
                (3) t MainWindow FolderTree  MultiClick Node1  "4"
                (4) t MainWindow MainWindow  MultiClick "50,200" "3"
                (5) t MainWindow MainWindow  MultiClick "Coords=50,200" "2"
                
                #1 above should click 3 times (default) at the center (default) of the MainWindow.
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to click 3 times (default) at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell the runtime to locate the FolderTree Generic 
                object and click 3 times (default) at the coordinates specified by the reference.
                
                #4 and #5 above show using literal text instead of an App Map entry to specify 
                where to click relative to the item.  The item will be clicked 3 times and 2 times, 
                respectively
                
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the clicks.
              <BR/>         clickCount -- Optional:YES  DefaultVal:3
                 Optional number of times (1 to N) to click the item.
              
    </UL>

     **********/
    public void multiClick(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "multiClick.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "multiClick.parameters = null");
        table.add( GenericObjectFunctions.multiClick(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Same as MULTICLICK.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the clicks.
              
     @param clickCount  Optional:YES  DefaultVal:3
                 Optional number of times (1 to N) to click the item.
              
     **********/
    public ComponentFunction multiClickScreenImage(String appMapSubkey, String clickCount ) {

        return GenericObjectFunctions.multiClickScreenImage(getWindow().getName(), getName(), appMapSubkey, clickCount);
    }

    /*********** <pre> 
                Same as MULTICLICK.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the clicks.
              
     @param clickCount  Optional:YES  DefaultVal:3
                 Optional number of times (1 to N) to click the item.
              
     **********/
    public void multiClickScreenImage(StepTestTable table, String appMapSubkey, String clickCount ) {

        if ( table == null ) throw new IllegalArgumentException ( "multiClickScreenImage.table = null");

        table.add( GenericObjectFunctions.multiClickScreenImage(getWindow().getName(), getName(), appMapSubkey, clickCount));
    }

    /*********** <pre> 
                Same as MULTICLICK.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the clicks.
              <BR/>         clickCount -- Optional:YES  DefaultVal:3
                 Optional number of times (1 to N) to click the item.
              
    </UL>

     **********/
    public ComponentFunction multiClickScreenImage(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "multiClickScreenImage.parameters = null");
        return GenericObjectFunctions.multiClickScreenImage(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                Same as MULTICLICK.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional)Name of the AppMap subkey to lookup or the literal text to use for the clicks.
              <BR/>         clickCount -- Optional:YES  DefaultVal:3
                 Optional number of times (1 to N) to click the item.
              
    </UL>

     **********/
    public void multiClickScreenImage(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "multiClickScreenImage.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "multiClickScreenImage.parameters = null");
        table.add( GenericObjectFunctions.multiClickScreenImage(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Press a touchscreen object for a number of seconds--0 seconds by default.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    </UL>

     @param duration  Optional:YES  DefaultVal:0
                 Optional number of seconds (0 to N) to press on the object.
              
     **********/
    public ComponentFunction press(String duration ) {

        return GenericObjectFunctions.press(getWindow().getName(), getName(), duration);
    }

    /*********** <pre> 
                Press a touchscreen object for a number of seconds--0 seconds by default.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param duration  Optional:YES  DefaultVal:0
                 Optional number of seconds (0 to N) to press on the object.
              
     **********/
    public void press(StepTestTable table, String duration ) {

        if ( table == null ) throw new IllegalArgumentException ( "press.table = null");

        table.add( GenericObjectFunctions.press(getWindow().getName(), getName(), duration));
    }

    /*********** <pre> 
                A right click on an object.
               
                By default we should click on the center of the object.
                We can also right click on any part of an object based on a stored x,y 
                coordinate.  The object containing the coordinate is first given 
                context and then a right click is generated at the coordinate.  Thus, an item 
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                 
                (1) t MainWindow MainWindow RightClick 
                (2) t MainWindow MainWindow RightClick AnObject
                (3) t MainWindow  ToolItem  RightClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to right click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with 
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like 
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window 
                object and right click at the coordinates specified by the reference.
		
		Engines should also attempt to support coordinates separated by alternate separators.  
		The most common separators that should be supported would be:
		
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
		
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Optional) Name of the AppMap subkey to lookup or the literal text to use for the right click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public ComponentFunction rightClick(String appMapSubkey, String autoScroll ) {

        return GenericObjectFunctions.rightClick(getWindow().getName(), getName(), appMapSubkey, autoScroll);
    }

    /*********** <pre> 
                A right click on an object.
               
                By default we should click on the center of the object.
                We can also right click on any part of an object based on a stored x,y 
                coordinate.  The object containing the coordinate is first given 
                context and then a right click is generated at the coordinate.  Thus, an item 
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                 
                (1) t MainWindow MainWindow RightClick 
                (2) t MainWindow MainWindow RightClick AnObject
                (3) t MainWindow  ToolItem  RightClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to right click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with 
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like 
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window 
                object and right click at the coordinates specified by the reference.
		
		Engines should also attempt to support coordinates separated by alternate separators.  
		The most common separators that should be supported would be:
		
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
		
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Optional) Name of the AppMap subkey to lookup or the literal text to use for the right click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public void rightClick(StepTestTable table, String appMapSubkey, String autoScroll ) {

        if ( table == null ) throw new IllegalArgumentException ( "rightClick.table = null");

        table.add( GenericObjectFunctions.rightClick(getWindow().getName(), getName(), appMapSubkey, autoScroll));
    }

    /*********** <pre> 
                A right click on an object.
               
                By default we should click on the center of the object.
                We can also right click on any part of an object based on a stored x,y 
                coordinate.  The object containing the coordinate is first given 
                context and then a right click is generated at the coordinate.  Thus, an item 
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                 
                (1) t MainWindow MainWindow RightClick 
                (2) t MainWindow MainWindow RightClick AnObject
                (3) t MainWindow  ToolItem  RightClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to right click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with 
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like 
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window 
                object and right click at the coordinates specified by the reference.
		
		Engines should also attempt to support coordinates separated by alternate separators.  
		The most common separators that should be supported would be:
		
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
		
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional) Name of the AppMap subkey to lookup or the literal text to use for the right click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public ComponentFunction rightClick(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "rightClick.parameters = null");
        return GenericObjectFunctions.rightClick(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                A right click on an object.
               
                By default we should click on the center of the object.
                We can also right click on any part of an object based on a stored x,y 
                coordinate.  The object containing the coordinate is first given 
                context and then a right click is generated at the coordinate.  Thus, an item 
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                 
                (1) t MainWindow MainWindow RightClick 
                (2) t MainWindow MainWindow RightClick AnObject
                (3) t MainWindow  ToolItem  RightClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to right click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with 
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like 
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window 
                object and right click at the coordinates specified by the reference.
		
		Engines should also attempt to support coordinates separated by alternate separators.  
		The most common separators that should be supported would be:
		
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
		
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional) Name of the AppMap subkey to lookup or the literal text to use for the right click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public void rightClick(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "rightClick.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "rightClick.parameters = null");
        table.add( GenericObjectFunctions.rightClick(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Same as RightClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey or literal text as documented in the CLICK command.
              
     **********/
    public ComponentFunction rightClickScreenImage(String appMapSubKey ) {

        return GenericObjectFunctions.rightClickScreenImage(getWindow().getName(), getName(), appMapSubKey);
    }

    /*********** <pre> 
                Same as RightClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey or literal text as documented in the CLICK command.
              
     **********/
    public void rightClickScreenImage(StepTestTable table, String appMapSubKey ) {

        if ( table == null ) throw new IllegalArgumentException ( "rightClickScreenImage.table = null");

        table.add( GenericObjectFunctions.rightClickScreenImage(getWindow().getName(), getName(), appMapSubKey));
    }

    /*********** <pre> 
                RightClick a specified screen location.
              
                RightClick a specified screen location.
                We can click on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component RightClickScreenLocation
                (2) t MainWindow MainWindow RightClickScreenLocation AnObject
                (3) t MainWindow MainWindow RightClickScreenLocation 50,80
                (4) t AnyWin AnyComp RightClickScreenLocation Node1
                
                #1 above will contain a blank as it's 5th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinates for the click.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the click will occur with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the click will occur with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates for the click.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to locate in the AppMap.
              
     **********/
    public ComponentFunction rightClickScreenLocation(String appMapSubkey ) {

        return GenericObjectFunctions.rightClickScreenLocation(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                RightClick a specified screen location.
              
                RightClick a specified screen location.
                We can click on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component RightClickScreenLocation
                (2) t MainWindow MainWindow RightClickScreenLocation AnObject
                (3) t MainWindow MainWindow RightClickScreenLocation 50,80
                (4) t AnyWin AnyComp RightClickScreenLocation Node1
                
                #1 above will contain a blank as it's 5th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinates for the click.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the click will occur with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the click will occur with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the click will occur at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates for the click.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to locate in the AppMap.
              
     **********/
    public void rightClickScreenLocation(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "rightClickScreenLocation.table = null");

        table.add( GenericObjectFunctions.rightClickScreenLocation(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                (Deprecated) RightClick a specified screen location.
              
                (Deprecated) RightClick a specified screen location. See RightClickScreenLocation 
                for the preferred method to click on screen coordinates.
                
                We can click on any screen location based on literal text x,y 
                coordinates retrieved from Field #5.  Window and Component names and App Map entries are 
                completely ignored.  So the user can put anything in those fields that might help test readability.  
                
                It is not recommended to hardcode screen coordinates in the test table in this way.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param coords  Optional:NO 
                The hardcoded X,Y screen coordinates--or the result of an expression--that provides the 
                absolute screen coordinates to click.
              
     **********/
    public ComponentFunction rightClickScreenPoint(String coords ) {

        if ( coords == null ) throw new IllegalArgumentException ( "rightClickScreenPoint.coords = null");
        return GenericObjectFunctions.rightClickScreenPoint(getWindow().getName(), getName(), coords);
    }

    /*********** <pre> 
                (Deprecated) RightClick a specified screen location.
              
                (Deprecated) RightClick a specified screen location. See RightClickScreenLocation 
                for the preferred method to click on screen coordinates.
                
                We can click on any screen location based on literal text x,y 
                coordinates retrieved from Field #5.  Window and Component names and App Map entries are 
                completely ignored.  So the user can put anything in those fields that might help test readability.  
                
                It is not recommended to hardcode screen coordinates in the test table in this way.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param coords  Optional:NO 
                The hardcoded X,Y screen coordinates--or the result of an expression--that provides the 
                absolute screen coordinates to click.
              
     **********/
    public void rightClickScreenPoint(StepTestTable table, String coords ) {

        if ( table == null ) throw new IllegalArgumentException ( "rightClickScreenPoint.table = null");

        if ( coords == null ) throw new IllegalArgumentException ( "rightClickScreenPoint.coords = null");
        table.add( GenericObjectFunctions.rightClickScreenPoint(getWindow().getName(), getName(), coords));
    }

    /*********** <pre> 
                A right mouse drag is performed on the object based on the stored coordinates.
               
                For components that are unrecognized, we can make a mouse drag in these 
                to draw fields(rectangles) or do drag and drop, based on stored x,y start 
                and end coordinates. The object containing the starting coordinates is first 
                given context and then a right mouse drag is performed with the stored coordinates.
                
                The coordinate lookup is done with the component name(Field #3) of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow GenericItem RightDrag DragName
                
                #1 above will contain a GenericItem entry in the MainWindow section with 
                normal recognition information for it .  GenericItem will also have it's
                own section in the Application Map in which there will be an entry like:
                
                DragName="15,30,60,90"    OR
                DragName="Coords=15,30,60,90"
                
                This will tell Robot to locate the GenericItem Window object and right drag 
                from coordinates 15,30 to 60,90.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup or literal text to use for the right mouse drag.
              
     **********/
    public ComponentFunction rightDrag(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "rightDrag.appMapSubkey = null");
        return GenericObjectFunctions.rightDrag(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                A right mouse drag is performed on the object based on the stored coordinates.
               
                For components that are unrecognized, we can make a mouse drag in these 
                to draw fields(rectangles) or do drag and drop, based on stored x,y start 
                and end coordinates. The object containing the starting coordinates is first 
                given context and then a right mouse drag is performed with the stored coordinates.
                
                The coordinate lookup is done with the component name(Field #3) of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow GenericItem RightDrag DragName
                
                #1 above will contain a GenericItem entry in the MainWindow section with 
                normal recognition information for it .  GenericItem will also have it's
                own section in the Application Map in which there will be an entry like:
                
                DragName="15,30,60,90"    OR
                DragName="Coords=15,30,60,90"
                
                This will tell Robot to locate the GenericItem Window object and right drag 
                from coordinates 15,30 to 60,90.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                Name of the AppMap subkey to lookup or literal text to use for the right mouse drag.
              
     **********/
    public void rightDrag(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "rightDrag.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "rightDrag.appMapSubkey = null");
        table.add( GenericObjectFunctions.rightDrag(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre>
                A SHIFT click on an object.
              
                By default we should click on the center of the object.
                We can SHIFT click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a SHIFT click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow ShiftClick 
                (2) t MainWindow MainWindow ShiftClick AnObject
                (3) t MainWindow  ToolItem  ShiftClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to SHIFT click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and SHIFT click at the coordinates specified by the reference.
				
				Engines should also attempt to support coordinates separated by alternate separators.  
				The most common separators that should be supported would be:
				
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
				
				
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the SHIFT click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public ComponentFunction shiftClick(String appMapSubkey, String autoScroll ) {

        return GenericObjectFunctions.shiftClick(getWindow().getName(), getName(), appMapSubkey, autoScroll);
    }

    /*********** <pre>
                A SHIFT click on an object.
              
                By default we should click on the center of the object.
                We can SHIFT click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a SHIFT click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow ShiftClick 
                (2) t MainWindow MainWindow ShiftClick AnObject
                (3) t MainWindow  ToolItem  ShiftClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to SHIFT click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and SHIFT click at the coordinates specified by the reference.
				
				Engines should also attempt to support coordinates separated by alternate separators.  
				The most common separators that should be supported would be:
				
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
				
				
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the SHIFT click.
              
     @param autoScroll  Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
     **********/
    public void shiftClick(StepTestTable table, String appMapSubkey, String autoScroll ) {

        if ( table == null ) throw new IllegalArgumentException ( "shiftClick.table = null");

        table.add( GenericObjectFunctions.shiftClick(getWindow().getName(), getName(), appMapSubkey, autoScroll));
    }

    /*********** <pre>
                A SHIFT click on an object.
              
                By default we should click on the center of the object.
                We can SHIFT click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a SHIFT click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow ShiftClick 
                (2) t MainWindow MainWindow ShiftClick AnObject
                (3) t MainWindow  ToolItem  ShiftClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to SHIFT click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and SHIFT click at the coordinates specified by the reference.
				
				Engines should also attempt to support coordinates separated by alternate separators.  
				The most common separators that should be supported would be:
				
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
				
				
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the SHIFT click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public ComponentFunction shiftClick(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "shiftClick.parameters = null");
        return GenericObjectFunctions.shiftClick(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
                A SHIFT click on an object.
              
                By default we should click on the center of the object.
                We can SHIFT click on any part of an object based on a stored x,y
                coordinate.  The object containing the coordinate is first given
                context and then a SHIFT click is generated at the coordinate.  Thus, an item
                or object can be referenced by name even though it is only recognized
                via coordinates.
                
                The coordinate lookup is done with the component name of the record AND
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow MainWindow ShiftClick 
                (2) t MainWindow MainWindow ShiftClick AnObject
                (3) t MainWindow  ToolItem  ShiftClick PrintTool
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section
                of the Application Map to SHIFT click at x=3, y=10 in the MainWindow. For SE+, the 
                coordinate can be percentage format, like "20%,30%". This percentage format indicates 
                the point (20% width of component, 30% height of component) relative to the object.
                
                #3 above will contain a ToolItem entry in the MainWindow section with
                normal recognition information for it .  ToolItem will also have it's
                own section in the Application Map in which there will be an entry like
                PrintTool="15,30".  This will tell Robot to locate the PrintTool Window
                object and SHIFT click at the coordinates specified by the reference.
				
				Engines should also attempt to support coordinates separated by alternate separators.  
				The most common separators that should be supported would be:
				
				"," (comma) Example: "50,200"
				";" (semi-colon) Example: "50;200"
				" " (space) Example: "50 200"
				
				
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES
                (Optional) Name of the AppMap subkey to lookup and use for the SHIFT click.
              <BR/>         autoScroll -- Optional:YES 
                (Optional) True|False. If the component will be scrolled into view automatically before clicking. The default value is true.
              
    </UL>

     **********/
    public void shiftClick(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "shiftClick.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "shiftClick.parameters = null");
        table.add( GenericObjectFunctions.shiftClick(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Same as ShiftClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey type of use as documented in the CLICK command.
              
     **********/
    public ComponentFunction shiftClickScreenImage(String appMapSubKey ) {

        return GenericObjectFunctions.shiftClickScreenImage(getWindow().getName(), getName(), appMapSubKey);
    }

    /*********** <pre> 
                Same as ShiftClick.
              
                The keyword is simply provided as a means to differentiate 
                Object-Based Testing from Image-Based Testing in your tests. 
                However, this differentiation is not required.
		
		Note: the TID supports this command using 
		Image-Based Testing 
		techniques and App Map entries as well as literal text coordinates.
		
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubKey  Optional:YES 
                (Optional) AppMapSubKey type of use as documented in the CLICK command.
              
     **********/
    public void shiftClickScreenImage(StepTestTable table, String appMapSubKey ) {

        if ( table == null ) throw new IllegalArgumentException ( "shiftClickScreenImage.table = null");

        table.add( GenericObjectFunctions.shiftClickScreenImage(getWindow().getName(), getName(), appMapSubKey));
    }

    /*********** <pre> 
                A SHIFT left mouse drag is performed on the object based on the stored coordinates.
               
                
                The coordinate lookup is done with the component name(Field #3) of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow GenericItem ShiftLeftDrag DragName
                
                #1 above will contain a GenericItem entry in the MainWindow section with 
                normal recognition information for it .  GenericItem will also have it's
                own section in the Application Map in which there will be an entry like:
                
                DragName="15,30,60,90"    OR
                DragName="Coords=15,30,60,90"
                
                This will tell RFT to locate the GenericItem Window object and SHIFT left drag 
                from coordinates 15,30 to 60,90.
  	              </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for the SHIFT left mouse drag.
              
     **********/
    public ComponentFunction shiftLeftDrag(String appMapSubkey ) {

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "shiftLeftDrag.appMapSubkey = null");
        return GenericObjectFunctions.shiftLeftDrag(getWindow().getName(), getName(), appMapSubkey);
    }

    /*********** <pre> 
                A SHIFT left mouse drag is performed on the object based on the stored coordinates.
               
                
                The coordinate lookup is done with the component name(Field #3) of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow GenericItem ShiftLeftDrag DragName
                
                #1 above will contain a GenericItem entry in the MainWindow section with 
                normal recognition information for it .  GenericItem will also have it's
                own section in the Application Map in which there will be an entry like:
                
                DragName="15,30,60,90"    OR
                DragName="Coords=15,30,60,90"
                
                This will tell RFT to locate the GenericItem Window object and SHIFT left drag 
                from coordinates 15,30 to 60,90.
  	              </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:NO 
                  Name of the AppMap subkey to lookup or literal text to use for the SHIFT left mouse drag.
              
     **********/
    public void shiftLeftDrag(StepTestTable table, String appMapSubkey ) {

        if ( table == null ) throw new IllegalArgumentException ( "shiftLeftDrag.table = null");

        if ( appMapSubkey == null ) throw new IllegalArgumentException ( "shiftLeftDrag.appMapSubkey = null");
        table.add( GenericObjectFunctions.shiftLeftDrag(getWindow().getName(), getName(), appMapSubkey));
    }

    /*********** <pre> 
                A single Tap on a touchscreen object.  Use keyword "Click" syntax and parameters.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    </UL>

     **********/
    public ComponentFunction tap( ) {
        return GenericObjectFunctions.tap(getWindow().getName(), getName());
    }

    /*********** <pre> 
                A single Tap on a touchscreen object.  Use keyword "Click" syntax and parameters.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void tap(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "tap.table = null");
        table.add( GenericObjectFunctions.tap(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                A two-finger tap on a touchscreen object.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     **********/
    public ComponentFunction twoFingerTap( ) {
        return GenericObjectFunctions.twoFingerTap(getWindow().getName(), getName());
    }

    /*********** <pre> 
                A two-finger tap on a touchscreen object.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void twoFingerTap(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "twoFingerTap.table = null");
        table.add( GenericObjectFunctions.twoFingerTap(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                 Performs a GenericObjectVP CompareImage OR a RegionImageVP on an object.
               
                Performs a GenericObjectVP CompareImage OR a RegionImageVP on an object.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                A RegionImageVP can be accomplished by having the name of the VP as an item 
                under the component in the application map.  The item's value must be 
                the coordinate values required by the RegionImageVP (i.e. "65,100,200,250").
                
                Example 1: Perform a GenericObjectVP CompareImage
                
                MainWindow SomeGenericObject VerifyImage StoredVP
                
                (no StoredVP item found in the app map under SomeGenericObject)
                
                The named VP (StoredVP) must not exist in the application map.  The 
                entire panel/object of SomeGenericObject will be captured and compared 
                against the StoredVP baseline which must already exist as an asset of the
                currently running script.
                 
                Example 2: Perform a RegionImageVP on a particular area of the screen
                
                MainWindow SomeGenericObject VerifyImage StoredVP
                
                (StoredVP found as:
                
                "65,100,200,250"   OR
                "Coords=65,100,200,250"
                 
                in the SomeGenericObject section of the app map)
                 
                The named VP (StoredVP) is found to exist in the application map as a
                subitem in the SomeGenericObject section of the map.  This causes 
                the routine to attempt a RegionImageVP using the map's value of the StoredVP 
                item as the coordinates for the region to capture.  StoredVP is ALSO the 
                name of the VP which must already exist as an asset of the currently 
                running script.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    </UL>

     @param vPAsset  Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              
     **********/
    public ComponentFunction verifyImage(String vPAsset ) {

        if ( vPAsset == null ) throw new IllegalArgumentException ( "verifyImage.vPAsset = null");
        return GenericObjectFunctions.verifyImage(getWindow().getName(), getName(), vPAsset);
    }

    /*********** <pre> 
                 Performs a GenericObjectVP CompareImage OR a RegionImageVP on an object.
               
                Performs a GenericObjectVP CompareImage OR a RegionImageVP on an object.  
                The benchmark VP must already exist and be an asset of the currently 
                running script.
                
                A RegionImageVP can be accomplished by having the name of the VP as an item 
                under the component in the application map.  The item's value must be 
                the coordinate values required by the RegionImageVP (i.e. "65,100,200,250").
                
                Example 1: Perform a GenericObjectVP CompareImage
                
                MainWindow SomeGenericObject VerifyImage StoredVP
                
                (no StoredVP item found in the app map under SomeGenericObject)
                
                The named VP (StoredVP) must not exist in the application map.  The 
                entire panel/object of SomeGenericObject will be captured and compared 
                against the StoredVP baseline which must already exist as an asset of the
                currently running script.
                 
                Example 2: Perform a RegionImageVP on a particular area of the screen
                
                MainWindow SomeGenericObject VerifyImage StoredVP
                
                (StoredVP found as:
                
                "65,100,200,250"   OR
                "Coords=65,100,200,250"
                 
                in the SomeGenericObject section of the app map)
                 
                The named VP (StoredVP) is found to exist in the application map as a
                subitem in the SomeGenericObject section of the map.  This causes 
                the routine to attempt a RegionImageVP using the map's value of the StoredVP 
                item as the coordinates for the region to capture.  StoredVP is ALSO the 
                name of the VP which must already exist as an asset of the currently 
                running script.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param vPAsset  Optional:NO 
                Name of the pre-existing VP asset stored in the currently running script.
              
     **********/
    public void verifyImage(StepTestTable table, String vPAsset ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyImage.table = null");

        if ( vPAsset == null ) throw new IllegalArgumentException ( "verifyImage.vPAsset = null");
        table.add( GenericObjectFunctions.verifyImage(getWindow().getName(), getName(), vPAsset));
    }

    /*********** <pre> 
                 Attempts to perform a VScrollTo on an object.
               
                Attempts to perform a VScrollTo on an object. The input record
                specifies the absolute position to scroll to.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>AutomatedQA TestComplete</LI>
    </UL>

     @param pOSITION  Optional:NO 
                 Integer value that specifies the absolute position to scroll to.
              
     **********/
    public ComponentFunction vScrollTo(String pOSITION ) {

        if ( pOSITION == null ) throw new IllegalArgumentException ( "vScrollTo.pOSITION = null");
        return GenericObjectFunctions.vScrollTo(getWindow().getName(), getName(), pOSITION);
    }

    /*********** <pre> 
                 Attempts to perform a VScrollTo on an object.
               
                Attempts to perform a VScrollTo on an object. The input record
                specifies the absolute position to scroll to.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>AutomatedQA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param pOSITION  Optional:NO 
                 Integer value that specifies the absolute position to scroll to.
              
     **********/
    public void vScrollTo(StepTestTable table, String pOSITION ) {

        if ( table == null ) throw new IllegalArgumentException ( "vScrollTo.table = null");

        if ( pOSITION == null ) throw new IllegalArgumentException ( "vScrollTo.pOSITION = null");
        table.add( GenericObjectFunctions.vScrollTo(getWindow().getName(), getName(), pOSITION));
    }

}
