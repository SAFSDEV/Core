
/******************************************************************************
 * GenericMaster.java
 *
 * Copyright (c) by SAS Institute Inc., Cary, NC 27513
 * General Public License: http://www.opensource.org/licenses/gpl-license.php
 *
 * !!! DO NOT EDIT THIS FILE !!!
 * This file is automatically generated from XML source.  Any changes you make 
 * here will be erased the next time the file is generated.
 *
 * The following assets are needed to generate this file:
 *
 *   GenericMasterFunctions.xml
 *   keyword_library.dtd
 *   XSLJavaCommonFunctions.xsl
 *   XSLJavaComponentModel.xsl
 *
 * Example invocation to generate:
 *
 *   msxsl.exe GenericMasterFunctions.xml XSLJavaComponentModel.xsl -o GenericMaster.java
 *
 ******************************************************************************/ 
package org.safs.model.components;

import org.safs.model.commands.GenericMasterFunctions;
import org.safs.model.ComponentFunction;
import org.safs.model.components.UIComponent;
import org.safs.model.StepTestTable;

public class GenericMaster extends UIComponent {

    /*****************
    Constructor 

    Create an instance of pseudo-component representing 
    a specific component in a specific window.
    
    @param window  Optional:NO 
           Specifies which Window this component is 'in'.
    @param compname Optional:NO 
           Specifies the AppMap name of the component in the Window.
    ****************/
    public GenericMaster(Window window, String compname) {

        super(window, compname);
    }

    /*****************
    Constructor 

    Create an instance of pseudo-component representing 
    a specific component in a specific window.
    
    This convenience routine will create the requisite Window component.
    
    @param winname  Optional:NO 
           Specifies the AppMap name of the window.
    @param compname Optional:NO 
           Specifies the AppMap name of the component in the Window.
    ****************/
    public GenericMaster(String winname, String compname) {

        this(new Window(winname), compname);
    }

    protected GenericMaster(String compname) {

        super(compname);
    }



    /*********** <pre>
               Assign the string value of an object property to a specific DDVariable
              
               Assign the string value of an object property to a specific DDVariable.
               Note, if you supply the name of the variable and include the leading
               caret (^) symbol then the variable must be enclosed in quotes.
               Otherwise, that variable will be used like any other variable and the
               substituted value of that variable will be interpretted as the name
               of the variable you wish to use.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param propertyName  Optional:NO
             The case-sensitive name of the object property.
              
     @param variableName  Optional:NO
             The name of the variable to receive the property value.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line property values.
              
     **********/
    public ComponentFunction assignPropertyVariable(String propertyName, String variableName, String suppressValue ) {

        if ( propertyName == null ) throw new IllegalArgumentException ( "assignPropertyVariable.propertyName = null");
        if ( variableName == null ) throw new IllegalArgumentException ( "assignPropertyVariable.variableName = null");
        return GenericMasterFunctions.assignPropertyVariable(getWindow().getName(), getName(), propertyName, variableName, suppressValue);
    }

    /*********** <pre>
               Assign the string value of an object property to a specific DDVariable
              
               Assign the string value of an object property to a specific DDVariable.
               Note, if you supply the name of the variable and include the leading
               caret (^) symbol then the variable must be enclosed in quotes.
               Otherwise, that variable will be used like any other variable and the
               substituted value of that variable will be interpretted as the name
               of the variable you wish to use.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param propertyName  Optional:NO
             The case-sensitive name of the object property.
              
     @param variableName  Optional:NO
             The name of the variable to receive the property value.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line property values.
              
     **********/
    public void assignPropertyVariable(StepTestTable table, String propertyName, String variableName, String suppressValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "assignPropertyVariable.table = null");

        if ( propertyName == null ) throw new IllegalArgumentException ( "assignPropertyVariable.propertyName = null");
        if ( variableName == null ) throw new IllegalArgumentException ( "assignPropertyVariable.variableName = null");
        table.add( GenericMasterFunctions.assignPropertyVariable(getWindow().getName(), getName(), propertyName, variableName, suppressValue));
    }

    /*********** <pre>
               Assign the string value of an object property to a specific DDVariable
              
               Assign the string value of an object property to a specific DDVariable.
               Note, if you supply the name of the variable and include the leading
               caret (^) symbol then the variable must be enclosed in quotes.
               Otherwise, that variable will be used like any other variable and the
               substituted value of that variable will be interpretted as the name
               of the variable you wish to use.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property.
              <BR/>         variableName -- Optional:NO
             The name of the variable to receive the property value.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line property values.
              
    </UL>

     **********/
    public ComponentFunction assignPropertyVariable(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "assignPropertyVariable.parameters = null");
        return GenericMasterFunctions.assignPropertyVariable(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
               Assign the string value of an object property to a specific DDVariable
              
               Assign the string value of an object property to a specific DDVariable.
               Note, if you supply the name of the variable and include the leading
               caret (^) symbol then the variable must be enclosed in quotes.
               Otherwise, that variable will be used like any other variable and the
               substituted value of that variable will be interpretted as the name
               of the variable you wish to use.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property.
              <BR/>         variableName -- Optional:NO
             The name of the variable to receive the property value.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line property values.
              
    </UL>

     **********/
    public void assignPropertyVariable(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "assignPropertyVariable.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "assignPropertyVariable.parameters = null");
        table.add( GenericMasterFunctions.assignPropertyVariable(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Copy the current contents of an object's data to a file.
              
             Only an object that Robot can perform an ObjectData VP 
             on can use this command.  By default, the files will be
             stored in the active "Test" directory.  If you specify a
             relative path, the path will be relative to the project
             directory.  The directory for a full or relative path 
             must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param file  Optional:NO
             The name of the file used to store the object data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public ComponentFunction captureObjectDataToFile(String file, String fileEncoding, String filterMode, String filterOptions ) {

        if ( file == null ) throw new IllegalArgumentException ( "captureObjectDataToFile.file = null");
        return GenericMasterFunctions.captureObjectDataToFile(getWindow().getName(), getName(), file, fileEncoding, filterMode, filterOptions);
    }

    /*********** <pre>
             Copy the current contents of an object's data to a file.
              
             Only an object that Robot can perform an ObjectData VP 
             on can use this command.  By default, the files will be
             stored in the active "Test" directory.  If you specify a
             relative path, the path will be relative to the project
             directory.  The directory for a full or relative path 
             must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param file  Optional:NO
             The name of the file used to store the object data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public void captureObjectDataToFile(StepTestTable table, String file, String fileEncoding, String filterMode, String filterOptions ) {

        if ( table == null ) throw new IllegalArgumentException ( "captureObjectDataToFile.table = null");

        if ( file == null ) throw new IllegalArgumentException ( "captureObjectDataToFile.file = null");
        table.add( GenericMasterFunctions.captureObjectDataToFile(getWindow().getName(), getName(), file, fileEncoding, filterMode, filterOptions));
    }

    /*********** <pre>
             Copy the current contents of an object's data to a file.
              
             Only an object that Robot can perform an ObjectData VP 
             on can use this command.  By default, the files will be
             stored in the active "Test" directory.  If you specify a
             relative path, the path will be relative to the project
             directory.  The directory for a full or relative path 
             must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         file -- Optional:NO
             The name of the file used to store the object data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public ComponentFunction captureObjectDataToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "captureObjectDataToFile.parameters = null");
        return GenericMasterFunctions.captureObjectDataToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Copy the current contents of an object's data to a file.
              
             Only an object that Robot can perform an ObjectData VP 
             on can use this command.  By default, the files will be
             stored in the active "Test" directory.  If you specify a
             relative path, the path will be relative to the project
             directory.  The directory for a full or relative path 
             must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         file -- Optional:NO
             The name of the file used to store the object data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public void captureObjectDataToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "captureObjectDataToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "captureObjectDataToFile.parameters = null");
        table.add( GenericMasterFunctions.captureObjectDataToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Copy all of the value properties a test object to a file.
              
             Copy all of the value properties a test object to a file.
             By default, the files will be
             stored in the active "Test" directory.  If you specify a
             relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Google Android</LI>
    </UL>

     @param file  Optional:NO
             The name of the file used to store the property list data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             
     **********/
    public ComponentFunction capturePropertiesToFile(String file, String fileEncoding ) {

        if ( file == null ) throw new IllegalArgumentException ( "capturePropertiesToFile.file = null");
        return GenericMasterFunctions.capturePropertiesToFile(getWindow().getName(), getName(), file, fileEncoding);
    }

    /*********** <pre>
             Copy all of the value properties a test object to a file.
              
             Copy all of the value properties a test object to a file.
             By default, the files will be
             stored in the active "Test" directory.  If you specify a
             relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Google Android</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param file  Optional:NO
             The name of the file used to store the property list data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             
     **********/
    public void capturePropertiesToFile(StepTestTable table, String file, String fileEncoding ) {

        if ( table == null ) throw new IllegalArgumentException ( "capturePropertiesToFile.table = null");

        if ( file == null ) throw new IllegalArgumentException ( "capturePropertiesToFile.file = null");
        table.add( GenericMasterFunctions.capturePropertiesToFile(getWindow().getName(), getName(), file, fileEncoding));
    }

    /*********** <pre>
             Copy all of the value properties a test object to a file.
              
             Copy all of the value properties a test object to a file.
             By default, the files will be
             stored in the active "Test" directory.  If you specify a
             relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Google Android</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         file -- Optional:NO
             The name of the file used to store the property list data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             
    </UL>

     **********/
    public ComponentFunction capturePropertiesToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "capturePropertiesToFile.parameters = null");
        return GenericMasterFunctions.capturePropertiesToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Copy all of the value properties a test object to a file.
              
             Copy all of the value properties a test object to a file.
             By default, the files will be
             stored in the active "Test" directory.  If you specify a
             relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Google Android</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         file -- Optional:NO
             The name of the file used to store the property list data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             
    </UL>

     **********/
    public void capturePropertiesToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "capturePropertiesToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "capturePropertiesToFile.parameters = null");
        table.add( GenericMasterFunctions.capturePropertiesToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Copy a propertie's value of a test object to to a file.
              
             Copy a propertie's value of a test object to to a file.
			 The file will be stored in the active "Test" directory. 
		     If you specify a relative path, the path will be relative 
		     to the project directory.  The directory for a full or 
		     relative path must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param propertyName  Optional:NO
             The case-sensitive name of the object array property to verify.
              
     @param file  Optional:NO
             The name of the file used to store the property list data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
     **********/
    public ComponentFunction capturePropertyToFile(String propertyName, String file, String fileEncoding ) {

        if ( file == null ) throw new IllegalArgumentException ( "capturePropertyToFile.file = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "capturePropertyToFile.propertyName = null");
        return GenericMasterFunctions.capturePropertyToFile(getWindow().getName(), getName(), propertyName, file, fileEncoding);
    }

    /*********** <pre>
             Copy a propertie's value of a test object to to a file.
              
             Copy a propertie's value of a test object to to a file.
			 The file will be stored in the active "Test" directory. 
		     If you specify a relative path, the path will be relative 
		     to the project directory.  The directory for a full or 
		     relative path must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param propertyName  Optional:NO
             The case-sensitive name of the object array property to verify.
              
     @param file  Optional:NO
             The name of the file used to store the property list data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
     **********/
    public void capturePropertyToFile(StepTestTable table, String propertyName, String file, String fileEncoding ) {

        if ( table == null ) throw new IllegalArgumentException ( "capturePropertyToFile.table = null");

        if ( file == null ) throw new IllegalArgumentException ( "capturePropertyToFile.file = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "capturePropertyToFile.propertyName = null");
        table.add( GenericMasterFunctions.capturePropertyToFile(getWindow().getName(), getName(), propertyName, file, fileEncoding));
    }

    /*********** <pre>
             Copy a propertie's value of a test object to to a file.
              
             Copy a propertie's value of a test object to to a file.
			 The file will be stored in the active "Test" directory. 
		     If you specify a relative path, the path will be relative 
		     to the project directory.  The directory for a full or 
		     relative path must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object array property to verify.
              <BR/>         file -- Optional:NO
             The name of the file used to store the property list data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
    </UL>

     **********/
    public ComponentFunction capturePropertyToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "capturePropertyToFile.parameters = null");
        return GenericMasterFunctions.capturePropertyToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Copy a propertie's value of a test object to to a file.
              
             Copy a propertie's value of a test object to to a file.
			 The file will be stored in the active "Test" directory. 
		     If you specify a relative path, the path will be relative 
		     to the project directory.  The directory for a full or 
		     relative path must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object array property to verify.
              <BR/>         file -- Optional:NO
             The name of the file used to store the property list data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when saving data to a file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
    </UL>

     **********/
    public void capturePropertyToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "capturePropertyToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "capturePropertyToFile.parameters = null");
        table.add( GenericMasterFunctions.capturePropertyToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Clear the internal application map cache.
          
             Some Engines maintain an internal cache of previously sought
             application objects.  In RobotJ, there exists a cache of
             TestObject objects, that cache is cleared by this command
             so that the recognition string algorithm has to be re-run
             the next time a window or component is to be recognized.
             This is useful for cases when a dialog pops up, goes
             away, then pops up again.  The cached version of the
             dialog or it's components may not correspond to the actual
             version.  This command lets a tester clear the cache when
             this kind of condition may arrise.
             (Future: instruct the safsmaps service
             to reload it's application map data)
              </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     **********/
    public ComponentFunction clearAppMapCache( ) {

        return GenericMasterFunctions.clearAppMapCache(getWindow().getName(), getName());
    }

    /*********** <pre>
             Clear the internal application map cache.
          
             Some Engines maintain an internal cache of previously sought
             application objects.  In RobotJ, there exists a cache of
             TestObject objects, that cache is cleared by this command
             so that the recognition string algorithm has to be re-run
             the next time a window or component is to be recognized.
             This is useful for cases when a dialog pops up, goes
             away, then pops up again.  The cached version of the
             dialog or it's components may not correspond to the actual
             version.  This command lets a tester clear the cache when
             this kind of condition may arrise.
             (Future: instruct the safsmaps service
             to reload it's application map data)
              </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void clearAppMapCache(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "clearAppMapCache.table = null");

        table.add( GenericMasterFunctions.clearAppMapCache(getWindow().getName(), getName()));
    }

    /*********** <pre>
                Clear the cache of a component.
              
                Clear the cache of a component. To save time, component may contain a cache to store its content
                or some time-consuming resource. But sometime, the cache's content may not be fresh, which will
                 affect the test, at this situation, user may call this keyword to clear the cache and SAFS will
                 use the latest content.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     **********/
    public ComponentFunction clearCache( ) {
        return GenericMasterFunctions.clearCache(getWindow().getName(), getName());
    }

    /*********** <pre>
                Clear the cache of a component.
              
                Clear the cache of a component. To save time, component may contain a cache to store its content
                or some time-consuming resource. But sometime, the cache's content may not be fresh, which will
                 affect the test, at this situation, user may call this keyword to clear the cache and SAFS will
                 use the latest content.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void clearCache(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "clearCache.table = null");
        table.add( GenericMasterFunctions.clearCache(getWindow().getName(), getName()));
    }

    /*********** <pre>
                Execute a piece of script on the specified component synchronously.
              
                Execute a piece of script on the specified component synchronously.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param script  Optional:NO
                The script to execute.
              
     @param paramN  Optional:YES
                The paramters passed to script.
              
     **********/
    public ComponentFunction executeScript(String script, String paramN ) {

        if ( script == null ) throw new IllegalArgumentException ( "executeScript.script = null");
        return GenericMasterFunctions.executeScript(getWindow().getName(), getName(), script, paramN);
    }

    /*********** <pre>
                Execute a piece of script on the specified component synchronously.
              
                Execute a piece of script on the specified component synchronously.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param script  Optional:NO
                The script to execute.
              
     @param paramN  Optional:YES
                The paramters passed to script.
              
     **********/
    public void executeScript(StepTestTable table, String script, String paramN ) {

        if ( table == null ) throw new IllegalArgumentException ( "executeScript.table = null");

        if ( script == null ) throw new IllegalArgumentException ( "executeScript.script = null");
        table.add( GenericMasterFunctions.executeScript(getWindow().getName(), getName(), script, paramN));
    }

    /*********** <pre>
                Execute a piece of script on the specified component synchronously.
              
                Execute a piece of script on the specified component synchronously.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         script -- Optional:NO
                The script to execute.
              <BR/>         paramN -- Optional:YES
                The paramters passed to script.
              
    </UL>

     **********/
    public ComponentFunction executeScript(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "executeScript.parameters = null");
        return GenericMasterFunctions.executeScript(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
                Execute a piece of script on the specified component synchronously.
              
                Execute a piece of script on the specified component synchronously.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         script -- Optional:NO
                The script to execute.
              <BR/>         paramN -- Optional:YES
                The paramters passed to script.
              
    </UL>

     **********/
    public void executeScript(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "executeScript.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "executeScript.parameters = null");
        table.add( GenericMasterFunctions.executeScript(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
                Get a component's 'computed style', and save them to a file.
              
                Get a component's 'computed style', and save them to a file.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param testFile  Optional:NO
                The test file to save 'computed style'.
              
     **********/
    public ComponentFunction getComputedStyle(String testFile ) {

        if ( testFile == null ) throw new IllegalArgumentException ( "getComputedStyle.testFile = null");
        return GenericMasterFunctions.getComputedStyle(getWindow().getName(), getName(), testFile);
    }

    /*********** <pre>
                Get a component's 'computed style', and save them to a file.
              
                Get a component's 'computed style', and save them to a file.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param testFile  Optional:NO
                The test file to save 'computed style'.
              
     **********/
    public void getComputedStyle(StepTestTable table, String testFile ) {

        if ( table == null ) throw new IllegalArgumentException ( "getComputedStyle.table = null");

        if ( testFile == null ) throw new IllegalArgumentException ( "getComputedStyle.testFile = null");
        table.add( GenericMasterFunctions.getComputedStyle(getWindow().getName(), getName(), testFile));
    }

    /*********** <pre>
               Capture the screen shot of a GUI component and save it to a file
              
               Capture the screen shot of a GUI component and save it to a file.
               The available formats for the output file are BITMAP (*.bmp) and JPEG
               (*.jpg). 
               For RJ and IBT engine, other formats like TIFF (*.tif), GIF (*.gif), 
               PNG (*.png) and PNM (*.pnm) are also supported.
               Optionally the user can specify part of the component to capture.
               
               The specified GUI component/part must be in the viewing range of its 
               containing window. If portion of the component is displayed in the 
               window, only that portion will be captured; if the component falls
               completely out of the viewing range of the window, the command will 
               fail. The command makes no attempt to bring the component into view.
               
               
               Robot Classic (RC) Specific Notes:  
               		1) This command may fail to execute if the user has turned off logging 
              	 	to TestManager via the Robot tools setting.  You may have to enable 
               		TestManager logging for the command to successfully execute.
               		2) This command requires that the TestManager Image Comparator tool is
               		installed on the test machine. Machines having only the Robot Test Agent
               		installed will not be able to use this command.
               		3) Due to a bug in Robot Classic, images captured using the Robot Classic
			engine may differ in image size and/or file size from those captured using 
			other supported engines.  Depending on the comparator used, rebenching
               		your images may be necessary when migrating to another engine.
               
               
               RobotJ (RJ) and IBT Specific Notes:
               		1)It requires that Java Advanced Imaging (JAI) be installed
               		on the test machine
               		2)It supports to save image in format TIFF (*.tif), GIF (*.gif), PNG (*.png)
               		and PNM (*.pnm) 
               
               
               Apple IOS specific Notes:
               UIAutomation captures all screenshots as PNG images, but SAFS copies and stores them 
               into the image format desired (JPG, BMP, etc.). However, the rootname of the desired 
               output image name must be unique to avoid UIAutomation generating indexed image names 
               we will not be looking for.
               For example, specifying MyImage.JPG and later MyImage.BMP will cause UIAutomation to capture 
               MyImage.PNG and MyImage1.PNG. When attempting to find MyImage.PNG captured for MyImage.BMP 
               we will retrieve MyImage.PNG which is NOT the correct image capture for MyImage.BMP.
               
           </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param outputFile  Optional:NO
             Path (with filename) to the output image file.
              
     @param subArea  Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
              
     @param filteredAreas  Optional:YES
              "Filter=one or multiple areas" to filter the GUI image (or sub image of GUI if the parameter "SubArea" is present)
             
     **********/
    public ComponentFunction getGUIImage(String outputFile, String subArea, String filteredAreas ) {

        if ( outputFile == null ) throw new IllegalArgumentException ( "getGUIImage.outputFile = null");
        return GenericMasterFunctions.getGUIImage(getWindow().getName(), getName(), outputFile, subArea, filteredAreas);
    }

    /*********** <pre>
               Capture the screen shot of a GUI component and save it to a file
              
               Capture the screen shot of a GUI component and save it to a file.
               The available formats for the output file are BITMAP (*.bmp) and JPEG
               (*.jpg). 
               For RJ and IBT engine, other formats like TIFF (*.tif), GIF (*.gif), 
               PNG (*.png) and PNM (*.pnm) are also supported.
               Optionally the user can specify part of the component to capture.
               
               The specified GUI component/part must be in the viewing range of its 
               containing window. If portion of the component is displayed in the 
               window, only that portion will be captured; if the component falls
               completely out of the viewing range of the window, the command will 
               fail. The command makes no attempt to bring the component into view.
               
               
               Robot Classic (RC) Specific Notes:  
               		1) This command may fail to execute if the user has turned off logging 
              	 	to TestManager via the Robot tools setting.  You may have to enable 
               		TestManager logging for the command to successfully execute.
               		2) This command requires that the TestManager Image Comparator tool is
               		installed on the test machine. Machines having only the Robot Test Agent
               		installed will not be able to use this command.
               		3) Due to a bug in Robot Classic, images captured using the Robot Classic
			engine may differ in image size and/or file size from those captured using 
			other supported engines.  Depending on the comparator used, rebenching
               		your images may be necessary when migrating to another engine.
               
               
               RobotJ (RJ) and IBT Specific Notes:
               		1)It requires that Java Advanced Imaging (JAI) be installed
               		on the test machine
               		2)It supports to save image in format TIFF (*.tif), GIF (*.gif), PNG (*.png)
               		and PNM (*.pnm) 
               
               
               Apple IOS specific Notes:
               UIAutomation captures all screenshots as PNG images, but SAFS copies and stores them 
               into the image format desired (JPG, BMP, etc.). However, the rootname of the desired 
               output image name must be unique to avoid UIAutomation generating indexed image names 
               we will not be looking for.
               For example, specifying MyImage.JPG and later MyImage.BMP will cause UIAutomation to capture 
               MyImage.PNG and MyImage1.PNG. When attempting to find MyImage.PNG captured for MyImage.BMP 
               we will retrieve MyImage.PNG which is NOT the correct image capture for MyImage.BMP.
               
           </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param outputFile  Optional:NO
             Path (with filename) to the output image file.
              
     @param subArea  Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
              
     @param filteredAreas  Optional:YES
              "Filter=one or multiple areas" to filter the GUI image (or sub image of GUI if the parameter "SubArea" is present)
             
     **********/
    public void getGUIImage(StepTestTable table, String outputFile, String subArea, String filteredAreas ) {

        if ( table == null ) throw new IllegalArgumentException ( "getGUIImage.table = null");

        if ( outputFile == null ) throw new IllegalArgumentException ( "getGUIImage.outputFile = null");
        table.add( GenericMasterFunctions.getGUIImage(getWindow().getName(), getName(), outputFile, subArea, filteredAreas));
    }

    /*********** <pre>
               Capture the screen shot of a GUI component and save it to a file
              
               Capture the screen shot of a GUI component and save it to a file.
               The available formats for the output file are BITMAP (*.bmp) and JPEG
               (*.jpg). 
               For RJ and IBT engine, other formats like TIFF (*.tif), GIF (*.gif), 
               PNG (*.png) and PNM (*.pnm) are also supported.
               Optionally the user can specify part of the component to capture.
               
               The specified GUI component/part must be in the viewing range of its 
               containing window. If portion of the component is displayed in the 
               window, only that portion will be captured; if the component falls
               completely out of the viewing range of the window, the command will 
               fail. The command makes no attempt to bring the component into view.
               
               
               Robot Classic (RC) Specific Notes:  
               		1) This command may fail to execute if the user has turned off logging 
              	 	to TestManager via the Robot tools setting.  You may have to enable 
               		TestManager logging for the command to successfully execute.
               		2) This command requires that the TestManager Image Comparator tool is
               		installed on the test machine. Machines having only the Robot Test Agent
               		installed will not be able to use this command.
               		3) Due to a bug in Robot Classic, images captured using the Robot Classic
			engine may differ in image size and/or file size from those captured using 
			other supported engines.  Depending on the comparator used, rebenching
               		your images may be necessary when migrating to another engine.
               
               
               RobotJ (RJ) and IBT Specific Notes:
               		1)It requires that Java Advanced Imaging (JAI) be installed
               		on the test machine
               		2)It supports to save image in format TIFF (*.tif), GIF (*.gif), PNG (*.png)
               		and PNM (*.pnm) 
               
               
               Apple IOS specific Notes:
               UIAutomation captures all screenshots as PNG images, but SAFS copies and stores them 
               into the image format desired (JPG, BMP, etc.). However, the rootname of the desired 
               output image name must be unique to avoid UIAutomation generating indexed image names 
               we will not be looking for.
               For example, specifying MyImage.JPG and later MyImage.BMP will cause UIAutomation to capture 
               MyImage.PNG and MyImage1.PNG. When attempting to find MyImage.PNG captured for MyImage.BMP 
               we will retrieve MyImage.PNG which is NOT the correct image capture for MyImage.BMP.
               
           </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         outputFile -- Optional:NO
             Path (with filename) to the output image file.
              <BR/>         subArea -- Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
              <BR/>         filteredAreas -- Optional:YES
              "Filter=one or multiple areas" to filter the GUI image (or sub image of GUI if the parameter "SubArea" is present)
             
    </UL>

     **********/
    public ComponentFunction getGUIImage(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "getGUIImage.parameters = null");
        return GenericMasterFunctions.getGUIImage(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
               Capture the screen shot of a GUI component and save it to a file
              
               Capture the screen shot of a GUI component and save it to a file.
               The available formats for the output file are BITMAP (*.bmp) and JPEG
               (*.jpg). 
               For RJ and IBT engine, other formats like TIFF (*.tif), GIF (*.gif), 
               PNG (*.png) and PNM (*.pnm) are also supported.
               Optionally the user can specify part of the component to capture.
               
               The specified GUI component/part must be in the viewing range of its 
               containing window. If portion of the component is displayed in the 
               window, only that portion will be captured; if the component falls
               completely out of the viewing range of the window, the command will 
               fail. The command makes no attempt to bring the component into view.
               
               
               Robot Classic (RC) Specific Notes:  
               		1) This command may fail to execute if the user has turned off logging 
              	 	to TestManager via the Robot tools setting.  You may have to enable 
               		TestManager logging for the command to successfully execute.
               		2) This command requires that the TestManager Image Comparator tool is
               		installed on the test machine. Machines having only the Robot Test Agent
               		installed will not be able to use this command.
               		3) Due to a bug in Robot Classic, images captured using the Robot Classic
			engine may differ in image size and/or file size from those captured using 
			other supported engines.  Depending on the comparator used, rebenching
               		your images may be necessary when migrating to another engine.
               
               
               RobotJ (RJ) and IBT Specific Notes:
               		1)It requires that Java Advanced Imaging (JAI) be installed
               		on the test machine
               		2)It supports to save image in format TIFF (*.tif), GIF (*.gif), PNG (*.png)
               		and PNM (*.pnm) 
               
               
               Apple IOS specific Notes:
               UIAutomation captures all screenshots as PNG images, but SAFS copies and stores them 
               into the image format desired (JPG, BMP, etc.). However, the rootname of the desired 
               output image name must be unique to avoid UIAutomation generating indexed image names 
               we will not be looking for.
               For example, specifying MyImage.JPG and later MyImage.BMP will cause UIAutomation to capture 
               MyImage.PNG and MyImage1.PNG. When attempting to find MyImage.PNG captured for MyImage.BMP 
               we will retrieve MyImage.PNG which is NOT the correct image capture for MyImage.BMP.
               
           </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         outputFile -- Optional:NO
             Path (with filename) to the output image file.
              <BR/>         subArea -- Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
              <BR/>         filteredAreas -- Optional:YES
              "Filter=one or multiple areas" to filter the GUI image (or sub image of GUI if the parameter "SubArea" is present)
             
    </UL>

     **********/
    public void getGUIImage(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "getGUIImage.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "getGUIImage.parameters = null");
        table.add( GenericMasterFunctions.getGUIImage(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Incorporate OCR technology to detect the text on a GUI component and save the text to a variable.
             
             Two open-source OCRs are integrated into SAFS. One is TesseractOCR (TOCR) at 
             http://code.google.com/p/tesseract-ocr; the other GOCR at http://jocr.sourceforge.net. 
             
             TOCR 2.0.4 and GOCR 0.48 are the latest release. They are available in SAFS and only 
             support English. Both two OCR owners claim to support more languages in next release. Chinese, 
             Japanese, and Korean are going to be supported in TOCR's next release 3.00.
			
       	         </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param variableName  Optional:NO
             The name of the variable to receive detected text.
              
     @param subArea  Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
             
     @param oCRId  Optional:YES
             OCRId indicating the OCR used to recognize text.
             
     @param langId  Optional:YES
             Optional LangId representing the language in use for selected OCR to recognize text. 
             
     @param scaleRatio  Optional:YES
             Optional ScaleRatio indicating the scale ratio for resizing the original image.
             
     **********/
    public ComponentFunction getTextFromGUI(String variableName, String subArea, String oCRId, String langId, String scaleRatio ) {

        if ( variableName == null ) throw new IllegalArgumentException ( "getTextFromGUI.variableName = null");
        return GenericMasterFunctions.getTextFromGUI(getWindow().getName(), getName(), variableName, subArea, oCRId, langId, scaleRatio);
    }

    /*********** <pre>
             Incorporate OCR technology to detect the text on a GUI component and save the text to a variable.
             
             Two open-source OCRs are integrated into SAFS. One is TesseractOCR (TOCR) at 
             http://code.google.com/p/tesseract-ocr; the other GOCR at http://jocr.sourceforge.net. 
             
             TOCR 2.0.4 and GOCR 0.48 are the latest release. They are available in SAFS and only 
             support English. Both two OCR owners claim to support more languages in next release. Chinese, 
             Japanese, and Korean are going to be supported in TOCR's next release 3.00.
			
       	         </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param variableName  Optional:NO
             The name of the variable to receive detected text.
              
     @param subArea  Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
             
     @param oCRId  Optional:YES
             OCRId indicating the OCR used to recognize text.
             
     @param langId  Optional:YES
             Optional LangId representing the language in use for selected OCR to recognize text. 
             
     @param scaleRatio  Optional:YES
             Optional ScaleRatio indicating the scale ratio for resizing the original image.
             
     **********/
    public void getTextFromGUI(StepTestTable table, String variableName, String subArea, String oCRId, String langId, String scaleRatio ) {

        if ( table == null ) throw new IllegalArgumentException ( "getTextFromGUI.table = null");

        if ( variableName == null ) throw new IllegalArgumentException ( "getTextFromGUI.variableName = null");
        table.add( GenericMasterFunctions.getTextFromGUI(getWindow().getName(), getName(), variableName, subArea, oCRId, langId, scaleRatio));
    }

    /*********** <pre>
             Incorporate OCR technology to detect the text on a GUI component and save the text to a variable.
             
             Two open-source OCRs are integrated into SAFS. One is TesseractOCR (TOCR) at 
             http://code.google.com/p/tesseract-ocr; the other GOCR at http://jocr.sourceforge.net. 
             
             TOCR 2.0.4 and GOCR 0.48 are the latest release. They are available in SAFS and only 
             support English. Both two OCR owners claim to support more languages in next release. Chinese, 
             Japanese, and Korean are going to be supported in TOCR's next release 3.00.
			
       	         </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         variableName -- Optional:NO
             The name of the variable to receive detected text.
              <BR/>         subArea -- Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
             <BR/>         oCRId -- Optional:YES
             OCRId indicating the OCR used to recognize text.
             <BR/>         langId -- Optional:YES
             Optional LangId representing the language in use for selected OCR to recognize text. 
             <BR/>         scaleRatio -- Optional:YES
             Optional ScaleRatio indicating the scale ratio for resizing the original image.
             
    </UL>

     **********/
    public ComponentFunction getTextFromGUI(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "getTextFromGUI.parameters = null");
        return GenericMasterFunctions.getTextFromGUI(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Incorporate OCR technology to detect the text on a GUI component and save the text to a variable.
             
             Two open-source OCRs are integrated into SAFS. One is TesseractOCR (TOCR) at 
             http://code.google.com/p/tesseract-ocr; the other GOCR at http://jocr.sourceforge.net. 
             
             TOCR 2.0.4 and GOCR 0.48 are the latest release. They are available in SAFS and only 
             support English. Both two OCR owners claim to support more languages in next release. Chinese, 
             Japanese, and Korean are going to be supported in TOCR's next release 3.00.
			
       	         </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         variableName -- Optional:NO
             The name of the variable to receive detected text.
              <BR/>         subArea -- Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
             <BR/>         oCRId -- Optional:YES
             OCRId indicating the OCR used to recognize text.
             <BR/>         langId -- Optional:YES
             Optional LangId representing the language in use for selected OCR to recognize text. 
             <BR/>         scaleRatio -- Optional:YES
             Optional ScaleRatio indicating the scale ratio for resizing the original image.
             
    </UL>

     **********/
    public void getTextFromGUI(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "getTextFromGUI.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "getTextFromGUI.parameters = null");
        table.add( GenericMasterFunctions.getTextFromGUI(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
               Routine to verify the visual existence of a particular window and/or component.
              
               Routine to verify the visual existence of a particular window and/or component.
               If the window(Field 2) and component(Field 3) are the same then we only
               check for the existence of the window.  However, if the component is
               actually a child of the window then we first check for the window and
               then check for the component.
               
               If a Window or Component is HIDDEN, it will be treated as if it Does NOT Exist.
               The item must be VISIBLE to pass.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     **********/
    public ComponentFunction gUIDoesExist( ) {

        return GenericMasterFunctions.gUIDoesExist(getWindow().getName(), getName());
    }

    /*********** <pre>
               Routine to verify the visual existence of a particular window and/or component.
              
               Routine to verify the visual existence of a particular window and/or component.
               If the window(Field 2) and component(Field 3) are the same then we only
               check for the existence of the window.  However, if the component is
               actually a child of the window then we first check for the window and
               then check for the component.
               
               If a Window or Component is HIDDEN, it will be treated as if it Does NOT Exist.
               The item must be VISIBLE to pass.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void gUIDoesExist(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "gUIDoesExist.table = null");

        table.add( GenericMasterFunctions.gUIDoesExist(getWindow().getName(), getName()));
    }

    /*********** <pre>
               Routine to verify the visual non-existence of a particular window and/or component.
              
               Routine to verify the visual non-existence of a particular window and/or component.
               If the window(Field 2) and component(Field 3) are the same then we only
               check for the visual non-existence of the window.  However, if the component is
               actually a child of the window then we first check for the visual existence of the
               window and then check for the visual non-existence of the component.
               
               If a Window or Component is HIDDEN, it will be treated as if it Does NOT Exist.
               The item must not exist or be HIDDEN to pass.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     **********/
    public ComponentFunction gUIDoesNotExist( ) {

        return GenericMasterFunctions.gUIDoesNotExist(getWindow().getName(), getName());
    }

    /*********** <pre>
               Routine to verify the visual non-existence of a particular window and/or component.
              
               Routine to verify the visual non-existence of a particular window and/or component.
               If the window(Field 2) and component(Field 3) are the same then we only
               check for the visual non-existence of the window.  However, if the component is
               actually a child of the window then we first check for the visual existence of the
               window and then check for the visual non-existence of the component.
               
               If a Window or Component is HIDDEN, it will be treated as if it Does NOT Exist.
               The item must not exist or be HIDDEN to pass.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     **********/
    public void gUIDoesNotExist(StepTestTable table ) {

        if ( table == null ) throw new IllegalArgumentException ( "gUIDoesNotExist.table = null");

        table.add( GenericMasterFunctions.gUIDoesNotExist(getWindow().getName(), getName()));
    }

    /*********** <pre> 
                Hover the mouse over an object.
              
                By default, hover on the center of the component for 2000 milliseconds.
                We can also hover on any part of an object based on a stored x,y 
                coordinate.  The object containing the coordinate is first given 
                context and then the hover command is generated at the coordinate.  
                Thus, an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component HoverMouse           1000
                (2) t MainWindow MainWindow HoverMouse AnObject 2000
                (3) t MainWindow FolderTree HoverMouse Node1 3000
                
                #1 above will contain a blank as it's 5th field and 1000 as 6th field, 
                and it will hover at the center of the Component for 1000 milliseconds.
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to hover at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and hover at the coordinates specified by the reference.               	              
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup and use for the hover.
              
     @param hoverTime  Optional:YES  DefaultVal:2000 
	                (Optional)Number of milliseconds to hover.
	              
     **********/
    public ComponentFunction hoverMouse(String appMapSubkey, String hoverTime ) {

        return GenericMasterFunctions.hoverMouse(getWindow().getName(), getName(), appMapSubkey, hoverTime);
    }

    /*********** <pre> 
                Hover the mouse over an object.
              
                By default, hover on the center of the component for 2000 milliseconds.
                We can also hover on any part of an object based on a stored x,y 
                coordinate.  The object containing the coordinate is first given 
                context and then the hover command is generated at the coordinate.  
                Thus, an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component HoverMouse           1000
                (2) t MainWindow MainWindow HoverMouse AnObject 2000
                (3) t MainWindow FolderTree HoverMouse Node1 3000
                
                #1 above will contain a blank as it's 5th field and 1000 as 6th field, 
                and it will hover at the center of the Component for 1000 milliseconds.
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to hover at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and hover at the coordinates specified by the reference.               	              
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Optional)Name of the AppMap subkey to lookup and use for the hover.
              
     @param hoverTime  Optional:YES  DefaultVal:2000 
	                (Optional)Number of milliseconds to hover.
	              
     **********/
    public void hoverMouse(StepTestTable table, String appMapSubkey, String hoverTime ) {

        if ( table == null ) throw new IllegalArgumentException ( "hoverMouse.table = null");

        table.add( GenericMasterFunctions.hoverMouse(getWindow().getName(), getName(), appMapSubkey, hoverTime));
    }

    /*********** <pre> 
                Hover the mouse over an object.
              
                By default, hover on the center of the component for 2000 milliseconds.
                We can also hover on any part of an object based on a stored x,y 
                coordinate.  The object containing the coordinate is first given 
                context and then the hover command is generated at the coordinate.  
                Thus, an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component HoverMouse           1000
                (2) t MainWindow MainWindow HoverMouse AnObject 2000
                (3) t MainWindow FolderTree HoverMouse Node1 3000
                
                #1 above will contain a blank as it's 5th field and 1000 as 6th field, 
                and it will hover at the center of the Component for 1000 milliseconds.
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to hover at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and hover at the coordinates specified by the reference.               	              
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional)Name of the AppMap subkey to lookup and use for the hover.
              <BR/>         hoverTime -- Optional:YES  DefaultVal:2000 
	                (Optional)Number of milliseconds to hover.
	              
    </UL>

     **********/
    public ComponentFunction hoverMouse(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "hoverMouse.parameters = null");
        return GenericMasterFunctions.hoverMouse(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                Hover the mouse over an object.
              
                By default, hover on the center of the component for 2000 milliseconds.
                We can also hover on any part of an object based on a stored x,y 
                coordinate.  The object containing the coordinate is first given 
                context and then the hover command is generated at the coordinate.  
                Thus, an item or object can be referenced by name even though it is only 
                recognized via coordinates.
                
                The coordinate lookup is done with the component name of the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component HoverMouse           1000
                (2) t MainWindow MainWindow HoverMouse AnObject 2000
                (3) t MainWindow FolderTree HoverMouse Node1 3000
                
                #1 above will contain a blank as it's 5th field and 1000 as 6th field, 
                and it will hover at the center of the Component for 1000 milliseconds.
                
                #2 above will contain an AnObject="3,10" entry in the MainWindow section 
                of the Application Map to hover at x=3, y=10 in the MainWindow.
                
                #3 above will contain a FolderTree entry in the MainWindow section with 
                normal recognition information for it.  FolderTree will also have it's
                own section in the Application Map in which there will be an entry like 
                Node1="15,30".  This will tell Robot to locate the FolderTree Generic 
                object and hover at the coordinates specified by the reference.               	              
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Optional)Name of the AppMap subkey to lookup and use for the hover.
              <BR/>         hoverTime -- Optional:YES  DefaultVal:2000 
	                (Optional)Number of milliseconds to hover.
	              
    </UL>

     **********/
    public void hoverMouse(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "hoverMouse.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "hoverMouse.parameters = null");
        table.add( GenericMasterFunctions.hoverMouse(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
                Hover the mouse over a specified screen location.
              
                Hover the mouse over a specified screen location.
                We can hover on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component HoverScreenLocation           1000
                (2) t MainWindow MainWindow HoverScreenLocation AnObject 2000
                (3) t MainWindow MainWindow HoverScreenLocation 50,80 3000
                (4) t AnyWin AnyComp HoverScreenLocation Node1 3000
                
                #1 above will contain a blank as it's 5th field and 1000 as 6th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinate data. The mouse cursor will hover at the specified Component location 
                for 1000 milliseconds.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the mouse cursor will hover with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the mouse will hover at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the mouse cursor will hover with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the mouse will hover at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param appMapSubkey  Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to lookup and use for the hover.
              
     @param hoverTime  Optional:YES  DefaultVal:2000 
	                (Optional)Number of milliseconds to hover.
	              
     **********/
    public ComponentFunction hoverScreenLocation(String appMapSubkey, String hoverTime ) {

        return GenericMasterFunctions.hoverScreenLocation(getWindow().getName(), getName(), appMapSubkey, hoverTime);
    }

    /*********** <pre> 
                Hover the mouse over a specified screen location.
              
                Hover the mouse over a specified screen location.
                We can hover on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component HoverScreenLocation           1000
                (2) t MainWindow MainWindow HoverScreenLocation AnObject 2000
                (3) t MainWindow MainWindow HoverScreenLocation 50,80 3000
                (4) t AnyWin AnyComp HoverScreenLocation Node1 3000
                
                #1 above will contain a blank as it's 5th field and 1000 as 6th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinate data. The mouse cursor will hover at the specified Component location 
                for 1000 milliseconds.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the mouse cursor will hover with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the mouse will hover at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the mouse cursor will hover with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the mouse will hover at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param appMapSubkey  Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to lookup and use for the hover.
              
     @param hoverTime  Optional:YES  DefaultVal:2000 
	                (Optional)Number of milliseconds to hover.
	              
     **********/
    public void hoverScreenLocation(StepTestTable table, String appMapSubkey, String hoverTime ) {

        if ( table == null ) throw new IllegalArgumentException ( "hoverScreenLocation.table = null");

        table.add( GenericMasterFunctions.hoverScreenLocation(getWindow().getName(), getName(), appMapSubkey, hoverTime));
    }

    /*********** <pre> 
                Hover the mouse over a specified screen location.
              
                Hover the mouse over a specified screen location.
                We can hover on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component HoverScreenLocation           1000
                (2) t MainWindow MainWindow HoverScreenLocation AnObject 2000
                (3) t MainWindow MainWindow HoverScreenLocation 50,80 3000
                (4) t AnyWin AnyComp HoverScreenLocation Node1 3000
                
                #1 above will contain a blank as it's 5th field and 1000 as 6th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinate data. The mouse cursor will hover at the specified Component location 
                for 1000 milliseconds.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the mouse cursor will hover with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the mouse will hover at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the mouse cursor will hover with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the mouse will hover at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to lookup and use for the hover.
              <BR/>         hoverTime -- Optional:YES  DefaultVal:2000 
	                (Optional)Number of milliseconds to hover.
	              
    </UL>

     **********/
    public ComponentFunction hoverScreenLocation(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "hoverScreenLocation.parameters = null");
        return GenericMasterFunctions.hoverScreenLocation(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
                Hover the mouse over a specified screen location.
              
                Hover the mouse over a specified screen location.
                We can hover on any screen location based on stored x,y 
                coordinates or hardcoded literal values. The Window:Component fields 
                can be anything at all and will be ignored if they do not exist in the app map, 
                or if the retrieved app map data does not contain coordinate data. 
                Thus, an item or object can be referenced by name even though it is only 
                known via coordinates.
                
                If the Window:Component AppMap lookup does NOT contain coordinate data and is ignored, then 
                the AppMapSubKey field is REQUIRED and is expected to contain a reference or literal 
                text containing absolute screen coordinates.
                
                If the Window:Component AppMap lookup DOES contain coordinate data, this data is treated as 
                the absolute screen coordinates to be used.  The AppMapSubKey field becomes OPTIONAL and 
                coordinate data in the field is treated as a relative offset added to the absolute values 
                found for the Window:Component.
                
                Any AppMapSubKey lookup is done with the Component name in the record AND 
                Field #5.
                
                Typical Data Table records:
                
                (1) t MainWindow Component HoverScreenLocation           1000
                (2) t MainWindow MainWindow HoverScreenLocation AnObject 2000
                (3) t MainWindow MainWindow HoverScreenLocation 50,80 3000
                (4) t AnyWin AnyComp HoverScreenLocation Node1 3000
                
                #1 above will contain a blank as it's 5th field and 1000 as 6th field. Because the AppMapSubKey 
                field is blank, the [MainWindow] section of the AppMap MUST have a Component item with valid 
                absolute screen coordinate data. The mouse cursor will hover at the specified Component location 
                for 1000 milliseconds.
                
                #2 above will contain an AnObject="Coords=50,80" entry in the [MainWindow] section 
                of the AppMap. If there is a MainWindow component in the AppMap with valid screen coordinates 
                then the mouse cursor will hover with a relative offset of 50,80 from those absolute screen 
                coordinates. Otherwise, the mouse will hover at absolute screen coordinates 50,80.
                
                #3 If there is a MainWindow component in the [MainWindow] section of the AppMap with valid screen 
                coordinates then the mouse cursor will hover with a relative offset of 50,80 from those absolute 
                screen coordinates. Otherwise, the mouse will hover at absolute screen coordinates 50,80.
                
                #4 above will contain no valid AnyWin:AnyComp coordinate data and 
                those fields will be ignored.  However, Node1 MUST exist in the 
                Application Map [AnyComp] section to provide absolute screen coordinates.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         appMapSubkey -- Optional:YES 
                (Sometimes Optional)Name of the AppMap subkey to lookup and use for the hover.
              <BR/>         hoverTime -- Optional:YES  DefaultVal:2000 
	                (Optional)Number of milliseconds to hover.
	              
    </UL>

     **********/
    public void hoverScreenLocation(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "hoverScreenLocation.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "hoverScreenLocation.parameters = null");
        table.add( GenericMasterFunctions.hoverScreenLocation(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
                Sends literal text to the specified component.
              
                Sends literal text to the specified component.
                The InputChars command does not convert or interpret any special
                characters like InputKeys (InputKeystrokes) does.
                
                Some engines cannot set keyboard focus to the component.  
                These engines will require the component already have keyboard focus before 
                calling this command.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param textValue  Optional:NO
                String of keystrokes to send.
              
     **********/
    public ComponentFunction inputCharacters(String textValue ) {

        if ( textValue == null ) throw new IllegalArgumentException ( "inputCharacters.textValue = null");
        return GenericMasterFunctions.inputCharacters(getWindow().getName(), getName(), textValue);
    }

    /*********** <pre>
                Sends literal text to the specified component.
              
                Sends literal text to the specified component.
                The InputChars command does not convert or interpret any special
                characters like InputKeys (InputKeystrokes) does.
                
                Some engines cannot set keyboard focus to the component.  
                These engines will require the component already have keyboard focus before 
                calling this command.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Google Android</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param textValue  Optional:NO
                String of keystrokes to send.
              
     **********/
    public void inputCharacters(StepTestTable table, String textValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "inputCharacters.table = null");

        if ( textValue == null ) throw new IllegalArgumentException ( "inputCharacters.textValue = null");
        table.add( GenericMasterFunctions.inputCharacters(getWindow().getName(), getName(), textValue));
    }

    /*********** <pre>
                Sends keystrokes to the specified component.
              
                Sends keystrokes to the specified component.
                
                Some engines cannot set keyboard focus to the component.  
                These engines will require the component already have keyboard focus before 
                calling this command.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Google Android</LI>
    </UL>

     @param textValue  Optional:NO
                String of keystrokes to send.
              
     **********/
    public ComponentFunction inputKeys(String textValue ) {

        if ( textValue == null ) throw new IllegalArgumentException ( "inputKeys.textValue = null");
        return GenericMasterFunctions.inputKeys(getWindow().getName(), getName(), textValue);
    }

    /*********** <pre>
                Sends keystrokes to the specified component.
              
                Sends keystrokes to the specified component.
                
                Some engines cannot set keyboard focus to the component.  
                These engines will require the component already have keyboard focus before 
                calling this command.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Abbot Abbot</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>Google Android</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param textValue  Optional:NO
                String of keystrokes to send.
              
     **********/
    public void inputKeys(StepTestTable table, String textValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "inputKeys.table = null");

        if ( textValue == null ) throw new IllegalArgumentException ( "inputKeys.textValue = null");
        table.add( GenericMasterFunctions.inputKeys(getWindow().getName(), getName(), textValue));
    }

    /*********** <pre>
             Verify if object's property exists or not.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param propertyName  Optional:NO
             The case-sensitive name of the object property to verify.
              
     @param propertyExistVariable  Optional:NO
             The variable to store 'true' or 'false' to indicate if the property exist or not.
              
     **********/
    public ComponentFunction isPropertyExist(String propertyName, String propertyExistVariable ) {

        if ( propertyExistVariable == null ) throw new IllegalArgumentException ( "isPropertyExist.propertyExistVariable = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "isPropertyExist.propertyName = null");
        return GenericMasterFunctions.isPropertyExist(getWindow().getName(), getName(), propertyName, propertyExistVariable);
    }

    /*********** <pre>
             Verify if object's property exists or not.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param propertyName  Optional:NO
             The case-sensitive name of the object property to verify.
              
     @param propertyExistVariable  Optional:NO
             The variable to store 'true' or 'false' to indicate if the property exist or not.
              
     **********/
    public void isPropertyExist(StepTestTable table, String propertyName, String propertyExistVariable ) {

        if ( table == null ) throw new IllegalArgumentException ( "isPropertyExist.table = null");

        if ( propertyExistVariable == null ) throw new IllegalArgumentException ( "isPropertyExist.propertyExistVariable = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "isPropertyExist.propertyName = null");
        table.add( GenericMasterFunctions.isPropertyExist(getWindow().getName(), getName(), propertyName, propertyExistVariable));
    }

    /*********** <pre>
             Verify if object's property exists or not.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property to verify.
              <BR/>         propertyExistVariable -- Optional:NO
             The variable to store 'true' or 'false' to indicate if the property exist or not.
              
    </UL>

     **********/
    public ComponentFunction isPropertyExist(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "isPropertyExist.parameters = null");
        return GenericMasterFunctions.isPropertyExist(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify if object's property exists or not.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property to verify.
              <BR/>         propertyExistVariable -- Optional:NO
             The variable to store 'true' or 'false' to indicate if the property exist or not.
              
    </UL>

     **********/
    public void isPropertyExist(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "isPropertyExist.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "isPropertyExist.parameters = null");
        table.add( GenericMasterFunctions.isPropertyExist(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
               Store the location and dimensions of a component.
              
               Store the location and dimensions of a component.
               The component can be SAFS IBT, RJ, Selenium object.
               The information is stored in a collection of variables using the variable root name provided. 
               
               The following variables are set by this command:
               
               
               rootname=x y w h [space delimited values]
               rootname.x=x
               rootname.y=y
               rootname.w=w
               rootname.h=h
               
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param variableName  Optional:NO
             The root name of the collection of variables to receive the location and dimensions.
              
     @param whomRelativeTo  Optional:YES  DefaultVal:screen
             This parameter decides the coordinates stored in VariableName is relative to the screen or the parent window.
             'screen' means they are relative to the screen; 'parent' means they are relative to the parent window.
             The parameter is curently available in RJ only. 
              
     **********/
    public ComponentFunction locateScreenImage(String variableName, String whomRelativeTo ) {

        if ( variableName == null ) throw new IllegalArgumentException ( "locateScreenImage.variableName = null");
        return GenericMasterFunctions.locateScreenImage(getWindow().getName(), getName(), variableName, whomRelativeTo);
    }

    /*********** <pre>
               Store the location and dimensions of a component.
              
               Store the location and dimensions of a component.
               The component can be SAFS IBT, RJ, Selenium object.
               The information is stored in a collection of variables using the variable root name provided. 
               
               The following variables are set by this command:
               
               
               rootname=x y w h [space delimited values]
               rootname.x=x
               rootname.y=y
               rootname.w=w
               rootname.h=h
               
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param variableName  Optional:NO
             The root name of the collection of variables to receive the location and dimensions.
              
     @param whomRelativeTo  Optional:YES  DefaultVal:screen
             This parameter decides the coordinates stored in VariableName is relative to the screen or the parent window.
             'screen' means they are relative to the screen; 'parent' means they are relative to the parent window.
             The parameter is curently available in RJ only. 
              
     **********/
    public void locateScreenImage(StepTestTable table, String variableName, String whomRelativeTo ) {

        if ( table == null ) throw new IllegalArgumentException ( "locateScreenImage.table = null");

        if ( variableName == null ) throw new IllegalArgumentException ( "locateScreenImage.variableName = null");
        table.add( GenericMasterFunctions.locateScreenImage(getWindow().getName(), getName(), variableName, whomRelativeTo));
    }

    /*********** <pre>
               Store the location and dimensions of a component.
              
               Store the location and dimensions of a component.
               The component can be SAFS IBT, RJ, Selenium object.
               The information is stored in a collection of variables using the variable root name provided. 
               
               The following variables are set by this command:
               
               
               rootname=x y w h [space delimited values]
               rootname.x=x
               rootname.y=y
               rootname.w=w
               rootname.h=h
               
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         variableName -- Optional:NO
             The root name of the collection of variables to receive the location and dimensions.
              <BR/>         whomRelativeTo -- Optional:YES  DefaultVal:screen
             This parameter decides the coordinates stored in VariableName is relative to the screen or the parent window.
             'screen' means they are relative to the screen; 'parent' means they are relative to the parent window.
             The parameter is curently available in RJ only. 
              
    </UL>

     **********/
    public ComponentFunction locateScreenImage(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "locateScreenImage.parameters = null");
        return GenericMasterFunctions.locateScreenImage(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
               Store the location and dimensions of a component.
              
               Store the location and dimensions of a component.
               The component can be SAFS IBT, RJ, Selenium object.
               The information is stored in a collection of variables using the variable root name provided. 
               
               The following variables are set by this command:
               
               
               rootname=x y w h [space delimited values]
               rootname.x=x
               rootname.y=y
               rootname.w=w
               rootname.h=h
               
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         variableName -- Optional:NO
             The root name of the collection of variables to receive the location and dimensions.
              <BR/>         whomRelativeTo -- Optional:YES  DefaultVal:screen
             This parameter decides the coordinates stored in VariableName is relative to the screen or the parent window.
             'screen' means they are relative to the screen; 'parent' means they are relative to the parent window.
             The parameter is curently available in RJ only. 
              
    </UL>

     **********/
    public void locateScreenImage(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "locateScreenImage.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "locateScreenImage.parameters = null");
        table.add( GenericMasterFunctions.locateScreenImage(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Incorporate OCR technology to detect the text on a GUI component and save the text to a text file.
             
             Two open-source OCRs are integrated into SAFS. One is TesseractOCR (TOCR) at 
             http://code.google.com/p/tesseract-ocr; the other GOCR at http://jocr.sourceforge.net. 
             
             TOCR 2.0.4 and GOCR 0.48 are the latest release. They are available in SAFS and only 
             support English. Both two OCR owners claim to support more languages in next release. Chinese, 
             Japanese, and Korean are going to be supported in TOCR's next release 3.00.
			
       	         </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param outputFile  Optional:NO
             The name of the text file used to store detected text.
              
     @param subArea  Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
             
     @param oCRId  Optional:YES
             OCRId indicating the OCR used to recognize text.
             
     @param langId  Optional:YES
             Optional LangId representing the language in use for selected OCR to recognize text. 
             
     @param scaleRatio  Optional:YES
             Optional ScaleRatio indicating the scale ratio for resizing the original image.
             
     **********/
    public ComponentFunction saveTextFromGUI(String outputFile, String subArea, String oCRId, String langId, String scaleRatio ) {

        if ( outputFile == null ) throw new IllegalArgumentException ( "saveTextFromGUI.outputFile = null");
        return GenericMasterFunctions.saveTextFromGUI(getWindow().getName(), getName(), outputFile, subArea, oCRId, langId, scaleRatio);
    }

    /*********** <pre>
             Incorporate OCR technology to detect the text on a GUI component and save the text to a text file.
             
             Two open-source OCRs are integrated into SAFS. One is TesseractOCR (TOCR) at 
             http://code.google.com/p/tesseract-ocr; the other GOCR at http://jocr.sourceforge.net. 
             
             TOCR 2.0.4 and GOCR 0.48 are the latest release. They are available in SAFS and only 
             support English. Both two OCR owners claim to support more languages in next release. Chinese, 
             Japanese, and Korean are going to be supported in TOCR's next release 3.00.
			
       	         </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param outputFile  Optional:NO
             The name of the text file used to store detected text.
              
     @param subArea  Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
             
     @param oCRId  Optional:YES
             OCRId indicating the OCR used to recognize text.
             
     @param langId  Optional:YES
             Optional LangId representing the language in use for selected OCR to recognize text. 
             
     @param scaleRatio  Optional:YES
             Optional ScaleRatio indicating the scale ratio for resizing the original image.
             
     **********/
    public void saveTextFromGUI(StepTestTable table, String outputFile, String subArea, String oCRId, String langId, String scaleRatio ) {

        if ( table == null ) throw new IllegalArgumentException ( "saveTextFromGUI.table = null");

        if ( outputFile == null ) throw new IllegalArgumentException ( "saveTextFromGUI.outputFile = null");
        table.add( GenericMasterFunctions.saveTextFromGUI(getWindow().getName(), getName(), outputFile, subArea, oCRId, langId, scaleRatio));
    }

    /*********** <pre>
             Incorporate OCR technology to detect the text on a GUI component and save the text to a text file.
             
             Two open-source OCRs are integrated into SAFS. One is TesseractOCR (TOCR) at 
             http://code.google.com/p/tesseract-ocr; the other GOCR at http://jocr.sourceforge.net. 
             
             TOCR 2.0.4 and GOCR 0.48 are the latest release. They are available in SAFS and only 
             support English. Both two OCR owners claim to support more languages in next release. Chinese, 
             Japanese, and Korean are going to be supported in TOCR's next release 3.00.
			
       	         </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         outputFile -- Optional:NO
             The name of the text file used to store detected text.
              <BR/>         subArea -- Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
             <BR/>         oCRId -- Optional:YES
             OCRId indicating the OCR used to recognize text.
             <BR/>         langId -- Optional:YES
             Optional LangId representing the language in use for selected OCR to recognize text. 
             <BR/>         scaleRatio -- Optional:YES
             Optional ScaleRatio indicating the scale ratio for resizing the original image.
             
    </UL>

     **********/
    public ComponentFunction saveTextFromGUI(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "saveTextFromGUI.parameters = null");
        return GenericMasterFunctions.saveTextFromGUI(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Incorporate OCR technology to detect the text on a GUI component and save the text to a text file.
             
             Two open-source OCRs are integrated into SAFS. One is TesseractOCR (TOCR) at 
             http://code.google.com/p/tesseract-ocr; the other GOCR at http://jocr.sourceforge.net. 
             
             TOCR 2.0.4 and GOCR 0.48 are the latest release. They are available in SAFS and only 
             support English. Both two OCR owners claim to support more languages in next release. Chinese, 
             Japanese, and Korean are going to be supported in TOCR's next release 3.00.
			
       	         </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         outputFile -- Optional:NO
             The name of the text file used to store detected text.
              <BR/>         subArea -- Optional:YES
             Optional app map subkey indicating partial image of the component to capture.
             <BR/>         oCRId -- Optional:YES
             OCRId indicating the OCR used to recognize text.
             <BR/>         langId -- Optional:YES
             Optional LangId representing the language in use for selected OCR to recognize text. 
             <BR/>         scaleRatio -- Optional:YES
             Optional ScaleRatio indicating the scale ratio for resizing the original image.
             
    </UL>

     **********/
    public void saveTextFromGUI(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "saveTextFromGUI.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "saveTextFromGUI.parameters = null");
        table.add( GenericMasterFunctions.saveTextFromGUI(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Send or trigger an "event" with 0 or more arguments.
             
             For objects or technologies that can be effectively event-driven, rather than GUI-driven.
             
             The first implementation is in IBM Rational Functional Tester for Flex testing.  Many Flex objects 
             respond to events, in addition to traditional GUI interaction.  Some Flex objects ONLY respond to 
             events.  This is especially true of many custom Flex delegates.
             
             The tester must know the events and arguments available for their particular object and technology. 
             The generic nature for this command cannot generally know if a particular event or set of 
             arguments is valid or not.  Thus, the implementation may not be able issue failures resulting from 
             invalid events, arguments, or other issues not generating recognizable failure conditions.
             
       	         </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param event  Optional:NO
             The potentially case-sensitive name of the event to send or trigger.
              
     @param pARAM_N  Optional:YES
             The first of 0 or more parameters needed for the event.
             
     **********/
    public ComponentFunction sendEvent(String event, String pARAM_N ) {

        if ( event == null ) throw new IllegalArgumentException ( "sendEvent.event = null");
        return GenericMasterFunctions.sendEvent(getWindow().getName(), getName(), event, pARAM_N);
    }

    /*********** <pre>
             Send or trigger an "event" with 0 or more arguments.
             
             For objects or technologies that can be effectively event-driven, rather than GUI-driven.
             
             The first implementation is in IBM Rational Functional Tester for Flex testing.  Many Flex objects 
             respond to events, in addition to traditional GUI interaction.  Some Flex objects ONLY respond to 
             events.  This is especially true of many custom Flex delegates.
             
             The tester must know the events and arguments available for their particular object and technology. 
             The generic nature for this command cannot generally know if a particular event or set of 
             arguments is valid or not.  Thus, the implementation may not be able issue failures resulting from 
             invalid events, arguments, or other issues not generating recognizable failure conditions.
             
       	         </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param event  Optional:NO
             The potentially case-sensitive name of the event to send or trigger.
              
     @param pARAM_N  Optional:YES
             The first of 0 or more parameters needed for the event.
             
     **********/
    public void sendEvent(StepTestTable table, String event, String pARAM_N ) {

        if ( table == null ) throw new IllegalArgumentException ( "sendEvent.table = null");

        if ( event == null ) throw new IllegalArgumentException ( "sendEvent.event = null");
        table.add( GenericMasterFunctions.sendEvent(getWindow().getName(), getName(), event, pARAM_N));
    }

    /*********** <pre>
             Send or trigger an "event" with 0 or more arguments.
             
             For objects or technologies that can be effectively event-driven, rather than GUI-driven.
             
             The first implementation is in IBM Rational Functional Tester for Flex testing.  Many Flex objects 
             respond to events, in addition to traditional GUI interaction.  Some Flex objects ONLY respond to 
             events.  This is especially true of many custom Flex delegates.
             
             The tester must know the events and arguments available for their particular object and technology. 
             The generic nature for this command cannot generally know if a particular event or set of 
             arguments is valid or not.  Thus, the implementation may not be able issue failures resulting from 
             invalid events, arguments, or other issues not generating recognizable failure conditions.
             
       	         </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         event -- Optional:NO
             The potentially case-sensitive name of the event to send or trigger.
              <BR/>         pARAM_N -- Optional:YES
             The first of 0 or more parameters needed for the event.
             
    </UL>

     **********/
    public ComponentFunction sendEvent(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "sendEvent.parameters = null");
        return GenericMasterFunctions.sendEvent(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Send or trigger an "event" with 0 or more arguments.
             
             For objects or technologies that can be effectively event-driven, rather than GUI-driven.
             
             The first implementation is in IBM Rational Functional Tester for Flex testing.  Many Flex objects 
             respond to events, in addition to traditional GUI interaction.  Some Flex objects ONLY respond to 
             events.  This is especially true of many custom Flex delegates.
             
             The tester must know the events and arguments available for their particular object and technology. 
             The generic nature for this command cannot generally know if a particular event or set of 
             arguments is valid or not.  Thus, the implementation may not be able issue failures resulting from 
             invalid events, arguments, or other issues not generating recognizable failure conditions.
             
       	         </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         event -- Optional:NO
             The potentially case-sensitive name of the event to send or trigger.
              <BR/>         pARAM_N -- Optional:YES
             The first of 0 or more parameters needed for the event.
             
    </UL>

     **********/
    public void sendEvent(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "sendEvent.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "sendEvent.parameters = null");
        table.add( GenericMasterFunctions.sendEvent(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Sets a value to the property of an object.
              
             Routine to set a value to the property of an object..
	     The routine expects that the given object already has Context or Focus.
		It also expects that Global StepDriverTestInfo contains all the information
		it needs to perform its function.
	     The routine will set the StepDriverTestInfo.statuscode and log any pass/fail info 
		using the StepDriverTestInfo.fac LogFacility.
		RJ implementation directly modifies the object in the software under test;therefore, it should be done with extreme care.
		Avoid using setPropertyValue whenever possible because it allows you to modify the software under test in ways that a typical user cannot.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param objectPropertyName  Optional:NO
             The name of the property of the object.
              
     @param propertyValue  Optional:NO
             The value to set the property to.
              
     **********/
    public ComponentFunction setPropertyValue(String objectPropertyName, String propertyValue ) {

        if ( objectPropertyName == null ) throw new IllegalArgumentException ( "setPropertyValue.objectPropertyName = null");
        if ( propertyValue == null ) throw new IllegalArgumentException ( "setPropertyValue.propertyValue = null");
        return GenericMasterFunctions.setPropertyValue(getWindow().getName(), getName(), objectPropertyName, propertyValue);
    }

    /*********** <pre>
             Sets a value to the property of an object.
              
             Routine to set a value to the property of an object..
	     The routine expects that the given object already has Context or Focus.
		It also expects that Global StepDriverTestInfo contains all the information
		it needs to perform its function.
	     The routine will set the StepDriverTestInfo.statuscode and log any pass/fail info 
		using the StepDriverTestInfo.fac LogFacility.
		RJ implementation directly modifies the object in the software under test;therefore, it should be done with extreme care.
		Avoid using setPropertyValue whenever possible because it allows you to modify the software under test in ways that a typical user cannot.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param objectPropertyName  Optional:NO
             The name of the property of the object.
              
     @param propertyValue  Optional:NO
             The value to set the property to.
              
     **********/
    public void setPropertyValue(StepTestTable table, String objectPropertyName, String propertyValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "setPropertyValue.table = null");

        if ( objectPropertyName == null ) throw new IllegalArgumentException ( "setPropertyValue.objectPropertyName = null");
        if ( propertyValue == null ) throw new IllegalArgumentException ( "setPropertyValue.propertyValue = null");
        table.add( GenericMasterFunctions.setPropertyValue(getWindow().getName(), getName(), objectPropertyName, propertyValue));
    }

    /*********** <pre>
             Sets a value to the property of an object.
              
             Routine to set a value to the property of an object..
	     The routine expects that the given object already has Context or Focus.
		It also expects that Global StepDriverTestInfo contains all the information
		it needs to perform its function.
	     The routine will set the StepDriverTestInfo.statuscode and log any pass/fail info 
		using the StepDriverTestInfo.fac LogFacility.
		RJ implementation directly modifies the object in the software under test;therefore, it should be done with extreme care.
		Avoid using setPropertyValue whenever possible because it allows you to modify the software under test in ways that a typical user cannot.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         objectPropertyName -- Optional:NO
             The name of the property of the object.
              <BR/>         propertyValue -- Optional:NO
             The value to set the property to.
              
    </UL>

     **********/
    public ComponentFunction setPropertyValue(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "setPropertyValue.parameters = null");
        return GenericMasterFunctions.setPropertyValue(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Sets a value to the property of an object.
              
             Routine to set a value to the property of an object..
	     The routine expects that the given object already has Context or Focus.
		It also expects that Global StepDriverTestInfo contains all the information
		it needs to perform its function.
	     The routine will set the StepDriverTestInfo.statuscode and log any pass/fail info 
		using the StepDriverTestInfo.fac LogFacility.
		RJ implementation directly modifies the object in the software under test;therefore, it should be done with extreme care.
		Avoid using setPropertyValue whenever possible because it allows you to modify the software under test in ways that a typical user cannot.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         objectPropertyName -- Optional:NO
             The name of the property of the object.
              <BR/>         propertyValue -- Optional:NO
             The value to set the property to.
              
    </UL>

     **********/
    public void setPropertyValue(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "setPropertyValue.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "setPropertyValue.parameters = null");
        table.add( GenericMasterFunctions.setPropertyValue(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Make the component visible on the page.
              
             Make the component visible on the page.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param verify  Optional:YES  DefaultVal:False"True" to verify that the component is shown on page.
     **********/
    public ComponentFunction showOnPage(String verify ) {

        return GenericMasterFunctions.showOnPage(getWindow().getName(), getName(), verify);
    }

    /*********** <pre>
             Make the component visible on the page.
              
             Make the component visible on the page.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param verify  Optional:YES  DefaultVal:False"True" to verify that the component is shown on page.
     **********/
    public void showOnPage(StepTestTable table, String verify ) {

        if ( table == null ) throw new IllegalArgumentException ( "showOnPage.table = null");

        table.add( GenericMasterFunctions.showOnPage(getWindow().getName(), getName(), verify));
    }

    /*********** <pre>
                Sends literal text keystrokes to whatever has keyboard focus.
              
                Sends literal text keystrokes to whatever has keyboard focus.
                The TypeChars command does not convert or interpret any special
                characters like InputKeys or TypeKeys do.
                
                No attempt is made to locate any specific window or component.  
                Keystrokes are simply sent to the system.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    <LI>Google Android</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param textValue  Optional:NO
                String of keystrokes to send.
              
     **********/
    public ComponentFunction typeChars(String textValue ) {

        if ( textValue == null ) throw new IllegalArgumentException ( "typeChars.textValue = null");
        return GenericMasterFunctions.typeChars(getWindow().getName(), getName(), textValue);
    }

    /*********** <pre>
                Sends literal text keystrokes to whatever has keyboard focus.
              
                Sends literal text keystrokes to whatever has keyboard focus.
                The TypeChars command does not convert or interpret any special
                characters like InputKeys or TypeKeys do.
                
                No attempt is made to locate any specific window or component.  
                Keystrokes are simply sent to the system.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    <LI>Google Android</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param textValue  Optional:NO
                String of keystrokes to send.
              
     **********/
    public void typeChars(StepTestTable table, String textValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "typeChars.table = null");

        if ( textValue == null ) throw new IllegalArgumentException ( "typeChars.textValue = null");
        table.add( GenericMasterFunctions.typeChars(getWindow().getName(), getName(), textValue));
    }

    /*********** <pre>
                Sends secret-text (such as password) to whatever has keyboard focus.
              
                User needs to provide the path to the "encrypted text" and the path
                to the "private key".
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param encryptedDataFile  Optional:NO
                The full path of the file where the "encrypted data" is stored.
              
     @param privateKeyFile  Optional:NO
                The full path of the file where the "private key" is stored.
              
     **********/
    public ComponentFunction typeEncryption(String encryptedDataFile, String privateKeyFile ) {

        if ( encryptedDataFile == null ) throw new IllegalArgumentException ( "typeEncryption.encryptedDataFile = null");
        if ( privateKeyFile == null ) throw new IllegalArgumentException ( "typeEncryption.privateKeyFile = null");
        return GenericMasterFunctions.typeEncryption(getWindow().getName(), getName(), encryptedDataFile, privateKeyFile);
    }

    /*********** <pre>
                Sends secret-text (such as password) to whatever has keyboard focus.
              
                User needs to provide the path to the "encrypted text" and the path
                to the "private key".
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param encryptedDataFile  Optional:NO
                The full path of the file where the "encrypted data" is stored.
              
     @param privateKeyFile  Optional:NO
                The full path of the file where the "private key" is stored.
              
     **********/
    public void typeEncryption(StepTestTable table, String encryptedDataFile, String privateKeyFile ) {

        if ( table == null ) throw new IllegalArgumentException ( "typeEncryption.table = null");

        if ( encryptedDataFile == null ) throw new IllegalArgumentException ( "typeEncryption.encryptedDataFile = null");
        if ( privateKeyFile == null ) throw new IllegalArgumentException ( "typeEncryption.privateKeyFile = null");
        table.add( GenericMasterFunctions.typeEncryption(getWindow().getName(), getName(), encryptedDataFile, privateKeyFile));
    }

    /*********** <pre>
                Sends secret-text (such as password) to whatever has keyboard focus.
              
                User needs to provide the path to the "encrypted text" and the path
                to the "private key".
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         encryptedDataFile -- Optional:NO
                The full path of the file where the "encrypted data" is stored.
              <BR/>         privateKeyFile -- Optional:NO
                The full path of the file where the "private key" is stored.
              
    </UL>

     **********/
    public ComponentFunction typeEncryption(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "typeEncryption.parameters = null");
        return GenericMasterFunctions.typeEncryption(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
                Sends secret-text (such as password) to whatever has keyboard focus.
              
                User needs to provide the path to the "encrypted text" and the path
                to the "private key".
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         encryptedDataFile -- Optional:NO
                The full path of the file where the "encrypted data" is stored.
              <BR/>         privateKeyFile -- Optional:NO
                The full path of the file where the "private key" is stored.
              
    </UL>

     **********/
    public void typeEncryption(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "typeEncryption.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "typeEncryption.parameters = null");
        table.add( GenericMasterFunctions.typeEncryption(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
                Sends keystrokes to whatever has keyboard focus.
              
                Sends keystrokes to whatever has keyboard focus.
                
                No attempt is made to locate any specific window or component.  
                Keystrokes are simply sent to the system.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    <LI>Google Android</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param textValue  Optional:NO
                String of keystrokes to send.
              
     **********/
    public ComponentFunction typeKeys(String textValue ) {

        if ( textValue == null ) throw new IllegalArgumentException ( "typeKeys.textValue = null");
        return GenericMasterFunctions.typeKeys(getWindow().getName(), getName(), textValue);
    }

    /*********** <pre>
                Sends keystrokes to whatever has keyboard focus.
              
                Sends keystrokes to whatever has keyboard focus.
                
                No attempt is made to locate any specific window or component.  
                Keystrokes are simply sent to the system.
                
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    <LI>Google Android</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param textValue  Optional:NO
                String of keystrokes to send.
              
     **********/
    public void typeKeys(StepTestTable table, String textValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "typeKeys.table = null");

        if ( textValue == null ) throw new IllegalArgumentException ( "typeKeys.textValue = null");
        table.add( GenericMasterFunctions.typeKeys(getWindow().getName(), getName(), textValue));
    }

    /*********** <pre>
             Verify the value of an array property with a benchmark file
              
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
             
             Note: for RobotJ,Suggest to use RFT Inspector to confirm which property should be used. There are two examples:
				 
					 For Java swing List and ComboBox items can be fetchedusing the '.itemText' property (Note the dot)
					 For Html List (type is html.select) items can be fetchedusing the '.text' property (Note the dot)
				 
			
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param propertyName  Optional:NO
             The case-sensitive name of the object array property to verify.
              
     @param benchmarkFile  Optional:NO
             The name of the file used as the comparison benchmark.
              
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public ComponentFunction verifyArrayPropertyToFile(String propertyName, String benchmarkFile, String filterMode, String filterOptions ) {

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyArrayPropertyToFile.benchmarkFile = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "verifyArrayPropertyToFile.propertyName = null");
        return GenericMasterFunctions.verifyArrayPropertyToFile(getWindow().getName(), getName(), propertyName, benchmarkFile, filterMode, filterOptions);
    }

    /*********** <pre>
             Verify the value of an array property with a benchmark file
              
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
             
             Note: for RobotJ,Suggest to use RFT Inspector to confirm which property should be used. There are two examples:
				 
					 For Java swing List and ComboBox items can be fetchedusing the '.itemText' property (Note the dot)
					 For Html List (type is html.select) items can be fetchedusing the '.text' property (Note the dot)
				 
			
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param propertyName  Optional:NO
             The case-sensitive name of the object array property to verify.
              
     @param benchmarkFile  Optional:NO
             The name of the file used as the comparison benchmark.
              
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public void verifyArrayPropertyToFile(StepTestTable table, String propertyName, String benchmarkFile, String filterMode, String filterOptions ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyArrayPropertyToFile.table = null");

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyArrayPropertyToFile.benchmarkFile = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "verifyArrayPropertyToFile.propertyName = null");
        table.add( GenericMasterFunctions.verifyArrayPropertyToFile(getWindow().getName(), getName(), propertyName, benchmarkFile, filterMode, filterOptions));
    }

    /*********** <pre>
             Verify the value of an array property with a benchmark file
              
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
             
             Note: for RobotJ,Suggest to use RFT Inspector to confirm which property should be used. There are two examples:
				 
					 For Java swing List and ComboBox items can be fetchedusing the '.itemText' property (Note the dot)
					 For Html List (type is html.select) items can be fetchedusing the '.text' property (Note the dot)
				 
			
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object array property to verify.
              <BR/>         benchmarkFile -- Optional:NO
             The name of the file used as the comparison benchmark.
              <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public ComponentFunction verifyArrayPropertyToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyArrayPropertyToFile.parameters = null");
        return GenericMasterFunctions.verifyArrayPropertyToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify the value of an array property with a benchmark file
              
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
             
             Note: for RobotJ,Suggest to use RFT Inspector to confirm which property should be used. There are two examples:
				 
					 For Java swing List and ComboBox items can be fetchedusing the '.itemText' property (Note the dot)
					 For Html List (type is html.select) items can be fetchedusing the '.text' property (Note the dot)
				 
			
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object array property to verify.
              <BR/>         benchmarkFile -- Optional:NO
             The name of the file used as the comparison benchmark.
              <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public void verifyArrayPropertyToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyArrayPropertyToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyArrayPropertyToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyArrayPropertyToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre> 
             Verify the current contents of a binary file with a benchmark file.
              
             Verify the current contents of a binary file with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param benchmarkFile  Optional:NO 
             File used as the comparison benchmark.
              
     @param actualFile  Optional:NO 
             File used as the comparison file under test.
              
     @param filterMode  Optional:YES  DefaultVal: 
                Specify a filter to use to process the file content before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal: 
                Specify filter options to use with the filter.
              
     **********/
    public ComponentFunction verifyBinaryFileToFile(String benchmarkFile, String actualFile, String filterMode, String filterOptions ) {

        if ( actualFile == null ) throw new IllegalArgumentException ( "verifyBinaryFileToFile.actualFile = null");
        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyBinaryFileToFile.benchmarkFile = null");
        return GenericMasterFunctions.verifyBinaryFileToFile(getWindow().getName(), getName(), benchmarkFile, actualFile, filterMode, filterOptions);
    }

    /*********** <pre> 
             Verify the current contents of a binary file with a benchmark file.
              
             Verify the current contents of a binary file with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchmarkFile  Optional:NO 
             File used as the comparison benchmark.
              
     @param actualFile  Optional:NO 
             File used as the comparison file under test.
              
     @param filterMode  Optional:YES  DefaultVal: 
                Specify a filter to use to process the file content before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal: 
                Specify filter options to use with the filter.
              
     **********/
    public void verifyBinaryFileToFile(StepTestTable table, String benchmarkFile, String actualFile, String filterMode, String filterOptions ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyBinaryFileToFile.table = null");

        if ( actualFile == null ) throw new IllegalArgumentException ( "verifyBinaryFileToFile.actualFile = null");
        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyBinaryFileToFile.benchmarkFile = null");
        table.add( GenericMasterFunctions.verifyBinaryFileToFile(getWindow().getName(), getName(), benchmarkFile, actualFile, filterMode, filterOptions));
    }

    /*********** <pre> 
             Verify the current contents of a binary file with a benchmark file.
              
             Verify the current contents of a binary file with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO 
             File used as the comparison benchmark.
              <BR/>         actualFile -- Optional:NO 
             File used as the comparison file under test.
              <BR/>         filterMode -- Optional:YES  DefaultVal: 
                Specify a filter to use to process the file content before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal: 
                Specify filter options to use with the filter.
              
    </UL>

     **********/
    public ComponentFunction verifyBinaryFileToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyBinaryFileToFile.parameters = null");
        return GenericMasterFunctions.verifyBinaryFileToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
             Verify the current contents of a binary file with a benchmark file.
              
             Verify the current contents of a binary file with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO 
             File used as the comparison benchmark.
              <BR/>         actualFile -- Optional:NO 
             File used as the comparison file under test.
              <BR/>         filterMode -- Optional:YES  DefaultVal: 
                Specify a filter to use to process the file content before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal: 
                Specify filter options to use with the filter.
              
    </UL>

     **********/
    public void verifyBinaryFileToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyBinaryFileToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyBinaryFileToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyBinaryFileToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify the current contents of the Windows clipboard with a benchmark file.
              
             Verify the current contents of the Windows clipboard with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.  
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param benchmarkFile  Optional:NO
             The name of the file used as the comparison benchmark.
              
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public ComponentFunction verifyClipboardToFile(String benchmarkFile, String filterMode, String filterOptions ) {

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyClipboardToFile.benchmarkFile = null");
        return GenericMasterFunctions.verifyClipboardToFile(getWindow().getName(), getName(), benchmarkFile, filterMode, filterOptions);
    }

    /*********** <pre>
             Verify the current contents of the Windows clipboard with a benchmark file.
              
             Verify the current contents of the Windows clipboard with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.  
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchmarkFile  Optional:NO
             The name of the file used as the comparison benchmark.
              
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public void verifyClipboardToFile(StepTestTable table, String benchmarkFile, String filterMode, String filterOptions ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyClipboardToFile.table = null");

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyClipboardToFile.benchmarkFile = null");
        table.add( GenericMasterFunctions.verifyClipboardToFile(getWindow().getName(), getName(), benchmarkFile, filterMode, filterOptions));
    }

    /*********** <pre>
             Verify the current contents of the Windows clipboard with a benchmark file.
              
             Verify the current contents of the Windows clipboard with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.  
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO
             The name of the file used as the comparison benchmark.
              <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public ComponentFunction verifyClipboardToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyClipboardToFile.parameters = null");
        return GenericMasterFunctions.verifyClipboardToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify the current contents of the Windows clipboard with a benchmark file.
              
             Verify the current contents of the Windows clipboard with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.  
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO
             The name of the file used as the comparison benchmark.
              <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public void verifyClipboardToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyClipboardToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyClipboardToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyClipboardToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
               Verify the current contents of the Windows clipboard using a Robot ClipboardVP.
              
               Verify the current contents of the Windows clipboard using a Robot ClipboardVP.
               The benchmark VP must already exist as an asset of the currently running script.
               
               If the provided VP is NOT a reference in the AppMap then a standard VP compare
               will occur with the typical VP parameter value like "VP=StoredVP".
               However, if you wish to modify the ClipboardVP parameter values, such as
               specifying that the expected result = FAIL, then you must make an entry
               in the AppMap under the Component name to provide these modified parameters.
               
               The Window and Component objects are not validated and normally have no role.
               The Window and Component strings can normally be any text, but they cannot be blank.
               However, the Component must be a valid section in the AppMap if we wish to store
               modified VP parameter settings.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param vPName  Optional:NO
             The name of the ClipboardVP from the currently running script.
              
     **********/
    public ComponentFunction verifyClipboardVP(String vPName ) {

        if ( vPName == null ) throw new IllegalArgumentException ( "verifyClipboardVP.vPName = null");
        return GenericMasterFunctions.verifyClipboardVP(getWindow().getName(), getName(), vPName);
    }

    /*********** <pre>
               Verify the current contents of the Windows clipboard using a Robot ClipboardVP.
              
               Verify the current contents of the Windows clipboard using a Robot ClipboardVP.
               The benchmark VP must already exist as an asset of the currently running script.
               
               If the provided VP is NOT a reference in the AppMap then a standard VP compare
               will occur with the typical VP parameter value like "VP=StoredVP".
               However, if you wish to modify the ClipboardVP parameter values, such as
               specifying that the expected result = FAIL, then you must make an entry
               in the AppMap under the Component name to provide these modified parameters.
               
               The Window and Component objects are not validated and normally have no role.
               The Window and Component strings can normally be any text, but they cannot be blank.
               However, the Component must be a valid section in the AppMap if we wish to store
               modified VP parameter settings.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param vPName  Optional:NO
             The name of the ClipboardVP from the currently running script.
              
     **********/
    public void verifyClipboardVP(StepTestTable table, String vPName ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyClipboardVP.table = null");

        if ( vPName == null ) throw new IllegalArgumentException ( "verifyClipboardVP.vPName = null");
        table.add( GenericMasterFunctions.verifyClipboardVP(getWindow().getName(), getName(), vPName));
    }

    /*********** <pre>
                Verify a component's 'computed style' against a benchmark file.
              
                Verify a component's 'computed style' against a benchmark file.
                If the comparison fails, a copy of the captured 'computed style' should be stored in 
                the project's Test directory.  This file, once verified, should be suitable to become a 
                new benchmark, if needed.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param benchFile  Optional:NO
                The benchmake file to compare against.
              
     **********/
    public ComponentFunction verifyComputedStyle(String benchFile ) {

        if ( benchFile == null ) throw new IllegalArgumentException ( "verifyComputedStyle.benchFile = null");
        return GenericMasterFunctions.verifyComputedStyle(getWindow().getName(), getName(), benchFile);
    }

    /*********** <pre>
                Verify a component's 'computed style' against a benchmark file.
              
                Verify a component's 'computed style' against a benchmark file.
                If the comparison fails, a copy of the captured 'computed style' should be stored in 
                the project's Test directory.  This file, once verified, should be suitable to become a 
                new benchmark, if needed.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchFile  Optional:NO
                The benchmake file to compare against.
              
     **********/
    public void verifyComputedStyle(StepTestTable table, String benchFile ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyComputedStyle.table = null");

        if ( benchFile == null ) throw new IllegalArgumentException ( "verifyComputedStyle.benchFile = null");
        table.add( GenericMasterFunctions.verifyComputedStyle(getWindow().getName(), getName(), benchFile));
    }

    /*********** <pre> 
             Verify the current contents of a text file with a benchmark file (same as VerifyTextFileToFile).
              
             Verify the current contents of a text file with a benchmark file (same as VerifyTextFileToFile).
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param benchmarkFile  Optional:NO 
             File used as the comparison benchmark.
              
     @param actualFile  Optional:NO 
             File used as the comparison file under test.
              
     @param filterMode  Optional:YES  DefaultVal: 
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal: 
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public ComponentFunction verifyFileToFile(String benchmarkFile, String actualFile, String filterMode, String filterOptions ) {

        if ( actualFile == null ) throw new IllegalArgumentException ( "verifyFileToFile.actualFile = null");
        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyFileToFile.benchmarkFile = null");
        return GenericMasterFunctions.verifyFileToFile(getWindow().getName(), getName(), benchmarkFile, actualFile, filterMode, filterOptions);
    }

    /*********** <pre> 
             Verify the current contents of a text file with a benchmark file (same as VerifyTextFileToFile).
              
             Verify the current contents of a text file with a benchmark file (same as VerifyTextFileToFile).
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchmarkFile  Optional:NO 
             File used as the comparison benchmark.
              
     @param actualFile  Optional:NO 
             File used as the comparison file under test.
              
     @param filterMode  Optional:YES  DefaultVal: 
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal: 
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public void verifyFileToFile(StepTestTable table, String benchmarkFile, String actualFile, String filterMode, String filterOptions ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyFileToFile.table = null");

        if ( actualFile == null ) throw new IllegalArgumentException ( "verifyFileToFile.actualFile = null");
        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyFileToFile.benchmarkFile = null");
        table.add( GenericMasterFunctions.verifyFileToFile(getWindow().getName(), getName(), benchmarkFile, actualFile, filterMode, filterOptions));
    }

    /*********** <pre> 
             Verify the current contents of a text file with a benchmark file (same as VerifyTextFileToFile).
              
             Verify the current contents of a text file with a benchmark file (same as VerifyTextFileToFile).
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO 
             File used as the comparison benchmark.
              <BR/>         actualFile -- Optional:NO 
             File used as the comparison file under test.
              <BR/>         filterMode -- Optional:YES  DefaultVal: 
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal: 
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public ComponentFunction verifyFileToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyFileToFile.parameters = null");
        return GenericMasterFunctions.verifyFileToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
             Verify the current contents of a text file with a benchmark file (same as VerifyTextFileToFile).
              
             Verify the current contents of a text file with a benchmark file (same as VerifyTextFileToFile).
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO 
             File used as the comparison benchmark.
              <BR/>         actualFile -- Optional:NO 
             File used as the comparison file under test.
              <BR/>         filterMode -- Optional:YES  DefaultVal: 
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal: 
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public void verifyFileToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyFileToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyFileToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyFileToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
               Verify the screen shot of a GUI component with a benchmark image file
              
               Verify the screen shot of a GUI component with a benchmark image file.
               The benchmark file must reside in the <project>\Datapool\Bench folder.
               Only BMP and JPG files can be used as the benchmark. If the extension
               of the bench file is not BMP or JPG, it is considered a BMP file.  
               For RJ and IBT engine, other formats like TIFF (*.tif), GIF (*.gif), 
               PNG (*.png) and PNM (*.pnm) are also supported.
               Optionally the user can specify part of the component to verify.
               The specified GUI component/part must be in the viewing range of its 
               containing window. If portion of the component is displayed in the 
               window, only that portion will be captured; if the component falls 
               completely out of the viewing range of the window, the command will 
               fail. The command makes no attemp to bring the component into view.
             
             NOTE: the command may fail to execute if the user has turned off logging 
             to TestManager via the Robot tools setting.  You may have to enable TestManager
             logging for the command to successfully execute.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
             
	    This command requires that TestManager Image Comparator tool is
	    installed on the machine. Machines having only the Robot Test Agent
	    installed will not be able to usee this command.
             
               
               RobotJ (RJ) and IBT Specific Notes:
               		1)It requires that Java Advanced Imaging (JAI) be installed
               		on the test machine
               		2)It supports to save image in format TIFF (*.tif), GIF (*.gif), PNG (*.png)
               		and PNM (*.pnm) 
               
               
               Apple IOS specific Notes:
               UIAutomation captures all screenshots as PNG images, but SAFS copies and stores them 
               into the image format desired (JPG, BMP, etc.). However, the rootname of the desired 
               output image name must be unique to avoid UIAutomation generating indexed image names 
               we will not be looking for.
               For example, specifying MyImage.JPG and later MyImage.BMP will cause UIAutomation to capture 
               MyImage.PNG and MyImage1.PNG. When attempting to find MyImage.PNG captured for MyImage.BMP 
               we will retrieve MyImage.PNG which is NOT the correct image capture for MyImage.BMP.
               
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param benchmarkFile  Optional:NO
             Name of the benchmark image file.
              
     @param subArea  Optional:YES
             Optional app map subkey indicating partial image of the component to verify.
              
     @param percentageTolerance  Optional:YES
             The percentage of bits need to be matched.
              
     @param uUIDFlag  Optional:YES
             "UUID=False" to make Test/Actuals Filenames the same as the Benchmark.
              
     @param filteredAreas  Optional:YES
              "Filter=one or multiple areas" to filter the GUI image (or sub image of GUI if the parameter "SubArea" is present)
              and it will also be used to filter the bench image before comparing. If there are some differences, the diff image
              will be made between these 2 filtered images (not the acutal and bench image).
             
     **********/
    public ComponentFunction verifyGUIImageToFile(String benchmarkFile, String subArea, String percentageTolerance, String uUIDFlag, String filteredAreas ) {

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyGUIImageToFile.benchmarkFile = null");
        return GenericMasterFunctions.verifyGUIImageToFile(getWindow().getName(), getName(), benchmarkFile, subArea, percentageTolerance, uUIDFlag, filteredAreas);
    }

    /*********** <pre>
               Verify the screen shot of a GUI component with a benchmark image file
              
               Verify the screen shot of a GUI component with a benchmark image file.
               The benchmark file must reside in the <project>\Datapool\Bench folder.
               Only BMP and JPG files can be used as the benchmark. If the extension
               of the bench file is not BMP or JPG, it is considered a BMP file.  
               For RJ and IBT engine, other formats like TIFF (*.tif), GIF (*.gif), 
               PNG (*.png) and PNM (*.pnm) are also supported.
               Optionally the user can specify part of the component to verify.
               The specified GUI component/part must be in the viewing range of its 
               containing window. If portion of the component is displayed in the 
               window, only that portion will be captured; if the component falls 
               completely out of the viewing range of the window, the command will 
               fail. The command makes no attemp to bring the component into view.
             
             NOTE: the command may fail to execute if the user has turned off logging 
             to TestManager via the Robot tools setting.  You may have to enable TestManager
             logging for the command to successfully execute.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
             
	    This command requires that TestManager Image Comparator tool is
	    installed on the machine. Machines having only the Robot Test Agent
	    installed will not be able to usee this command.
             
               
               RobotJ (RJ) and IBT Specific Notes:
               		1)It requires that Java Advanced Imaging (JAI) be installed
               		on the test machine
               		2)It supports to save image in format TIFF (*.tif), GIF (*.gif), PNG (*.png)
               		and PNM (*.pnm) 
               
               
               Apple IOS specific Notes:
               UIAutomation captures all screenshots as PNG images, but SAFS copies and stores them 
               into the image format desired (JPG, BMP, etc.). However, the rootname of the desired 
               output image name must be unique to avoid UIAutomation generating indexed image names 
               we will not be looking for.
               For example, specifying MyImage.JPG and later MyImage.BMP will cause UIAutomation to capture 
               MyImage.PNG and MyImage1.PNG. When attempting to find MyImage.PNG captured for MyImage.BMP 
               we will retrieve MyImage.PNG which is NOT the correct image capture for MyImage.BMP.
               
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchmarkFile  Optional:NO
             Name of the benchmark image file.
              
     @param subArea  Optional:YES
             Optional app map subkey indicating partial image of the component to verify.
              
     @param percentageTolerance  Optional:YES
             The percentage of bits need to be matched.
              
     @param uUIDFlag  Optional:YES
             "UUID=False" to make Test/Actuals Filenames the same as the Benchmark.
              
     @param filteredAreas  Optional:YES
              "Filter=one or multiple areas" to filter the GUI image (or sub image of GUI if the parameter "SubArea" is present)
              and it will also be used to filter the bench image before comparing. If there are some differences, the diff image
              will be made between these 2 filtered images (not the acutal and bench image).
             
     **********/
    public void verifyGUIImageToFile(StepTestTable table, String benchmarkFile, String subArea, String percentageTolerance, String uUIDFlag, String filteredAreas ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyGUIImageToFile.table = null");

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyGUIImageToFile.benchmarkFile = null");
        table.add( GenericMasterFunctions.verifyGUIImageToFile(getWindow().getName(), getName(), benchmarkFile, subArea, percentageTolerance, uUIDFlag, filteredAreas));
    }

    /*********** <pre>
               Verify the screen shot of a GUI component with a benchmark image file
              
               Verify the screen shot of a GUI component with a benchmark image file.
               The benchmark file must reside in the <project>\Datapool\Bench folder.
               Only BMP and JPG files can be used as the benchmark. If the extension
               of the bench file is not BMP or JPG, it is considered a BMP file.  
               For RJ and IBT engine, other formats like TIFF (*.tif), GIF (*.gif), 
               PNG (*.png) and PNM (*.pnm) are also supported.
               Optionally the user can specify part of the component to verify.
               The specified GUI component/part must be in the viewing range of its 
               containing window. If portion of the component is displayed in the 
               window, only that portion will be captured; if the component falls 
               completely out of the viewing range of the window, the command will 
               fail. The command makes no attemp to bring the component into view.
             
             NOTE: the command may fail to execute if the user has turned off logging 
             to TestManager via the Robot tools setting.  You may have to enable TestManager
             logging for the command to successfully execute.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
             
	    This command requires that TestManager Image Comparator tool is
	    installed on the machine. Machines having only the Robot Test Agent
	    installed will not be able to usee this command.
             
               
               RobotJ (RJ) and IBT Specific Notes:
               		1)It requires that Java Advanced Imaging (JAI) be installed
               		on the test machine
               		2)It supports to save image in format TIFF (*.tif), GIF (*.gif), PNG (*.png)
               		and PNM (*.pnm) 
               
               
               Apple IOS specific Notes:
               UIAutomation captures all screenshots as PNG images, but SAFS copies and stores them 
               into the image format desired (JPG, BMP, etc.). However, the rootname of the desired 
               output image name must be unique to avoid UIAutomation generating indexed image names 
               we will not be looking for.
               For example, specifying MyImage.JPG and later MyImage.BMP will cause UIAutomation to capture 
               MyImage.PNG and MyImage1.PNG. When attempting to find MyImage.PNG captured for MyImage.BMP 
               we will retrieve MyImage.PNG which is NOT the correct image capture for MyImage.BMP.
               
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO
             Name of the benchmark image file.
              <BR/>         subArea -- Optional:YES
             Optional app map subkey indicating partial image of the component to verify.
              <BR/>         percentageTolerance -- Optional:YES
             The percentage of bits need to be matched.
              <BR/>         uUIDFlag -- Optional:YES
             "UUID=False" to make Test/Actuals Filenames the same as the Benchmark.
              <BR/>         filteredAreas -- Optional:YES
              "Filter=one or multiple areas" to filter the GUI image (or sub image of GUI if the parameter "SubArea" is present)
              and it will also be used to filter the bench image before comparing. If there are some differences, the diff image
              will be made between these 2 filtered images (not the acutal and bench image).
             
    </UL>

     **********/
    public ComponentFunction verifyGUIImageToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyGUIImageToFile.parameters = null");
        return GenericMasterFunctions.verifyGUIImageToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
               Verify the screen shot of a GUI component with a benchmark image file
              
               Verify the screen shot of a GUI component with a benchmark image file.
               The benchmark file must reside in the <project>\Datapool\Bench folder.
               Only BMP and JPG files can be used as the benchmark. If the extension
               of the bench file is not BMP or JPG, it is considered a BMP file.  
               For RJ and IBT engine, other formats like TIFF (*.tif), GIF (*.gif), 
               PNG (*.png) and PNM (*.pnm) are also supported.
               Optionally the user can specify part of the component to verify.
               The specified GUI component/part must be in the viewing range of its 
               containing window. If portion of the component is displayed in the 
               window, only that portion will be captured; if the component falls 
               completely out of the viewing range of the window, the command will 
               fail. The command makes no attemp to bring the component into view.
             
             NOTE: the command may fail to execute if the user has turned off logging 
             to TestManager via the Robot tools setting.  You may have to enable TestManager
             logging for the command to successfully execute.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
             
	    This command requires that TestManager Image Comparator tool is
	    installed on the machine. Machines having only the Robot Test Agent
	    installed will not be able to usee this command.
             
               
               RobotJ (RJ) and IBT Specific Notes:
               		1)It requires that Java Advanced Imaging (JAI) be installed
               		on the test machine
               		2)It supports to save image in format TIFF (*.tif), GIF (*.gif), PNG (*.png)
               		and PNM (*.pnm) 
               
               
               Apple IOS specific Notes:
               UIAutomation captures all screenshots as PNG images, but SAFS copies and stores them 
               into the image format desired (JPG, BMP, etc.). However, the rootname of the desired 
               output image name must be unique to avoid UIAutomation generating indexed image names 
               we will not be looking for.
               For example, specifying MyImage.JPG and later MyImage.BMP will cause UIAutomation to capture 
               MyImage.PNG and MyImage1.PNG. When attempting to find MyImage.PNG captured for MyImage.BMP 
               we will retrieve MyImage.PNG which is NOT the correct image capture for MyImage.BMP.
               
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO
             Name of the benchmark image file.
              <BR/>         subArea -- Optional:YES
             Optional app map subkey indicating partial image of the component to verify.
              <BR/>         percentageTolerance -- Optional:YES
             The percentage of bits need to be matched.
              <BR/>         uUIDFlag -- Optional:YES
             "UUID=False" to make Test/Actuals Filenames the same as the Benchmark.
              <BR/>         filteredAreas -- Optional:YES
              "Filter=one or multiple areas" to filter the GUI image (or sub image of GUI if the parameter "SubArea" is present)
              and it will also be used to filter the bench image before comparing. If there are some differences, the diff image
              will be made between these 2 filtered images (not the acutal and bench image).
             
    </UL>

     **********/
    public void verifyGUIImageToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyGUIImageToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyGUIImageToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyGUIImageToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify the current contents of an object's data with a benchmark file.
              
             
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  Only an object that 
             Robot can perform an ObjectData VP on can use this command.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param benchmarkFile  Optional:NO
             The name of the file used as the comparison benchmark.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when opening a bench file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public ComponentFunction verifyObjectDataToFile(String benchmarkFile, String fileEncoding, String filterMode, String filterOptions ) {

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyObjectDataToFile.benchmarkFile = null");
        return GenericMasterFunctions.verifyObjectDataToFile(getWindow().getName(), getName(), benchmarkFile, fileEncoding, filterMode, filterOptions);
    }

    /*********** <pre>
             Verify the current contents of an object's data with a benchmark file.
              
             
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  Only an object that 
             Robot can perform an ObjectData VP on can use this command.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchmarkFile  Optional:NO
             The name of the file used as the comparison benchmark.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when opening a bench file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public void verifyObjectDataToFile(StepTestTable table, String benchmarkFile, String fileEncoding, String filterMode, String filterOptions ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyObjectDataToFile.table = null");

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyObjectDataToFile.benchmarkFile = null");
        table.add( GenericMasterFunctions.verifyObjectDataToFile(getWindow().getName(), getName(), benchmarkFile, fileEncoding, filterMode, filterOptions));
    }

    /*********** <pre>
             Verify the current contents of an object's data with a benchmark file.
              
             
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  Only an object that 
             Robot can perform an ObjectData VP on can use this command.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO
             The name of the file used as the comparison benchmark.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when opening a bench file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public ComponentFunction verifyObjectDataToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyObjectDataToFile.parameters = null");
        return GenericMasterFunctions.verifyObjectDataToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify the current contents of an object's data with a benchmark file.
              
             
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  Only an object that 
             Robot can perform an ObjectData VP on can use this command.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO
             The name of the file used as the comparison benchmark.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when opening a bench file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public void verifyObjectDataToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyObjectDataToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyObjectDataToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyObjectDataToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Compare/Verify the subset of properties of a test object with the values stored in a benchmark file.
              
             Compare/Verify the subset of properties of a test object with the values stored in a benchmark file.
             Only the properties stored in the benchmark are compared against the properties of the test object.
             The benchmark file is expected to be stored in the active "Bench" directory.  
             If you specify a relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param benchFile  Optional:NO
             The name of the file used to store the benchmark property data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when loading data from the file.
             
     **********/
    public ComponentFunction verifyPropertiesSubsetToFile(String benchFile, String fileEncoding ) {

        if ( benchFile == null ) throw new IllegalArgumentException ( "verifyPropertiesSubsetToFile.benchFile = null");
        return GenericMasterFunctions.verifyPropertiesSubsetToFile(getWindow().getName(), getName(), benchFile, fileEncoding);
    }

    /*********** <pre>
             Compare/Verify the subset of properties of a test object with the values stored in a benchmark file.
              
             Compare/Verify the subset of properties of a test object with the values stored in a benchmark file.
             Only the properties stored in the benchmark are compared against the properties of the test object.
             The benchmark file is expected to be stored in the active "Bench" directory.  
             If you specify a relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchFile  Optional:NO
             The name of the file used to store the benchmark property data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when loading data from the file.
             
     **********/
    public void verifyPropertiesSubsetToFile(StepTestTable table, String benchFile, String fileEncoding ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyPropertiesSubsetToFile.table = null");

        if ( benchFile == null ) throw new IllegalArgumentException ( "verifyPropertiesSubsetToFile.benchFile = null");
        table.add( GenericMasterFunctions.verifyPropertiesSubsetToFile(getWindow().getName(), getName(), benchFile, fileEncoding));
    }

    /*********** <pre>
             Compare/Verify the subset of properties of a test object with the values stored in a benchmark file.
              
             Compare/Verify the subset of properties of a test object with the values stored in a benchmark file.
             Only the properties stored in the benchmark are compared against the properties of the test object.
             The benchmark file is expected to be stored in the active "Bench" directory.  
             If you specify a relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchFile -- Optional:NO
             The name of the file used to store the benchmark property data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when loading data from the file.
             
    </UL>

     **********/
    public ComponentFunction verifyPropertiesSubsetToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyPropertiesSubsetToFile.parameters = null");
        return GenericMasterFunctions.verifyPropertiesSubsetToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Compare/Verify the subset of properties of a test object with the values stored in a benchmark file.
              
             Compare/Verify the subset of properties of a test object with the values stored in a benchmark file.
             Only the properties stored in the benchmark are compared against the properties of the test object.
             The benchmark file is expected to be stored in the active "Bench" directory.  
             If you specify a relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchFile -- Optional:NO
             The name of the file used to store the benchmark property data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when loading data from the file.
             
    </UL>

     **********/
    public void verifyPropertiesSubsetToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyPropertiesSubsetToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyPropertiesSubsetToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyPropertiesSubsetToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Compare/Verify ALL of the value properties of a test object with a benchmark file.
              
             Compare/Verify all of the value properties of a test object with a benchmark file.
             The benchmark file is expected to be stored in the active "Bench" directory.  
             If you specify a relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    <LI>Google Android</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param benchFile  Optional:NO
             The name of the file used to store the benchmark property data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when loading data from the file.
             
     **********/
    public ComponentFunction verifyPropertiesToFile(String benchFile, String fileEncoding ) {

        if ( benchFile == null ) throw new IllegalArgumentException ( "verifyPropertiesToFile.benchFile = null");
        return GenericMasterFunctions.verifyPropertiesToFile(getWindow().getName(), getName(), benchFile, fileEncoding);
    }

    /*********** <pre>
             Compare/Verify ALL of the value properties of a test object with a benchmark file.
              
             Compare/Verify all of the value properties of a test object with a benchmark file.
             The benchmark file is expected to be stored in the active "Bench" directory.  
             If you specify a relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    <LI>Google Android</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchFile  Optional:NO
             The name of the file used to store the benchmark property data.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when loading data from the file.
             
     **********/
    public void verifyPropertiesToFile(StepTestTable table, String benchFile, String fileEncoding ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyPropertiesToFile.table = null");

        if ( benchFile == null ) throw new IllegalArgumentException ( "verifyPropertiesToFile.benchFile = null");
        table.add( GenericMasterFunctions.verifyPropertiesToFile(getWindow().getName(), getName(), benchFile, fileEncoding));
    }

    /*********** <pre>
             Compare/Verify ALL of the value properties of a test object with a benchmark file.
              
             Compare/Verify all of the value properties of a test object with a benchmark file.
             The benchmark file is expected to be stored in the active "Bench" directory.  
             If you specify a relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    <LI>Google Android</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchFile -- Optional:NO
             The name of the file used to store the benchmark property data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when loading data from the file.
             
    </UL>

     **********/
    public ComponentFunction verifyPropertiesToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyPropertiesToFile.parameters = null");
        return GenericMasterFunctions.verifyPropertiesToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Compare/Verify ALL of the value properties of a test object with a benchmark file.
              
             Compare/Verify all of the value properties of a test object with a benchmark file.
             The benchmark file is expected to be stored in the active "Bench" directory.  
             If you specify a relative path, the path will be relative to the project
             directory.  The directory for a full or relative path must already exist.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Apple IOS</LI>
    <LI>Google Android</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchFile -- Optional:NO
             The name of the file used to store the benchmark property data.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when loading data from the file.
             
    </UL>

     **********/
    public void verifyPropertiesToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyPropertiesToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyPropertiesToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyPropertiesToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify the value of a single object property
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param propertyName  Optional:NO
             The case-sensitive name of the object property to verify.
              
     @param expectedValue  Optional:NO
             The case-sensitive value we expect to get from the object property.
              
     @param caseInsensitive  Optional:YES
             Values of "CASE-INSENSITIVE", "CASEINSENSITIVE", and "FALSE" will cause the 
             comparison of the property value and the expected value to ignore case.
              
     **********/
    public ComponentFunction verifyProperty(String propertyName, String expectedValue, String caseInsensitive ) {

        if ( expectedValue == null ) throw new IllegalArgumentException ( "verifyProperty.expectedValue = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "verifyProperty.propertyName = null");
        return GenericMasterFunctions.verifyProperty(getWindow().getName(), getName(), propertyName, expectedValue, caseInsensitive);
    }

    /*********** <pre>
             Verify the value of a single object property
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param propertyName  Optional:NO
             The case-sensitive name of the object property to verify.
              
     @param expectedValue  Optional:NO
             The case-sensitive value we expect to get from the object property.
              
     @param caseInsensitive  Optional:YES
             Values of "CASE-INSENSITIVE", "CASEINSENSITIVE", and "FALSE" will cause the 
             comparison of the property value and the expected value to ignore case.
              
     **********/
    public void verifyProperty(StepTestTable table, String propertyName, String expectedValue, String caseInsensitive ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyProperty.table = null");

        if ( expectedValue == null ) throw new IllegalArgumentException ( "verifyProperty.expectedValue = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "verifyProperty.propertyName = null");
        table.add( GenericMasterFunctions.verifyProperty(getWindow().getName(), getName(), propertyName, expectedValue, caseInsensitive));
    }

    /*********** <pre>
             Verify the value of a single object property
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property to verify.
              <BR/>         expectedValue -- Optional:NO
             The case-sensitive value we expect to get from the object property.
              <BR/>         caseInsensitive -- Optional:YES
             Values of "CASE-INSENSITIVE", "CASEINSENSITIVE", and "FALSE" will cause the 
             comparison of the property value and the expected value to ignore case.
              
    </UL>

     **********/
    public ComponentFunction verifyProperty(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyProperty.parameters = null");
        return GenericMasterFunctions.verifyProperty(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify the value of a single object property
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property to verify.
              <BR/>         expectedValue -- Optional:NO
             The case-sensitive value we expect to get from the object property.
              <BR/>         caseInsensitive -- Optional:YES
             Values of "CASE-INSENSITIVE", "CASEINSENSITIVE", and "FALSE" will cause the 
             comparison of the property value and the expected value to ignore case.
              
    </UL>

     **********/
    public void verifyProperty(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyProperty.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyProperty.parameters = null");
        table.add( GenericMasterFunctions.verifyProperty(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify that the value of an object property contains a string
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param propertyName  Optional:NO
             The case-sensitive name of the object property to verify.
              
     @param searchString  Optional:NO
             The case-sensitive value we expect the object property to contain.
              
     @param caseInsensitive  Optional:YES
             Values of "CASE-INSENSITIVE", "CASEINSENSITIVE", and "FALSE" will cause the 
             comparison of the property value and the expected value to ignore case.
              
     **********/
    public ComponentFunction verifyPropertyContains(String propertyName, String searchString, String caseInsensitive ) {

        if ( propertyName == null ) throw new IllegalArgumentException ( "verifyPropertyContains.propertyName = null");
        if ( searchString == null ) throw new IllegalArgumentException ( "verifyPropertyContains.searchString = null");
        return GenericMasterFunctions.verifyPropertyContains(getWindow().getName(), getName(), propertyName, searchString, caseInsensitive);
    }

    /*********** <pre>
             Verify that the value of an object property contains a string
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param propertyName  Optional:NO
             The case-sensitive name of the object property to verify.
              
     @param searchString  Optional:NO
             The case-sensitive value we expect the object property to contain.
              
     @param caseInsensitive  Optional:YES
             Values of "CASE-INSENSITIVE", "CASEINSENSITIVE", and "FALSE" will cause the 
             comparison of the property value and the expected value to ignore case.
              
     **********/
    public void verifyPropertyContains(StepTestTable table, String propertyName, String searchString, String caseInsensitive ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyPropertyContains.table = null");

        if ( propertyName == null ) throw new IllegalArgumentException ( "verifyPropertyContains.propertyName = null");
        if ( searchString == null ) throw new IllegalArgumentException ( "verifyPropertyContains.searchString = null");
        table.add( GenericMasterFunctions.verifyPropertyContains(getWindow().getName(), getName(), propertyName, searchString, caseInsensitive));
    }

    /*********** <pre>
             Verify that the value of an object property contains a string
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property to verify.
              <BR/>         searchString -- Optional:NO
             The case-sensitive value we expect the object property to contain.
              <BR/>         caseInsensitive -- Optional:YES
             Values of "CASE-INSENSITIVE", "CASEINSENSITIVE", and "FALSE" will cause the 
             comparison of the property value and the expected value to ignore case.
              
    </UL>

     **********/
    public ComponentFunction verifyPropertyContains(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyPropertyContains.parameters = null");
        return GenericMasterFunctions.verifyPropertyContains(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify that the value of an object property contains a string
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>Apple IOS</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property to verify.
              <BR/>         searchString -- Optional:NO
             The case-sensitive value we expect the object property to contain.
              <BR/>         caseInsensitive -- Optional:YES
             Values of "CASE-INSENSITIVE", "CASEINSENSITIVE", and "FALSE" will cause the 
             comparison of the property value and the expected value to ignore case.
              
    </UL>

     **********/
    public void verifyPropertyContains(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyPropertyContains.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyPropertyContains.parameters = null");
        table.add( GenericMasterFunctions.verifyPropertyContains(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify the value of a single object property with a benchmark file
              
             Verify the value of a single object property with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param propertyName  Optional:NO
             The case-sensitive name of the object property to verify.
              
     @param benchmarkFile  Optional:NO
             The name of the file used as the comparison benchmark.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when opening a bench file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public ComponentFunction verifyPropertyToFile(String propertyName, String benchmarkFile, String fileEncoding, String filterMode, String filterOptions ) {

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyPropertyToFile.benchmarkFile = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "verifyPropertyToFile.propertyName = null");
        return GenericMasterFunctions.verifyPropertyToFile(getWindow().getName(), getName(), propertyName, benchmarkFile, fileEncoding, filterMode, filterOptions);
    }

    /*********** <pre>
             Verify the value of a single object property with a benchmark file
              
             Verify the value of a single object property with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param propertyName  Optional:NO
             The case-sensitive name of the object property to verify.
              
     @param benchmarkFile  Optional:NO
             The name of the file used as the comparison benchmark.
              
     @param fileEncoding  Optional:YES  DefaultVal:
             Specify a character encoding to be used when opening a bench file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            
     @param filterMode  Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public void verifyPropertyToFile(StepTestTable table, String propertyName, String benchmarkFile, String fileEncoding, String filterMode, String filterOptions ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyPropertyToFile.table = null");

        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyPropertyToFile.benchmarkFile = null");
        if ( propertyName == null ) throw new IllegalArgumentException ( "verifyPropertyToFile.propertyName = null");
        table.add( GenericMasterFunctions.verifyPropertyToFile(getWindow().getName(), getName(), propertyName, benchmarkFile, fileEncoding, filterMode, filterOptions));
    }

    /*********** <pre>
             Verify the value of a single object property with a benchmark file
              
             Verify the value of a single object property with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property to verify.
              <BR/>         benchmarkFile -- Optional:NO
             The name of the file used as the comparison benchmark.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when opening a bench file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public ComponentFunction verifyPropertyToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyPropertyToFile.parameters = null");
        return GenericMasterFunctions.verifyPropertyToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify the value of a single object property with a benchmark file
              
             Verify the value of a single object property with a benchmark file.
             Typically, benchmarks are stored in the Datapool\Bench directory.
             In that event, only the filename.ext is needed.  There is currently
             a limit of 32K allowed for this type of comparison.
             
             The command will produce a TEST WARNING if the user has configured an 
             alternate DIFF tool for which we have no means to compare the diff results.
             If this WARNING is expected, the user should use the "TW" test record type.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Apple IOS</LI>
    <LI>Rational RobotJ</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    <LI>OpenQA Selenium</LI>
    <LI>OpenQA Selenium</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         propertyName -- Optional:NO
             The case-sensitive name of the object property to verify.
              <BR/>         benchmarkFile -- Optional:NO
             The name of the file used as the comparison benchmark.
              <BR/>         fileEncoding -- Optional:YES  DefaultVal:
             Specify a character encoding to be used when opening a bench file.
             If it is not specified, the system default file encoding will be used.
             The encoding should be a valid string supported by Java; if it is not valid,
             the system default file encoding will be used instead.
            <BR/>         filterMode -- Optional:YES  DefaultVal:
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal:
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public void verifyPropertyToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyPropertyToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyPropertyToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyPropertyToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
                 Attempts to verify the tab order of the specified object--usually a Window.
               
  Attempts to verify the tab order of the current object--usually a Window.
  A file is used to store the correct tab order of the interface. 

  The file is simply a list of component names in the order we expect to find
  them as we tab through the interface.  Each line in the file will contain a
  single component name.  That can be either the real valid Name given to the
  component by development, or the name for the component from the AppMap.  The
  AppMap name is highly recommended to reduce maintenance of the tab order file.
  Blank lines or commented lines are ignored.  Comment lines begin with
  apostrophe(') or semi-colon(;) characters.

  Example file:
  
          ;Tab Order Benchmark File
          ;For ClassicC Login Window
          (blank)
          UserIDComboBox
          PasswordEditBox
          RememberCheckBox
          (blank)
          OKButton
          CancelButton
  
  This file would normally be placed in the Datapool\Bench directory.

  The function will verify that the object order in the interface is the same
  object order that is in the file. This is done by checking the FOCUS
  Property of the current object and using the TAB key for navigation.
  Thus, navigation by the TAB key must be supported by the application.

  The routine will only check the tab order for the number of items found
  in the tab order benchmark file.  Thus, the user can perform partial tests
  on different portions of the interface at different times.  Just make sure
  that the item that currently has the focus is the first item in the tab order
  benchmark file when invoking this command.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param fileName  Optional:NO
                Filename of TabOrder benchmark file.
              
     **********/
    public ComponentFunction verifyTabOrder(String fileName ) {

        if ( fileName == null ) throw new IllegalArgumentException ( "verifyTabOrder.fileName = null");
        return GenericMasterFunctions.verifyTabOrder(getWindow().getName(), getName(), fileName);
    }

    /*********** <pre>
                 Attempts to verify the tab order of the specified object--usually a Window.
               
  Attempts to verify the tab order of the current object--usually a Window.
  A file is used to store the correct tab order of the interface. 

  The file is simply a list of component names in the order we expect to find
  them as we tab through the interface.  Each line in the file will contain a
  single component name.  That can be either the real valid Name given to the
  component by development, or the name for the component from the AppMap.  The
  AppMap name is highly recommended to reduce maintenance of the tab order file.
  Blank lines or commented lines are ignored.  Comment lines begin with
  apostrophe(') or semi-colon(;) characters.

  Example file:
  
          ;Tab Order Benchmark File
          ;For ClassicC Login Window
          (blank)
          UserIDComboBox
          PasswordEditBox
          RememberCheckBox
          (blank)
          OKButton
          CancelButton
  
  This file would normally be placed in the Datapool\Bench directory.

  The function will verify that the object order in the interface is the same
  object order that is in the file. This is done by checking the FOCUS
  Property of the current object and using the TAB key for navigation.
  Thus, navigation by the TAB key must be supported by the application.

  The routine will only check the tab order for the number of items found
  in the tab order benchmark file.  Thus, the user can perform partial tests
  on different portions of the interface at different times.  Just make sure
  that the item that currently has the focus is the first item in the tab order
  benchmark file when invoking this command.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Mercury Interactive WinRunner</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param fileName  Optional:NO
                Filename of TabOrder benchmark file.
              
     **********/
    public void verifyTabOrder(StepTestTable table, String fileName ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyTabOrder.table = null");

        if ( fileName == null ) throw new IllegalArgumentException ( "verifyTabOrder.fileName = null");
        table.add( GenericMasterFunctions.verifyTabOrder(getWindow().getName(), getName(), fileName));
    }

    /*********** <pre> 
             Verify the current contents of a text file with a benchmark file (same as VerifyFileToFile).
              
             Verify the current contents of a text file with a benchmark file (same as VerifyFileToFile).
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param benchmarkFile  Optional:NO 
             File used as the comparison benchmark.
              
     @param actualFile  Optional:NO 
             File used as the comparison file under test.
              
     @param filterMode  Optional:YES  DefaultVal: 
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal: 
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public ComponentFunction verifyTextFileToFile(String benchmarkFile, String actualFile, String filterMode, String filterOptions ) {

        if ( actualFile == null ) throw new IllegalArgumentException ( "verifyTextFileToFile.actualFile = null");
        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyTextFileToFile.benchmarkFile = null");
        return GenericMasterFunctions.verifyTextFileToFile(getWindow().getName(), getName(), benchmarkFile, actualFile, filterMode, filterOptions);
    }

    /*********** <pre> 
             Verify the current contents of a text file with a benchmark file (same as VerifyFileToFile).
              
             Verify the current contents of a text file with a benchmark file (same as VerifyFileToFile).
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param benchmarkFile  Optional:NO 
             File used as the comparison benchmark.
              
     @param actualFile  Optional:NO 
             File used as the comparison file under test.
              
     @param filterMode  Optional:YES  DefaultVal: 
             (Future) Specify a file filter to use to process the text before comparison.
              
     @param filterOptions  Optional:YES  DefaultVal: 
             (Future) Specify filter options to use with the file filter.
              
     **********/
    public void verifyTextFileToFile(StepTestTable table, String benchmarkFile, String actualFile, String filterMode, String filterOptions ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyTextFileToFile.table = null");

        if ( actualFile == null ) throw new IllegalArgumentException ( "verifyTextFileToFile.actualFile = null");
        if ( benchmarkFile == null ) throw new IllegalArgumentException ( "verifyTextFileToFile.benchmarkFile = null");
        table.add( GenericMasterFunctions.verifyTextFileToFile(getWindow().getName(), getName(), benchmarkFile, actualFile, filterMode, filterOptions));
    }

    /*********** <pre> 
             Verify the current contents of a text file with a benchmark file (same as VerifyFileToFile).
              
             Verify the current contents of a text file with a benchmark file (same as VerifyFileToFile).
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO 
             File used as the comparison benchmark.
              <BR/>         actualFile -- Optional:NO 
             File used as the comparison file under test.
              <BR/>         filterMode -- Optional:YES  DefaultVal: 
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal: 
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public ComponentFunction verifyTextFileToFile(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyTextFileToFile.parameters = null");
        return GenericMasterFunctions.verifyTextFileToFile(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre> 
             Verify the current contents of a text file with a benchmark file (same as VerifyFileToFile).
              
             Verify the current contents of a text file with a benchmark file (same as VerifyFileToFile).
             Typically, benchmarks are stored in the Datapool\Bench directory.  
             Typically, files to test are stored in the Datapool\Test directory.  
             In that event, the filename.ext is needed for both files.
             The Window and Component objects are not validated and have no role.
             The Window and Component strings can be any text, but they cannot be blank.
             
             The command may produce a WARNING if a diff tool for which we 
             have no means to verify the results is configured for use.  
             Consequently, if these warnings are expected, the user can use the 
             "TW" test record type to avoid issuing these warnings.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         benchmarkFile -- Optional:NO 
             File used as the comparison benchmark.
              <BR/>         actualFile -- Optional:NO 
             File used as the comparison file under test.
              <BR/>         filterMode -- Optional:YES  DefaultVal: 
             (Future) Specify a file filter to use to process the text before comparison.
              <BR/>         filterOptions -- Optional:YES  DefaultVal: 
             (Future) Specify filter options to use with the file filter.
              
    </UL>

     **********/
    public void verifyTextFileToFile(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyTextFileToFile.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyTextFileToFile.parameters = null");
        table.add( GenericMasterFunctions.verifyTextFileToFile(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify that a string value contains a substring
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param value  Optional:NO
             The case-sensitive string value to verify.
              
     @param searchString  Optional:NO
             The case-sensitive value we expect the preceeding string to contain.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public ComponentFunction verifyValueContains(String value, String searchString, String suppressValue ) {

        if ( searchString == null ) throw new IllegalArgumentException ( "verifyValueContains.searchString = null");
        if ( value == null ) throw new IllegalArgumentException ( "verifyValueContains.value = null");
        return GenericMasterFunctions.verifyValueContains(getWindow().getName(), getName(), value, searchString, suppressValue);
    }

    /*********** <pre>
             Verify that a string value contains a substring
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param value  Optional:NO
             The case-sensitive string value to verify.
              
     @param searchString  Optional:NO
             The case-sensitive value we expect the preceeding string to contain.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public void verifyValueContains(StepTestTable table, String value, String searchString, String suppressValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValueContains.table = null");

        if ( searchString == null ) throw new IllegalArgumentException ( "verifyValueContains.searchString = null");
        if ( value == null ) throw new IllegalArgumentException ( "verifyValueContains.value = null");
        table.add( GenericMasterFunctions.verifyValueContains(getWindow().getName(), getName(), value, searchString, suppressValue));
    }

    /*********** <pre>
             Verify that a string value contains a substring
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value -- Optional:NO
             The case-sensitive string value to verify.
              <BR/>         searchString -- Optional:NO
             The case-sensitive value we expect the preceeding string to contain.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public ComponentFunction verifyValueContains(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValueContains.parameters = null");
        return GenericMasterFunctions.verifyValueContains(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify that a string value contains a substring
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value -- Optional:NO
             The case-sensitive string value to verify.
              <BR/>         searchString -- Optional:NO
             The case-sensitive value we expect the preceeding string to contain.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public void verifyValueContains(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValueContains.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValueContains.parameters = null");
        table.add( GenericMasterFunctions.verifyValueContains(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify that a string value contains a substring, ignoring case.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SmartBear TestComplete</LI>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param value  Optional:NO
             The case-insensitive string value to verify.
              
     @param searchString  Optional:NO
             The case-insensitive value we expect the preceeding string to contain.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public ComponentFunction verifyValueContainsIgnoreCase(String value, String searchString, String suppressValue ) {

        if ( searchString == null ) throw new IllegalArgumentException ( "verifyValueContainsIgnoreCase.searchString = null");
        if ( value == null ) throw new IllegalArgumentException ( "verifyValueContainsIgnoreCase.value = null");
        return GenericMasterFunctions.verifyValueContainsIgnoreCase(getWindow().getName(), getName(), value, searchString, suppressValue);
    }

    /*********** <pre>
             Verify that a string value contains a substring, ignoring case.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SmartBear TestComplete</LI>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param value  Optional:NO
             The case-insensitive string value to verify.
              
     @param searchString  Optional:NO
             The case-insensitive value we expect the preceeding string to contain.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public void verifyValueContainsIgnoreCase(StepTestTable table, String value, String searchString, String suppressValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValueContainsIgnoreCase.table = null");

        if ( searchString == null ) throw new IllegalArgumentException ( "verifyValueContainsIgnoreCase.searchString = null");
        if ( value == null ) throw new IllegalArgumentException ( "verifyValueContainsIgnoreCase.value = null");
        table.add( GenericMasterFunctions.verifyValueContainsIgnoreCase(getWindow().getName(), getName(), value, searchString, suppressValue));
    }

    /*********** <pre>
             Verify that a string value contains a substring, ignoring case.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SmartBear TestComplete</LI>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value -- Optional:NO
             The case-insensitive string value to verify.
              <BR/>         searchString -- Optional:NO
             The case-insensitive value we expect the preceeding string to contain.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public ComponentFunction verifyValueContainsIgnoreCase(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValueContainsIgnoreCase.parameters = null");
        return GenericMasterFunctions.verifyValueContainsIgnoreCase(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify that a string value contains a substring, ignoring case.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SmartBear TestComplete</LI>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value -- Optional:NO
             The case-insensitive string value to verify.
              <BR/>         searchString -- Optional:NO
             The case-insensitive value we expect the preceeding string to contain.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public void verifyValueContainsIgnoreCase(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValueContainsIgnoreCase.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValueContainsIgnoreCase.parameters = null");
        table.add( GenericMasterFunctions.verifyValueContainsIgnoreCase(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify that a string value does NOT contain a substring
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param value  Optional:NO
             The case-sensitive string value to verify.
              
     @param searchString  Optional:NO
             The case-sensitive value we do NOT want to find in the provided Value.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public ComponentFunction verifyValueDoesNotContain(String value, String searchString, String suppressValue ) {

        if ( searchString == null ) throw new IllegalArgumentException ( "verifyValueDoesNotContain.searchString = null");
        if ( value == null ) throw new IllegalArgumentException ( "verifyValueDoesNotContain.value = null");
        return GenericMasterFunctions.verifyValueDoesNotContain(getWindow().getName(), getName(), value, searchString, suppressValue);
    }

    /*********** <pre>
             Verify that a string value does NOT contain a substring
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param value  Optional:NO
             The case-sensitive string value to verify.
              
     @param searchString  Optional:NO
             The case-sensitive value we do NOT want to find in the provided Value.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public void verifyValueDoesNotContain(StepTestTable table, String value, String searchString, String suppressValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValueDoesNotContain.table = null");

        if ( searchString == null ) throw new IllegalArgumentException ( "verifyValueDoesNotContain.searchString = null");
        if ( value == null ) throw new IllegalArgumentException ( "verifyValueDoesNotContain.value = null");
        table.add( GenericMasterFunctions.verifyValueDoesNotContain(getWindow().getName(), getName(), value, searchString, suppressValue));
    }

    /*********** <pre>
             Verify that a string value does NOT contain a substring
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value -- Optional:NO
             The case-sensitive string value to verify.
              <BR/>         searchString -- Optional:NO
             The case-sensitive value we do NOT want to find in the provided Value.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public ComponentFunction verifyValueDoesNotContain(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValueDoesNotContain.parameters = null");
        return GenericMasterFunctions.verifyValueDoesNotContain(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify that a string value does NOT contain a substring
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value -- Optional:NO
             The case-sensitive string value to verify.
              <BR/>         searchString -- Optional:NO
             The case-sensitive value we do NOT want to find in the provided Value.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public void verifyValueDoesNotContain(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValueDoesNotContain.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValueDoesNotContain.parameters = null");
        table.add( GenericMasterFunctions.verifyValueDoesNotContain(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify that two string values are identical. Note: RobotJ
             also uses identical keyword 'VerifyValueEquals'
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param value1  Optional:NO
              A case-sensitive string value to compare.
              
     @param value2  Optional:NO
             A case-sensitive value to compare.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public ComponentFunction verifyValues(String value1, String value2, String suppressValue ) {

        if ( value1 == null ) throw new IllegalArgumentException ( "verifyValues.value1 = null");
        if ( value2 == null ) throw new IllegalArgumentException ( "verifyValues.value2 = null");
        return GenericMasterFunctions.verifyValues(getWindow().getName(), getName(), value1, value2, suppressValue);
    }

    /*********** <pre>
             Verify that two string values are identical. Note: RobotJ
             also uses identical keyword 'VerifyValueEquals'
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param value1  Optional:NO
              A case-sensitive string value to compare.
              
     @param value2  Optional:NO
             A case-sensitive value to compare.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public void verifyValues(StepTestTable table, String value1, String value2, String suppressValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValues.table = null");

        if ( value1 == null ) throw new IllegalArgumentException ( "verifyValues.value1 = null");
        if ( value2 == null ) throw new IllegalArgumentException ( "verifyValues.value2 = null");
        table.add( GenericMasterFunctions.verifyValues(getWindow().getName(), getName(), value1, value2, suppressValue));
    }

    /*********** <pre>
             Verify that two string values are identical. Note: RobotJ
             also uses identical keyword 'VerifyValueEquals'
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value1 -- Optional:NO
              A case-sensitive string value to compare.
              <BR/>         value2 -- Optional:NO
             A case-sensitive value to compare.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public ComponentFunction verifyValues(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValues.parameters = null");
        return GenericMasterFunctions.verifyValues(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify that two string values are identical. Note: RobotJ
             also uses identical keyword 'VerifyValueEquals'
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value1 -- Optional:NO
              A case-sensitive string value to compare.
              <BR/>         value2 -- Optional:NO
             A case-sensitive value to compare.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public void verifyValues(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValues.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValues.parameters = null");
        table.add( GenericMasterFunctions.verifyValues(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify that two string values are identical, ignoring case.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param value1  Optional:NO
              A case-insensitive string value to compare.
              
     @param value2  Optional:NO
             A case-insensitive value to compare.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public ComponentFunction verifyValuesIgnoreCase(String value1, String value2, String suppressValue ) {

        if ( value1 == null ) throw new IllegalArgumentException ( "verifyValuesIgnoreCase.value1 = null");
        if ( value2 == null ) throw new IllegalArgumentException ( "verifyValuesIgnoreCase.value2 = null");
        return GenericMasterFunctions.verifyValuesIgnoreCase(getWindow().getName(), getName(), value1, value2, suppressValue);
    }

    /*********** <pre>
             Verify that two string values are identical, ignoring case.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param value1  Optional:NO
              A case-insensitive string value to compare.
              
     @param value2  Optional:NO
             A case-insensitive value to compare.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public void verifyValuesIgnoreCase(StepTestTable table, String value1, String value2, String suppressValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValuesIgnoreCase.table = null");

        if ( value1 == null ) throw new IllegalArgumentException ( "verifyValuesIgnoreCase.value1 = null");
        if ( value2 == null ) throw new IllegalArgumentException ( "verifyValuesIgnoreCase.value2 = null");
        table.add( GenericMasterFunctions.verifyValuesIgnoreCase(getWindow().getName(), getName(), value1, value2, suppressValue));
    }

    /*********** <pre>
             Verify that two string values are identical, ignoring case.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value1 -- Optional:NO
              A case-insensitive string value to compare.
              <BR/>         value2 -- Optional:NO
             A case-insensitive value to compare.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public ComponentFunction verifyValuesIgnoreCase(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValuesIgnoreCase.parameters = null");
        return GenericMasterFunctions.verifyValuesIgnoreCase(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify that two string values are identical, ignoring case.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>Rational Robot</LI>
    <LI>Rational RobotJ</LI>
    <LI>SAFS TIDComponent</LI>
    <LI>Mercury Interactive WinRunner</LI>
    <LI>Automated QA TestComplete</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value1 -- Optional:NO
              A case-insensitive string value to compare.
              <BR/>         value2 -- Optional:NO
             A case-insensitive value to compare.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public void verifyValuesIgnoreCase(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValuesIgnoreCase.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValuesIgnoreCase.parameters = null");
        table.add( GenericMasterFunctions.verifyValuesIgnoreCase(getWindow().getName(), getName(), parameters));
    }

    /*********** <pre>
             Verify that two string values are NOT identical.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param value1  Optional:NO
              A case-sensitive string value to compare.
              
     @param value2  Optional:NO
             A case-sensitive value to compare.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public ComponentFunction verifyValuesNotEqual(String value1, String value2, String suppressValue ) {

        if ( value1 == null ) throw new IllegalArgumentException ( "verifyValuesNotEqual.value1 = null");
        if ( value2 == null ) throw new IllegalArgumentException ( "verifyValuesNotEqual.value2 = null");
        return GenericMasterFunctions.verifyValuesNotEqual(getWindow().getName(), getName(), value1, value2, suppressValue);
    }

    /*********** <pre>
             Verify that two string values are NOT identical.
                  </pre>    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param value1  Optional:NO
              A case-sensitive string value to compare.
              
     @param value2  Optional:NO
             A case-sensitive value to compare.
              
     @param suppressValue  Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
     **********/
    public void verifyValuesNotEqual(StepTestTable table, String value1, String value2, String suppressValue ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValuesNotEqual.table = null");

        if ( value1 == null ) throw new IllegalArgumentException ( "verifyValuesNotEqual.value1 = null");
        if ( value2 == null ) throw new IllegalArgumentException ( "verifyValuesNotEqual.value2 = null");
        table.add( GenericMasterFunctions.verifyValuesNotEqual(getWindow().getName(), getName(), value1, value2, suppressValue));
    }

    /*********** <pre>
             Verify that two string values are NOT identical.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value1 -- Optional:NO
              A case-sensitive string value to compare.
              <BR/>         value2 -- Optional:NO
             A case-sensitive value to compare.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public ComponentFunction verifyValuesNotEqual(String[] parameters ) {

        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValuesNotEqual.parameters = null");
        return GenericMasterFunctions.verifyValuesNotEqual(getWindow().getName(), getName(), parameters);
    }

    /*********** <pre>
             Verify that two string values are NOT identical.
                  </pre>    
    Supporting Engines:
    <P/><UL>
    <LI>SAFS TIDComponent</LI>
    </UL>

     @param table  Optional:NO
            The table to add the record to.
     @param parameters  Optional:NO
            An array containing the following parameters:
    <UL>
<BR/>         value1 -- Optional:NO
              A case-sensitive string value to compare.
              <BR/>         value2 -- Optional:NO
             A case-sensitive value to compare.
              <BR/>         suppressValue -- Optional:YES
             Set to "SUPPRESSVALUE" to prevent the logging of ugly multi-line values.
              
    </UL>

     **********/
    public void verifyValuesNotEqual(StepTestTable table, String[] parameters ) {

        if ( table == null ) throw new IllegalArgumentException ( "verifyValuesNotEqual.table = null");
        if ( parameters == null ) throw new IllegalArgumentException ( "verifyValuesNotEqual.parameters = null");
        table.add( GenericMasterFunctions.verifyValuesNotEqual(getWindow().getName(), getName(), parameters));
    }

}
