<HTML>
<HEAD>
<TITLE>
Using JSAFS
</TITLE>
</HEAD>
<BODY>
<center><H1>Using JSAFS, the Java API for SAFS</H1></center>
<p>
<hr>
Author: Carl Nagle<br/>
 Since: MAR 30, 2006<br/>
Update: MAY 31, 2013
<p>
Copyright, SAS Institute
<a href="http://www.sas.com" target="altwin">http://www.sas.com</a><br/>
<a href="http://www.opensource.org/licenses/gpl-license.php" target="altwin">General Public License (GPL)</a>:&nbsp;
http://www.opensource.org/licenses/gpl-license.php<br/>
<hr>
<a name="top"/>
<P>
JSAFS Developers should refer to: <a href="http://safsdev.sourceforge.net/doc/javadoc.html" target="_blank">SAFS JavaDoc</a>.<br/>
Key documentation of interest therein are the packages for:
<p><ul>
<li><a href="http://safsdev.sourceforge.net/doc/org/safs/model/commands/package-summary.html" target="_api">org.safs.model.commands</a>
<li><a href="http://safsdev.sourceforge.net/doc/org/safs/model/components/package-summary.html" target="_api">org.safs.model.components</a>
<li><a href="http://safsdev.sourceforge.net/doc/org/safs/model/examples/advanced/package-summary.html" target="_api">org.safs.model.examples.advanced</a>
<li><a href="http://safsdev.sourceforge.net/doc/org/safs/model/tools/package-summary.html" target="_api">org.safs.model.tools</a>
</ul>
<p>
<a href="http://safsdev.sourceforge.net/sqabasic2000/SetupJSAFS.README.htm" target="_blank" alt"JSAFS Install and Setup Instructions" title="JSAFS Install and Setup Instructions">Installation and setup of Instructions for JSAFS</a>.
<p>
The source and class files for the JSAFS API are provided in <b><i>safsmodel.jar</i></b>.<br/>
Note, also, the documentation for the <a href="http://safsdev.sourceforge.net/doc/org/safs/tools/drivers/JSAFSDriver.html" target="_api">JSAFSDriver</a>--intended for Advanced Runtime frameworks and scenarios (discussed later).
<p>
<hr>
<a name="background"/>
<small><a href="#top">Back To Top</a>, <a href="#designtime">Design-Time Test Table Development</a>, <a href="#advancedruntime">Advanced Runtime Development</a></small>
<H3><i>What exactly is JSAFS?</i></H3>

JSAFS is a Java API for writing tool-independent tests that can be executed in the SAFS environment. &nbsp;The SAFS environment provides these key test automation features not readily available in one package anywhere else:
<p>
<ul><dl>

<dt><b>SAFSLOGS</b> and <b>Debug Logs</b>

<p><dd>Advanced centralized logging available for all processes running on the machine.<br/>
	All test services, test drivers, test engines, and custom processes--whether they are Java, C/C++, COM, .Net, Perl, Python, VBScript, Ruby, etc...all can write to one or more common test logs and Debug Logs. &nbsp;All testing tools and processes--including those executing on remote devices like Android and iPhone also write to these same logs. &nbsp;Logs can be written in either or both Text and XML formats.

<p><dt><b>SAFSMAPS</b>

<p><dd>Advanced centralized mapping (INI/Properties) storage for all processes running on the machine.<br/>
	All test services, test drivers, test engines, and custom processes--whether they are Java, C/C++, COM, .Net, Perl, Python, VBScript, Ruby, etc...all can access the stored values. &nbsp;SAFSMAPS also integrates with SAFSVARS for dynamic embedded variable resolution to allow non-static values to be created and retrieved at runtime. &nbsp;Maps and values can be "chained"--allowing seemless lookup for localization/NLS values across multiple map files.

<p><dt><b>SAFSVARS</b>

<p><dd>Advanced centralized variables storage for all processes running on the machine.<br/>
	All test services, test drivers, test engines, and custom processes--whether they are Java, C/C++, COM, .Net, Perl, Python, VBScript, Ruby, etc...all can read and write shared variable values. &nbsp;SAFSVARS also integrates with SAFSMAPS to provide "constants" stored in Map files. &nbsp;SAFSVARS provides variable values to SAFSMAPS at runtime for dynamic embedded variable resolution of non-static map values.

<p><dt><b>Advanced NLS/Localization Support</b>

<p><dd>The "chaining" of mutliple SAFSMAPS Map files combined with SAFSVARS variable embedding in mapped values provides outstanding support for "write once run everywhere" when it comes to testing an application across multiple languages or configurations. &nbsp;A "generic" Map file containing no language dependencies can be chained to an English-language map file, or a Chinese Map file, or any other Map file needed for the particular test configuration/language being tested. &nbsp;These can also be dynamically swapped in and out at runtime.

<p><dt><b>Tool-independent Interface to Common Test Automation Tools</b>

<p><dd>JSAFS provides a Java API for common test automation actions and activities regardless of which test automation tool is going to be used to actually run them. &nbsp;A JSAFS test can be used to drive IBM Rational Functional Tester, SmartBear Test Complete, SAFS/Robotium Remote Control for Android, Apple SDK iOS UIAutomation, and any other test automation tool made available as a SAFS execution engine. &nbsp;Because this is one common API for all testing tools, the tester or developer is able to migrate from one tool to another as needed without having to learn each new test tool IDE or API.

</dl></ul>
<p>
When used as a form of "<a href="#designtime">Design Time</a>" test table development, it is an API that ultimately exports <a href="http://sourceforge.net/apps/mediawiki/safsdev/index.php?title=SAFS_Record_Formats" target="_blank">SAFS test records and tables</a> in the text format used in the traditional SAFS runtime environment. &nbsp;This is a seldom used feature as most developers will want to use the Advanced runtime features below.
<p>
With the "<a href="#advancedruntime">Advanced Runtime</a>", the Java code *is* the test and it contains runtime calls to the SAFS framework to accomplish tool-independent test activities. &nbsp;There generally are no SAFS test tables created and all testing is driven from the developer's independent JSAFS-enabled Java program.
<p>
<ul><b>In either case, the Java "program" and the tests that ultimately result from it are not tied to any specific execution engine or automation tool. &nbsp;The developer can use any testing tool supported by SAFS. &nbsp;These are SAFS tool-independent tests!</b>
</ul><p>
While the JSAFS API is provided for Java test development, the code or applications to be tested are not limited to Java clients.&nbsp; You can develop tests for:
<p>
<ul>
<li>Android Devices
<li>Apple iOS Devices
<li>Java,
<li>Web,
<li>.NET,
<li>Flex,
<li>VB,
<li>C\C++,
<li>COM,
<li>PowerBuilder,
<li>Delphi,
<li>Unit\API,
<li>Virtually any environment a SAFS execution engine can support.
</ul>
<p>
The most common SAFS engines (testing tools) in use are:
<p>
<ul>
<li>SAFS Driver Commands (SDC),
<li>SmartBear Test Complete®,
<li>Android SDK SAFS/Robotium Remote Control,
<li>IBM Rational Functional Tester®,
<li>Apple SDK iOS UIAutomation
<li>SAFS Image-Based Testing (IBT)
<p>
Some other engine possibilities are:
<p>
<li>HP QuickTest Professional®,
<li>Selenium, Selenium WebDriver,
<li>WSH VBScript,
<li>WSH JavaScript,
<li>Java,
<li>C\C++,
<li>COM,
<li>.Net,
<li>Perl,
<li>Python,
<li>Ruby,
<li>jUnit,
<li>Almost any 3rd party automation tool or suite...
</ul>
<p>

<H3><i>Why use JSAFS?</i></H3>

<p>
JSAFS attempts to engage Java-savvy developers and testers exploiting tools like Eclipse allowing them to develop tool-independent SAFS tests in a familiar development environment (IDE). &nbsp;It allows them to code tests that are still independent of the testing tools used at runtime while leveraging the Java IDE to provide a wealth of information and documentation for the JSAFS API and the SAFS Keyword implementations--the <a href="SAFSReference.php" target="_blank">SAFS Reference</a>.
<p>
The detailed information provided in the SAFS Reference is encapsulated into Java functions with JavaDoc. &nbsp;Thus, the Java IDE is able to present this information to the developer in a context-sensitive manner via the auto-complete, tooltips and popups they already know. &nbsp;Every SAFS command is available as a "callable" function. &nbsp;Documentation for commands, component types, available functions, and parameters are available in the IDE, as shown below.
<p>
<center><b>Sample Eclipse IDE Snapshot</b>:
<p>
<img border="1" src="jsafs_ide.gif" alt="Eclipse IDE Snapshot"/></center>
<p>


<H3><i>How would I use JSAFS?</i></H3>


The SAFS framework has been designed from the ground up with an open architecture. &nbsp;It is a collection of testing tools and utilities connected together through a SAFS-defined protocol using <a href="http://staf.sourceforge.net" target="_blank">STAF</a>.
<p>
Java is an especially well-supported interface into SAFS which means Java developers using JSAFS have nearly endless possibilities for how they can exploit SAFS. &nbsp;Other programming languages like VBScript, Perl, and C\C++ are also well supported, but do not (yet) have a comprehensive API interface to SAFS like JSAFS.
<p>
The potential for using JSAFS can generally fall into the two broadly-defined categories previously mentioned:
<ul>
<table>
<tr><td><a href="#designtime">Design-time Test Table Development</a>:&nbsp;
    <td>Build tests that export tables for traditional SAFS processing later. (Rarely used)
<tr><td><a href="#advancedruntime">Advanced Runtime Development</a>:
    <td>Use SAFS services and test tool engines controlled by your Java program at runtime.
</table>
</ul>
<hr>
<a name="designtime"/>
<small><a href="#top">Back To Top</a>, <a href="#background">Background Info</a>, <a href="#advancedruntime">Advanced Runtime Usage</a></small>


<H2><i>JSAFS Design-time Test Table Development</i></H2>


Design-time test development uses the JSAFS API in a Java IDE to build Java-based test records and tables.&nbsp; When the developer executes the Java code it does little more than export the test records and data as properly formatted SAFS text files. &nbsp;These files can then be executed by a standard SAFS runtime environment like <a href="http://safsdev.sourceforge.net/doc/org/safs/tools/drivers/SAFSDRIVER.html" target="_blank">SAFSDRIVER</a>. &nbsp;The standard SAFS runtime handles all the usual test processing, expression handling, NLS lookups, etc...
<p>
The developer's Java code does not actually <i>"run"</i> the tests. &nbsp;However, the developer can embed code to launch a suitable SAFS runtime <b><i>after</i></b> the tests have been exported.
<p>
For the following discussion, refer to the '<b><i><a href="http://safsdev.sourceforge.net/doc/org/safs/model/package-summary.html" target="_api">org.safs.model</a></i></b>' package JavaDoc.
<p>
You will see in the <i>model</i> package we have both abstract and concrete classes that represent the various pieces of a SAFS test.&nbsp; There are classes that represent the various record types like Driver Commands and Component Functions.&nbsp; There are classes that represent the different types of test tables: Cycle, Suite, and Step. &nbsp;There is even a 'Variable' class that represents a SAFS variable (a.k.a. DDVariable).
<p>
Now refer to the '<b><i><a href="http://safsdev.sourceforge.net/doc/org/safs/model/commands/package-summary.html" target="_api">org.safs.model.commands</a></i></b>' and the '<b><i><a href="http://safsdev.sourceforge.net/doc/org/safs/model/components/package-summary.html" target="_api">org.safs.model.components</a></i></b>' package documentation.
<p>
The 'components' package provides a means to represent your application GUI components in a JSAFS object that knows all the commands that can be executed on that type of component.&nbsp; The 'commands' package provides similar classes that allow you to call the same commands in an alternative manner. &nbsp;This is to accomodate different developer preferences.
<p>


<H3><i>Is there a 'Best Practice' for using JSAFS?</i></H3>


You will find that the API does not force developers down one specific path for SAFS test development.&nbsp; There are often a few different ways to get at similar results.&nbsp; This isn't just because we thought it would be nice. &nbsp;This is a direct result from developer feedback. &nbsp;We have developers wanting to write JSAFS tests in different ways, and with different philosophies and purpose.
<p>
For example, some developers have chosen to use Java Collections, Arrays, or even external sources to store or otherwise encapsulate application test data. &nbsp;Some use Java to loop through that data exporting a separate test record--or table of records--for every item to be used in the system. &nbsp;Further, they do the looping of the data in Java code to create 50 new hardcoded records for adding 50 new users and do NOT use any looping in the SAFS runtime. &nbsp;They do NOT use any global SAFS DDVariables--everything is hardcoded and linear in the exported test tables.
<p>
It sounds like a worst-case scenario for reuse, but it is not in most cases.&nbsp; For this scenario it is the JSAFS Java code that is the reusable asset, not the linearly hardcoded SAFS text files exported, executed, and ultimately discarded.&nbsp; There is not necessarily anything wrong with this in a JSAFS-only test.&nbsp; As the external data changes over time, the exported runtime test tables will reliably change along with the data.
<p>
<center><b>Sample Design-Time Usage Flow</b>:
<p>
<img src="jsafs_temptables.gif" alt="Sample Design-Time Usage Flow"/></center>
<p>&nbsp;
<p>
<b>Integrating with other non-JSAFS assets:</b><br/>
These JSAFS tests do not have to live in a JSAFS-only world.&nbsp; There may be developers writing JSAFS tests in their environment that must integrate with and have dependencies on SAFS tests developed in Access, Excel, TextPad, or some internal corporate proprietary tools.
<p>
Because the output of all of these are SAFS-compatible test tables, JSAFS tables can call Excel-based tables, and vice-versa.&nbsp; All that matters is that each tool has exported its test tables prior to execution.&nbsp; Once all the tables are in place, any table can call any other table because they are all compatible and ready for execution.
<p>
<center><b>Sample Design-Time Multi-Source Flow</b>:
<p>
<img src="jsafs_exports.gif" alt="Sample Design-Time Multi-Source Flow"/></center>
<p>&nbsp;
<p>
Such an environment may or may not require JSAFS table exports to be more reusable like those traditionally developed by other methods. &nbsp;That would be up to the collaborating team of testers and developers to decide and design into the overall test solution.
<p>
Refer to the sourcecode in the '<b><i><a href="http://safsdev.sourceforge.net/doc/org/safs/model/examples/tables/package-summary.html" target="_api">org.safs.model.examples.tables</a></i></b>' package and its subpackages for some simple examples of putting the JSAFS API to use. &nbsp;The sourcecode for the examples is also available in the <b>safsmodel.jar</b> file delivered with SAFS.
<p>
<a href="jsafs_design_example.txt" target="_blank" alt="Sample Design-Time Java Code"/>Sample Design-Time Java Code</a>.
<p>
The sourcecode examples represent just a few ways in which JSAFS tests could be constructed using Design-time Development.&nbsp; More examples will become available over time.  Now, let's take a look at the much broader possibilities provided by customizing SAFS with JSAFS Advanced Runtime Development.
<p>
<hr>
<a name="advancedruntime"/>

<small><a href="#top">Back To Top</a>, <a href="#background">Background Info</a>, <a href="#designtime">Design-Time Test Table Development</a></small>


<H2><i>JSAFS Advanced Runtime Development</i></H2>


Because JSAFS is a Java API, and because SAFS is largely Java-based, we are starting to see test developers using JSAFS in this Advanced Runtime execution mode. &nbsp;Essentially, the Java developer is coding their test logic in Java and foregoing the use of the SAFS test table processor <a href="http://safsdev.sourceforge.net/doc/org/safs/tools/drivers/SAFSDRIVER.html" alt="Standard SAFS Driver Class" target="_blank">SAFS DRIVER<a/> altogether. &nbsp;They are writing custom test drivers (and whole frameworks!) in Java--largely replacing SAFS test table logic with Java code. &nbsp;However, this Java code is still tool-independent and the tests still migrate from one testing tool to another as readily as any other SAFS test deployed as traditional test tables.
<p>
One possible (but rarely used) mechanism for using JSAFS in this way is for the new custom Java class to be a direct subclass of <a href="http://safsdev.sourceforge.net/doc/org/safs/tools/drivers/SAFSDRIVER.html" alt="SAFS Driver Class" target="_blank">SAFSDRIVER</a>, or its superclass: <a href="http://safsdev.sourceforge.net/doc/org/safs/tools/drivers/DefaultDriver.html" alt="Standard SAFS Driver Class" target="_blank">DefaultDriver</a>. &nbsp;By doing this, the developer inherits all the core startup and initialization capabilities of SAFSDRIVER--including the startup of required SAFS services and engines. &nbsp; In addition, the custom SAFS driver has easy API access to all the SAFS services for handling variables, appmaps, NLS, and logging. &nbsp;The new driver will also inherit the running <a href="http://safsdev.sourceforge.net/sqabasic2000/UsingSAFSMonitor.htm" alt="SAFS Monitor Doc" target="_blank">SAFS Monitor</a> allowing the tester or developer to Pause, Resume, Step, and Shutdown a running test, if desired.
<p>
<center><b>SAFS Monitor for Runtime Debugging</b>:
<p>
<img src="SAFSMonitor.jpg" alt="SAFS Monitor Application"/></center>
<p>
However, it is also possible to merely add a comparable <a href="http://safsdev.sourceforge.net/doc/org/safs/tools/drivers/JSAFSDriver.html" alt="JSAFS Driver Class" target="_blank">JSAFSDriver</a> object to any Java class or testing framework. &nbsp;The developer still acquires all the core startup and initialization capabilities of the standard SAFS Drivers--including the startup of required SAFS services and engines. &nbsp; The custom driver will still have access to the <a href="http://safsdev.sourceforge.net/sqabasic2000/UsingSAFSMonitor.htm" alt="SAFS Monitor Doc" target="_blank">SAFS Monitor</a> allowing the tester or developer to Pause, Resume, Step, and Shutdown a running test--assuming the developer exploits these features in their code. &nbsp;In addition, the JSAFSDriver provides convenient API access to all the SAFS services for handling variables, appmaps, NLS, logging, and expression handling.
<p>
Commented example(s) with sourcecode are provided in the <a href="http://safsdev.sourceforge.net/doc/org/safs/model/examples/advanced/package-summary.html" alt="JSAFS Advanced Examples Doc" target="_blank">org.safs.model.examples.advanced</a> package. &nbsp;The sourcecode can be found in the <b>safsmodel.jar</b> file in a SAFS\lib directory following the <a href="http://safsdev.sourceforge.net/sqabasic2000/SetupSAFS.README.htm" target="_blank" alt"SAFS Install Instructions" title="SAFS Install Instructions">installation and setup of SAFS</a>.  Also refer to additional <a href="http://safsdev.sourceforge.net/sqabasic2000/SetupJSAFS.README.htm" target="_blank" alt"JSAFS Developer Instructions" title="JSAFS Developer Instructions">developer instructions for JSAFS</a>.
<p>
The <a href="http://safsdev.sourceforge.net/doc/org/safs/tools/drivers/JSAFSDriver.html" alt="JSAFS Driver Class" target="_blank">JSAFSDriver</a> main(String[] args) sourcecode can also act as <a href="jsafs_advanced_example.txt" target="_blank" alt="Sample Advanced Runtime Java Code"/>an example</a> since it is a functional self-test of the class itself:
<p>
<hr>
<a name="bottom"/>
<small><a href="#top">Back To Top</a>, <a href="#background">Background Info</a>, <a href="#designtime">Design-Time Usage</a></small>
</BODY></HTML>